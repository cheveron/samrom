           ORG &C000
;MISCX1.SAM - START OF UPPER ROM. FIRST PART IS SECTIONS THAT ARE COPIED
;TO A RAM BUFFER FOR EXECUTION SO THE UPPER ROM CAN BE PAGED OUT AND
;THE BASIC PROGRAM GOT AT.

           ORG INSTBUF

;MOVED TO INSTBUF FOR EXECUTION

RNMP2:     LD HL,10
           LD   (RLINE),HL
           LD   (RSTEP),HL
           CALL BRKLSSL      ;ASSESS <N> TO <M>
           RST  &18
           LD   HL,RLINE
           CP   LINETOK
           CALL Z,REVAL
           LD   HL,RSTEP
           CP   STEPTOK
           CALL Z,REVAL
           CALL CHKEND

           LD B,24
           CALL TESTROOM     ;ABORT IF <6K FREE
           CALL SPSS

MAKETABLE: LD   HL,(RLINE)
           LD   BC,(RSTEP)
           LD   DE,SBN+2

           EXX
           LD   HL,SBO
           PUSH HL
           LD   DE,&0000

MKTBLP:    POP  HL           ;SBO
           LD   (HL),D
           INC  HL
           LD   (HL),E
           DEC  HL
           PUSH HL           ;SBO
           LD   HL,(LAST)    ;FEFF IF END OF PROG WANTED
           SBC  HL,DE
           JR C,RENUM3       ;JR IF LINE NUMBER JUST PLACED IS PAST BLOCK END
                             ;(COULD BE FF?? PROG TERMINATOR)
           CALL GTRLNN
           SCF
           SBC  HL,DE
           JR   NC,MKTBLP

           POP  HL
           INC  HL
           INC  HL
           PUSH HL

           EXX
           EX   DE,HL
           LD   (HL),D
           INC  HL
           LD   (HL),E
           INC  HL
           INC H
           JR Z,NRFLERR

           DEC H
           EX   DE,HL
           ADD  HL,BC        ;ADD LINE,STEP TO GET NEXT NEW LINE NO.
           JR C,NRFLERR

           LD A,H
           EXX

           INC  A
           JR   NZ,MKTBLP    ;LOOP UNLESS LINE NUMBERS TOO HIGH (>FEFF)

NRFLERR:   RST &08
           DB 33             ;'No room for line'

RENUM3:    POP BC
           LD HL,(SBO)
           LD (TEMPW1),HL    ;SAVE IT SO IT CAN BE READ WHEN SCREEN SWITCHED OUT
           CALL RCURP
           LD HL,PPC
           CALL TRANSHL
           PUSH BC
           LD A,(SUBPPC)
           PUSH AF

           LD A,D
           INC A
           JR NZ,REN3        ;JR IF DE IS A REAL LINE NUMBER

           LD E,A            ;ELSE DE=FF00, MAX LINE+1

REN3:      XOR A             ;NC
           PUSH DE
           EXX
           POP  DE
           SBC  HL,BC
           SBC  HL,BC
           SBC  HL,DE
           JR   NC,NRFLERR   ;ERROR IF MOVING LINES ONTO OTHERS

           LD   HL,(TEMPW1)
           LD   D,L
           LD   E,H
           LD   HL,(RLINE)
           SBC  HL,DE
           JR C,NRFLERR

           CALL CHGREF

;CHANGE LINE NUMBERS

           LD   HL,(FIRST)
           CALL FNDLINE

CHGLL:     LD   B,(HL)
           INC  HL
           LD   C,(HL)
           PUSH HL
           CALL TRANSFORM
           POP  HL
           JR C,REN5         ;JR IF FINISHED BLOCK

           LD   (HL),C
           DEC  HL
           LD   (HL),B       ;ALTER LINE NUMBER
           INC  HL
           INC  HL
           LD   C,(HL)
           INC  HL
           LD   B,(HL)       ;BC=LINE LEN
           INC  HL
           ADD  HL,BC        ;PT TO NEXT LINE
           CALL CHKHL
           JR   CHGLL

REN5:      LD HL,EPPC
           CALL TRANSHL
           LD L,SDTOP\256
           CALL TRANSHL
           CALL MCLS         ;CLEAR ENTIRE SCREEN
           JP GT4P           ;UNSTACK STAT, PPC, SET UP FOR GOTO NEXT, COMP

;CHANGE REFERENCES TO LINE NUMBERS

FAILED:    CALL FDELETE

NBLKL:     POP  BC
           POP  BC
           POP  BC
           JP CHGR7

CHGREF:    LD   IX,RENTAB-1

RENCL:     INC  IX
           CALL ADDRPROG
           LD A,(HL)
           INC A
           RET Z

           LD   (CLA),HL
           INC  HL
           INC  HL
           INC  HL
           INC  HL
           LD   (CHAD),HL

RLOOP:     LD   A,(IX+0)
           AND  A
           RET  Z

           LD   E,A
           CALL SRCHPROG
           JR   NC,RENCL

           LD   (SUBPPC),A
           IN   A,(251)
           LD   (CHADP),A
           LD A,(IX+0)
           CP LINETOK
           JR NZ,CHGRY

           DEC HL
           DEC HL
           LD A,(HL)         ;PT TO BYTE BEFORE "LINE"
           CP "$"
           JR Z,CHGRY        ;RENUM E.G. SAVE ASD$ LINE 10

           CP &22
           JR NZ,RLOOP       ;NO RENUM UNLESS E.G. SAVE "NAME" LINE 10

CHGRY:     RST  &18

CHGR1:     CP   TOTOK
           JR   NZ,CHGR2

           RST  &20

CHGR2:     PUSH HL
           LD   B,&FF
           CP   &DE          ;ONTOK
           JR   NZ,CHGR5

CHGR3:     RST  &20
           CP   ";"
           JR   NZ,CHGR3

           RST  &20
           POP  DE
           PUSH HL
           DB &11            ;'JR+2'

CHGR4:     INC HL
           LD A,(HL)

CHGR5:     CALL NUMERIC
           INC  B
           JR   C,CHGR4

           PUSH BC

CHGR6:     LD A,(HL)
           INC HL
           CP " "
           JR Z,CHGR6

           PUSH HL
           CP   &0E
           JR   NZ,NBLKL

           CALL HLTOFPCS
           LD   (CHAD),HL
           CALL GETINT
           RST  &18
           CALL COCRCOTO     ;CHECK FOR CR/:/TO/,
           JR NZ,FAILED

           CALL TRANSFORM
           JR   C,NBLKL

           CALL STACKBC      ;EXITS WITH DE=STKEND
           LD HL,-5
           ADD HL,DE         ;POINT TO TOP ITEM ON FPCS
           POP  DE
           CALL LDI5         ;COPY TO 5-BYTE BUFFER IN LINE
           CALL JPFSTRS      ;BC=NEW LEN OF NUMBER (DIGITS)
           POP  AF           ;ORIG NUMBER OF DIGITS
           POP  DE
           LD   HL,(CLA)

;ADJUST LINE LEN
;ENTRY: HL PTS TO START OF BASIC LINE, DE PTS TO SPACE TO OPEN OR CLOSE IN THE
;LINE, BC=NEW LENGTH OF SPACE, A=OLD LENGTH.

ADJLINE:   SUB C
           JR Z,ADLNO        ;JR IF LENS THE SAME

           INC  HL
           INC  HL
           PUSH BC
           PUSH AF
           LD   C,(HL)
           INC  HL
           LD   B,(HL)       ;CURRENT LINE LEN
           PUSH HL
           NEG
           LD   L,A
           RLA
           SBC  A,A
           LD   H,A
           ADD  HL,BC
           LD   B,H
           LD   C,L
           POP  HL
           LD   (HL),B
           DEC  HL
           LD   (HL),C       ;NEW LINE LEN
           POP  AF
           LD   B,0
           JR   NC,ADJL2     ;JR IF CLOSEING UP SPACE

           NEG
           LD   C,A
           EX   DE,HL
           CALL MAKEROOM
           JR   ADJL3

ADJL2:     LD   C,A
           EX DE,HL
           CALL RECLAIM2

ADJL3:     EX DE,HL
           POP BC

ADLNO:     LD HL,PRNBUFF
           LDIR
           EX DE,HL
           LD C,6
           ADD HL,BC
           LD (CHAD),HL

CHGR7:     CALL RCRC         ;RST 18, CRCOLON
           JP Z,RLOOP

           CALL COCRCOTO     ;Z IF TO/,
           JP NZ,RLOOP

           RST &20
           JP CHGR1

RENTAB:    DB &CD            ;DELETETOK
           DB &DD            ;ONERRORTOK
           DB &8C            ;LINETOK
           DB &BE            ;LLISTTOK
           DB &BD            ;LISTTOK
           DB &BA            ;RESTORETOK
           DB &B4            ;GOTOTOK
           DB &B5            ;GOSUBTOK
           DB &B0            ;RUNTOK
           DB 0

REVAL:     PUSH HL
           CALL GIR
           POP HL
           RET C

           LD A,B
           OR C
           JP Z,IOORERR

           LD (HL),C
           INC HL
           LD (HL),B
           RST &18
           RET

TRANSHL:   LD C,(HL)
           INC HL
           LD B,(HL)
           PUSH HL
           CALL TRANSFORM
           POP HL
           RET C             ;RET IF NOT IN BLOCK

           LD (HL),B
           DEC HL
           LD (HL),C
           RET

TRANSFORM: LD   HL,(LAST)
           AND  A
           SBC  HL,BC
           RET  C

           LD   HL,(FIRST)
           SBC  HL,BC
           JR   Z,TRANS2

           CCF
           RET  C

TRANS2:    CALL SPSS
           LD   HL,SBO+2

TRANS3:    LD A,(HL)
           CP B
           JR NZ,TRANS4

           INC HL
           LD A,(HL)
           DEC HL
           CP C

TRANS4:    JR   NC,TRANS5

           INC  HL
           INC  HL
           JR   TRANS3

TRANS5:    LD   A,H
           ADD  A,0+(SBN-SBO)/256   ;NC
           LD   H,A
           LD   B,(HL)
           INC  HL
           LD   C,(HL)
TRANSF:    JP   RCURP

RENLN:     EQU TRANSF+3-RNMP2

           ORG INSTBUF

GETP2:     CALL SYNTAX1      ;VALID VARIABLE
           CALL CHKEND

           LD HL,FLAGS
           PUSH HL
           RES 5,(HL)        ;'NO KEY'
           CALL WKBR         ;GET KEY WITH BREAK OPTION
           POP HL            ;FLAGS
           BIT 6,(HL)
           JR NZ,GT2         ;JR IF NUMERIC VALUE WANTED

           CALL STACKA

           DB CALC
           DB CHRS           ;CONVERT KEY VALUE TO STRING
           DB EXIT

           JR GT4

GT2:       CALL NUMERIC
           JR C,GT3          ;JR IF '0' TO '9'

           AND &DF           ;FORCE U.C
           SUB 7

GT3:       SUB &30           ;'0'->0, 'A'->10D ETC.
           CALL STACKA

GT4:       CALL NOISE
           JP ASSIGN         ;ASSSIGN STACKED VALUE TO VARIABLE

GETLN:     EQU GT4+6-GETP2

           ORG INSTBUF

DELPT2:    LD HL,1
           CALL DELSR
           RST &18           ;CHAR AFTER 'DELETE'
           CP TOTOK
           JR Z,DL2

           CALL GIR2         ;EVAL NUM, GET TO HL IF RUNNING. SCF IF SYNTAX
           CALL NC,DELSR     ;CALL IF RUNNING

           RST &18
           CP TOTOK
           JP NZ,NONSENSE

DL2:       RST &20           ;SKIP 'TO'
           CALL CRCOLON
           LD HL,&FEFF       ;LAST LEGAL LINE NUMBER
           CALL NZ,GIR2      ;GET LAST LINE NUM

           CALL RUNFLG
           JR NC,DL4          ;JR IF SYNTAX TIME

           CALL FNDLINE
           JR NZ,DL4         ;IF NOT USED, HL IS START OF NEXT LINE

           CALL NEXTONE      ;IF LINE IN USE, GET ADDR OF END+1 IN DE
           EX DE,HL          ; THEN HL

DL4:       CALL CHKHL
           IN A,(251)
           LD D,A
           CALL CHKENDCP

           LD A,(LAST)
           LD C,A
           CALL TSURPG       ;SWITCH IN START
           LD A,D            ;AHL=END ADDR
           LD DE,(FIRST)     ;CDE=START ADDR
           CALL SUBAHLCDE
           RET C             ;RET IF START HIGHER THAN END E.G. DELETE 2 TO 1

           LD B,H
           LD C,L            ;ABC=LEN TO CLOSE
           EX DE,HL          ;HL=START
           CALL RECL2BIG     ;CLOSE UP ABC AT (HL)
           JP GT4R           ;'GOTO' NEXT STATEMENT SO NXTLINE ETC. SET UP AGAIN

DELSR:     CALL FNDLINE      ;DEFAULT LINE IS LINE 1 OR FIRST AFTER IT
           CALL CHKHL
           LD (FIRST),HL
           IN A,(251)
           LD (LAST),A
DELFIN:    JP SELCHADP

DELLN:     EQU DELFIN+3-DELPT2

           ORG HDR

KEYP2:     CALL SYNTAXA

           LD A,&FE
           CALL SBFSR2       ;COPY STRING TO BUFFER. LEN 0-511 OK
           RET Z             ;RET IF LEN Z

           LD HL,(PPC)
           PUSH HL
           LD A,(SUBPPC)
           PUSH AF           ;SAVE LINE/STAT FOR LATER 'GOTO'
           PUSH DE           ;STRING START
           PUSH BC           ;STRING LEN
           CALL CLEARSP      ;CLEAR ELINE
           POP BC
           PUSH BC
           CALL ADDRELN
           CALL MAKEROOM
           EX DE,HL          ;DE PTS TO ROOM
           POP BC
           POP HL            ;STRING START
           LDIR              ;COPY STRING TO ELINE (INDIRECT METHOD MEANS
                             ;EVEN DIRECT KEYIN OF LITERAL STRING WORKS)
           CALL SETESP       ;ERRORS WILL RETURN TO THIS ROUTINE NOW.
                             ;OLD ERRSP IS ON STACK
           CALL TOKMAIN      ;TOKENIZE ELINE
           CALL LINESCAN     ;CHECK SYNTAX
           LD A,(ERRNR)
           AND A
           JR NZ,KI3         ;JR IF ERROR OCCURRED

           LD HL,FLAGS
           SET 7,(HL)        ;'RUNNING'
           CALL EVALLINO     ;CY IF IOOR, Z IF 0
           JP C,NONSENSE

           JR NZ,KI2         ;JR IF THERE WAS A LINE NUMBER

           INC C             ;STAT 1
           CALL LOOPEL       ;RUN ELINE
           SCF

KI2:       CALL NC,INSERTLN

KI3:       POP HL            ;OLD ERRSP
           CALL RESESP       ;RESET ERRSP, RESPOND TO ANY ERRORS
           CALL CLEARSP      ;CLEAR ELINE
KEYFIN:    JP GT4P           ;SET UP SO GOTO HAPPENS. MEANS LINE CAN BE KEYED
                             ;IN BEFORE LINE BEING EXECUTED.

KEYLN:     EQU KEYFIN+3-KEYP2

           ORG INSTBUF

POPP2:     CALL CRCOLON

           CALL NZ,VNUMV        ;EVAL NUM VARIABLE, SET NZ

POP1:      EX AF,AF'         ;Z IF NO VAR
           CALL CHKEND

           EX AF,AF'
           PUSH AF
           LD HL,(BSTKEND)
           LD A,(HL)
           INC A
           JR NZ,POP2        ;JR IF NOT THE STACK TERMINATOR

           RST &08
           DB 11             ;'No POP data'

POP2:      CALL RETLOOP2     ;ACCEPT ANY TYPE OF RET ADDR - DO/GOSUB/PROC
                             ;HL=LINE, A=TYPE/PAGE
           LD B,A
           POP AF
           PUSH BC           ;TYPE/PAGE
           JR Z,POP4         ;RET IF NO VARIABLE TO POP INTO

           INC H
           DEC H
           LD D,H
           LD E,H
           JR Z,POP3         ;JR IF ELINE - USE LINE OF 0

           LD A,B
           CALL TSURPG
           LD D,(HL)
           INC HL
           LD E,(HL)         ;DE=LINE NUMBER

POP3:      EX DE,HL
           CALL STACKHL
           CALL ASSIGN       ;FPCS TO VAR

POP4:      POP AF            ;TYPE/PAGE
           AND &E0
           CP &40
           JP Z,DELOCAL    ;IF 'PROC' TYPE, CLEAR LOCAL VARS TOO

POP5:      RET

POPLN:     EQU POP5-POPP2+1

           ORG INSTBUF

INPP2:     CALL RUNFLG
           CALL C,CLSLOWER     ;CLS AND SELECT CHANNEL 'K' IF RUNNING
           CALL SPACAN       ;NO INDENT **
           INC A             ;A=1
           LD (TVFLAG),A
           CALL INPSL
           XOR A
           LD (FLAGX),A      ;'NOT INPUT LINE' SO LISTING OK
           CALL CHKENDCP

           CALL CLSLOWER
           LD A,(SPOSNU+1)
           LD HL,UWTOP
           SUB (HL)
           INC A
           LD (SCRCT),A      ;EVERYTHING ON SCREEN DOWN TO SPOSN HAS BEEN SEEN,
                             ;SO WE CAN SCROLL THOSE LINES OFF BEFORE 'SCROLL?'
           RET

INPSL:     RST &18
           CALL PRTERM
           JR Z,IP2CR        ;JR IF CR/COLON/CLOSE BRACK.

           CALL PRSEPR
           RET Z             ;RET IF TERMINATOR FOUND AFTER ;/,/'

           CALL C,IPITEM     ;CALL INPUT ITEM SR IF NON-SEPARATOR FOUND
           JR INPSL

IP2CR:     LD A,(DEVICE)
           AND A
           JP Z,RUNCR        ;CR IF RUNNING IF UPPER SCREEN IN USE

           RET

IPITEM:    CP "("
           JR NZ,INP2        ;JR IF NOT AN EMBEDDED PRINT ITEM

           RST &20           ;SKIP '('
           CALL PRINT2       ;HANDLE PRINT ITEM
           RST &18
           JP INSISCBRK      ;CHECK/SKIP ')'

INP2:      CP LINETOK
           JR Z,INP4

           CALL ALPHA
           JP NC,PRITEM      ;JR IF NOT A LETTER

           CALL SYNTAX1      ;EXITS WITH DE=FLAGX
           LD HL,FLAGX
           RES 7,(HL)        ;'NOT INPUT LINE'
           JR INP5

INP4:      CALL SSYNTAX1     ;SKIP 'LINE', EVAL VAR
           CALL RUNFLG
           JP M,NONSENSE     ;ERROR IF NUMERIC VARIABLE

           LD HL,FLAGX
           SET 7,(HL)        ;"USING INPUT LINE"

INP5:      CALL ABORTER

           PUSH HL
           CALL SETWORK      ;CLEAR WORKSPACE
           POP HL            ;FLAGX
           SET 5,(HL)        ;'INPUT MODE'
           SET 6,(HL)        ;'NUMERIC RESULT'
           LD BC,1
           CALL RUNFLG
           JP M,INP6         ;JP IF NUMERIC - USE 1 SPACE

           RES 6,(HL)        ;STRING RESULT
           BIT 7,(HL)
           JR NZ,INP6        ;JR IF INPUT LINE - USE 1 SPACE

           LD C,3

INP6:      CALL WKROOM
           LD (HL),&0D       ;LAST LOCN
           DEC C
           JR Z,INP7         ;JR IF JUST ONE SPACE

           DEC HL
           LD A,&22
           LD (HL),A         ;SECOND LOCN
           LD (DE),A         ;FIRST LOCN

INP7:      LD (KCUR),HL      ;KCUR PTS TO CR, OR 2ND QUOTE
           IN A,(URPORT)
           LD (KCURP),A
           LD A,(FLAGX)
           RLA
           JR C,INP9         ;JR IF INPUT LINE - NO SYNTAX CHECK ON INPUT

           LD A,(CHADP)
           PUSH AF
           LD HL,(CHAD)
           PUSH HL
           LD HL,(ERRSP)
           PUSH HL

INPERR:    LD HL,INPERR
           PUSH HL
           XOR A
           LD (ERRNR),A      ;'NO ERROR'
           CALL KSCHK
           JR NZ,INP8        ;JR IF NOT 'K' OR 'S' CHANNEL

           LD (ERRSP),SP     ;ONLY SET ERRSP FOR K/S

INP8:      CALL ADDRWK       ;PT TO WORKSPACE
           CALL REMOVEFP
           CALL EDITOR
           CALL TOKMAIN
           LD HL,FLAGS
           RES 7,(HL)        ;SYNTAX TIME
           CALL INPAS
           AND A             ;SKIP NEXT INSTR.

INP9:      CALL C,EDCX       ;EDITOR

           CALL KSCHK
           JR NZ,INPA        ;JR IF NOT 'K' OR 'S' CHANNEL

           LD (KCUR+1),A     ;NO CURSOR WANTED
           CALL EDPRT        ;PRINT INPUT LINE
           LD HL,(OLDPOS)
           LD BC,POSTORE
           CALL R1ONCLBC     ;SCREEN POSN=PAST END OF PRINTED INPUT LINE

INPA:      LD HL,FLAGX
           LD A,(HL)
           RES 7,(HL)        ;'NOT INPUT LINE'
           RES 5,(HL)        ;'NOT INPUT MODE'
           RLA
           JR NC,INPC        ;JR IF NOT INPUT LINE

           CALL ADDRWK
           LD D,H
           LD E,L            ;DE=START
           LD BC,&FFFF

INPBL:     LD A,(HL)
           INC HL
           INC BC
           CP &0D
           JR NZ,INPBL       ;COUNT LEN TILL 0D TERMINATOR

           CALL STKSTOREP
           JP ASSIGN

INPC:      POP AF            ;JUNK INPERR
           POP HL
           LD (ERRSP),HL
           POP HL
           LD (PRPTR),HL
           POP AF
           LD (PRPTRP),A     ;ORIG CHAD IN AUTO-ADJUST SYS VAR
           LD HL,FLAGS
           SET 7,(HL)
           CALL INPAS
           LD A,(PRPTRP)
           CALL SETCHADP
           LD HL,(PRPTR)
           LD (CHAD),HL
           RET

INPAS:     LD HL,(WORKSP)
           LD (CHAD),HL
           LD A,(WORKSPP)
           CALL SETCHADP
           RST &18
           CP &B1            ;STOPTOK
           JR NZ,INPA2

           CALL RUNFLG
           RET NC

           RST &08
           DB 17             ;'STOP in INPUT'

INPA2:     LD A,(FLAGX)
           CALL VALFET2
           RST &18
           CP &0D
           RET Z

           RST &08
INPFIN:    DB 29             ;'NONSENSE'

INPLN:     EQU INPFIN+1-INPP2

                                 ;INPUT
;          INCLUDE TMISCX2.SAM   ;DEF KEYCODE, READ, DEF FN, TOKEN.
;MISCX2.SAM

           ORG INSTBUF

DKP2:      CALL EXPT1NUM     ;NUMBER OF KEY CODE TO DEFINE
                             ;(KEYBOARD HAS 69 KEYS WITH 3 SHIFTS (CAPS, SYM,
                             ;CONTROL) GIVING 276 BYTES IN KEY MAP, ANY OF WHICH
                             ;CAN BE PROGRAMMED TO GIVE ANY KEY CODE. KEY CODES
                             ;ABOVE 168? CAN BE DEFINED
           CALL COMMASC      ;SEE IF COMMA OR SEMI-COLON
           JR Z,DFK4         ;JR IF STRING DEFINITION SHOULD FOLLOW

           CALL RUNFLG
           JP NC,DFKNL       ;JP IF SYNTAX TIME - CHECK, STRIP FP FORMS

           EX DE,HL          ;DE=CHAD
           LD HL,(NXTLINE)
           SCF
           SBC HL,DE
           LD B,H
           LD C,L            ;ASSUMING NXTLINE HAS SAME PAGE PART AS CHAD,
                             ;BC=LEN OF REST OF LINE
           DEC BC            ;DEC BECAUSE WE DON'T USE ':' SEPARATOR
           INC DE            ;SKIP ':'
           LD HL,LINEEND
           EX (SP),HL        ;JUNK NEXT STAT, STACK LINEEND SO WE DON'T
           JR DFK5           ;EXECUTE THE REST OF THIS LINE

DFK4:      CALL SSYNTAXA     ;DEFINITION STRING

           CALL GETSTRING    ;BC=LEN, DE=ST, PAGED IN

DFK5:      PUSH DE
           PUSH BC
           CALL GETBYTE      ;KEY CODE
           INC A             ;255->0
           CP 193            ;ONLY KEY CODES 192-254 ARE DEFINABLE
           JP C,IOORERR

           DEC A
           PUSH AF
           CALL FNDKYD       ;FIND ANY EXISTING KEY DATA
           JR C,DFK55        ;JR IF DOESNT EXIST, ELSE CLOSE IT UP

;DEF KEY CLOSE
;CLOSES BC+3 BYTES AT HL-3 (I.E. ENTRY WITH HL PTING TO TEXT, BC=TEXT LEN,
;ERASES ENTIRE DEFINITION)

           INC BC
           INC BC
           INC BC
           PUSH HL           ;DEF TEXT START
           ADD HL,BC         ;PT TO PAST END OF DEFINITION,+3
           PUSH HL
           CALL DKTR         ;GET HL PTING TO TERMINATOR+3
           POP DE
           AND A
           SBC HL,DE
           INC HL
           LD B,H
           LD C,L            ;BC=BYTES TO MOVE (PAST END TO TERMINATOR, PLUS 1)
           EX DE,HL
           DEC HL
           DEC HL
           DEC HL            ;PT TO PAST DEF END
           POP DE
           DEC DE
           DEC DE
           DEC DE            ;PT TO DEF START
           LDIR

DFK55:     POP AF            ;KEY CODE
           POP BC            ;DEF$ LEN
           PUSH AF
           LD A,B
           CP &FF
           JR Z,DFK6         ;ABORT IF WAS E.G. DEF KEY 1 (CR). LEN IS FFFFH

           OR C              ;ALSO ABORT IF LEN 0

DFK6:      JP Z,PPRET        ;POP POP RET - JUNK KEY, SRC, ABORT

;DEF KEY OPEN
;ENTRY: BC=TEXT LEN (BC+3 IS OPENED TO ALLOW FOR KEY CODE AND LEN)
;EXIT: DE PTS TO SPACE, BC IS UNCHANGED

           PUSH BC
           CALL DKTR         ;HL=TERMINATOR ADDR+3
           POP BC
           PUSH HL
           ADD HL,BC         ;HL=NEW POSN FOR TERMINATOR. NC
           EX DE,HL
           LD HL,(DKLIM)
           SBC HL,DE
           JP C,TMDERR       ;ERROR IF TERMINATOR PAST LIMIT
                             ;ALLOWS TERMINATOR TO BE AT LIMIT...
           EX DE,HL
           LD (HL),&FF       ;NEW TERMINATOR (OLD WILL BE OVER-WRITTEN)
           POP DE
           DEC DE
           DEC DE
           DEC DE            ;PT TO OLD TERMINATOR

           POP AF            ;KEY CODE
           POP HL            ;SRC
           LD (DE),A
           INC DE
           LD A,C
           LD (DE),A
           INC DE
           LD A,B
           LD (DE),A         ;LEN IN PLACE
           INC DE
           LDIR
DKFIN:     RET

DKLN:      EQU DKFIN+1-DKP2


RDLN:      EQU 0   ;RDFIN+3-RDP2

;DEF FN COMMAND (OR MARKER - DOES NOTHING EXCEPT CHECK SYNTAX)

           ORG INSTBUF

DFNP2:     CALL RUNFLG
           JP C,SKIPCSTAT    ;SKIP STATEMENT IF RUNNING

           RST &18
           CALL FNNAME
           PUSH AF           ;A=1 IF STRING DEF FN
           LD (CHAD),HL
           RST &18
           CP "("
           JR NZ,DFN5

           RST &20           ;SKIP '('
           CP ")"
           JR Z,DFN4

DFNPL:     CALL GETALPH      ;INSIST ON A LETTER
           INC HL            ;SKIP VAR LETTER
           LD A,(HL)
           CP "$"
           JR NZ,DFN3

           INC HL            ;SKIP '$'

DFN3:      CALL MAKESIX
           LD (CHAD),DE      ;PT TO LAST OF 5-BYTES
           RST &20
           CP ")"
           JR Z,DFN4

           CALL INSISCOMA
           JR DFNPL

DFN4:      RST &20

DFN5:      CP "="
           JR NZ,DFNNS

           CALL SEXPTEXPR
           POP BC
           JR Z,DFN6         ;JR IF EXPR ASSIGNED TO DEF FN IS STRING

           DEC B
           RET NZ            ;RET IF B WAS NOT 1

DFN6:      DEC B             ;ERROR IF B<>1 (NAME<>STRING TYPE)
           RET Z

DFNNS:     RST &08
           DB 29             ;'Syntax error'

DFNLN:     EQU DFNNS+2-DFNP2
           ORG CDBUFF+&80

TOKPT2:    EXX
           EX DE,HL          ;E-LINE START OR WKSPACE START, OR OTHER,  TO HL

TOKRST:    LD A,(HL)         ;JR TO PT CHAD TO LINE START
           JR TOKQUEN

LOOKNA:    POP HL
           LD A,(HL)
           INC HL
           CP "A"
           JR C,TOKQUEN      ;JR IF WE JUST CONSIDERED '>' OR '<'

           DB &FE            ;'JR+1'

LKNONALP:  INC HL
           LD A,(HL)
           CALL ALPHA
           JR C,LKNONALP     ;LOOP WHILE LETTER

           CP "_"            ;CHECK FOR LETTER, UNDERLINE OR DOLLAR

           JR Z,LKNONALP     ;LOOP WHILE UNDERLINE

TOKQUEN:   LD (CHAD),HL      ;RESET CHAD
           DB &FE            ;'JR+1'

TOKMLP:    RST &20
           EX DE,HL
           CP &0D
           RET Z             ;RET IF END MARKER FOUND

           CALL ALPHA
           JR C,POSFIRST     ;JR IF A POSSIBLE FIRST LETTER FOUND

           CP "<"
           JR Z,POSFIRST     ;COULD BE '<=' OR '<>'

           CP ">"
           JR Z,POSFIRST     ;COULD BE '>='

           INC DE
           CP &FF
           JR Z,FNTS         ;JR WITH (DE)=FN LETTER IF FN LDR

           DEC DE
           CP &22            ;QUOTE
           JR NZ,TOKMLP

QUOTELP:   INC DE
           LD A,(DE)
           CP &0D
           RET Z

           CP &22
           JR NZ,QUOTELP

FNTS:      INC DE
           EX DE,HL
           LD A,(HL)
           JR TOKQUEN

POSFIRST:  PUSH DE
           EX DE,HL
           LD DE,TOKFIN+3    ;END OF THIS ROUTINE, IN CDBUFF
           LD BC,15          ;MAX LEN TO TOKENIZE
           PUSH DE
           LDIR
           POP DE
           LD HL,KEYWTAB-1
           LD A,KEYWNO+1     ;WORDS TO CHECK, PLUS 1
           CALL JGTTOK       ;GET A=1 TO KEYWNUMBER, IF MATCHED
           JR NZ,YGOTM

           LD HL,(MTOKV)
           INC H
           DEC H
           CALL NZ,HLJUMP

           JR Z,LOOKNA       ;JR IF NO MATCH FOUND, OR MTOKV ZERO

YGOTM:     EX DE,HL          ;ELSE HL=WORD START, DE=PAST END (IN BUFFER)
           AND A
           SBC HL,DE         ;HL=LEN
           POP DE            ;ELINE PTR
           ADD HL,DE
           EX DE,HL          ;HL PTS TO START, DE TO PAST END, IN ELINE

           CP &4A
           JR NC,TOK42       ;JR IF IN RANGE OF CMDS

           ADD A,&3A         ;ELSE GET FN CODE 3BH-83H
           LD (HL),&FF       ;OVERWRITE FIRST LETTER WITH FN LEADER
           INC HL
           JR TOK55

TOK42:     ADD A,&3B         ;CONVERT LIST ENTRY TO TOKEN CODE 85H-
           CP &FF            ;'INK'
           JR NZ,TOK43

           LD A,&A1          ;PENTOK - ALLOW 'PEN' TO BE ENTERED AS 'INK'

TOK43:     DEC HL            ;PT TO BEFORE WORD IN INPUT
           EX AF,AF'         ;SAVE TOKEN
           LD A,(HL)
           CP " "
           JR Z,TOK5         ;AVOID INC IF THERE IS A LEADING SPACE - SO IT
                             ;WILL BE OVER-WRITTEN BY TOKEN
           INC HL            ;PT TO FIRST LETTER

TOK5:      EX AF,AF'         ;RESTORE TOKEN

TOK55:     LD (HL),A         ;PLACE AT START OF SPELLED-OUT FORM
           INC HL            ;HL PTS TO FIRST BYTE TO DELETE
           EX DE,HL
           LD A,(HL)
           CP " "
           JR NZ,TOK6        ;JR IF NO TRAILING SPACE, ELSE INC HL TO INCLUDE
                             ;SPACE IN 'CLOSED UP' REGION
           INC HL

TOK6:      PUSH DE
           CALL RECLAIM1     ;CLOSE UP (DE) <- (HL)
           POP DE            ;KEEP LOOKING FROM HL ONWARDS
           LD H,D
           LD L,E
           DEC DE
           LD A,(DE)
           CP &B7            ;REMTOK. DON'T TOKENIZE REM STATEMENTS
           JP NZ,TOKRST      ;KEEP TOKENISING FROM HL ONWARDS

TOKFIN:    RET

TOKLN:     EQU TOKFIN+1-TOKPT2

           ORG INSTBUF

MEPRO2:    CALL SETWORK      ;CLEAR WORKSP IN CASE E.G. MERGE A$+B$
           LD BC,1
           CALL WKROOM       ;OPEN 1 BYTE IN WORKROOM (NOTE: ENSURES WKEND MOVED
                             ;BY MKRBIG)
           LD (HL),&FF       ;TERMINATOR
           PUSH HL
           CALL RDLLEN       ;CDE=FILE LEN TO LOAD
           POP HL
           PUSH BC
           PUSH DE
           LD A,C
           LD B,D
           LD C,E
           CALL MKRBIG       ;OPEN ABC BYTES
           POP DE
           POP BC
           SCF               ;'LOAD' NOT 'VERIFY'
           CALL JLDVD        ;LOAD CDE TO (HL)
           CALL MBASLNS
           CALL MNUMS
           LD HL,HDL+16
           CALL RDTHREE      ;CDE=LEN OF PROG ALONE
           PUSH BC
           PUSH DE
           LD L,(HDL+22)\256
           CALL RDTHREE      ;CDE=LEN OF PROG+NVARS+GAP
           LD A,C
           EX DE,HL          ;AHL=DITTO
           POP DE
           POP BC
           CALL SUBAHLCDE    ;AHL=LEN OF NVARS+GAP
           LD BC,1
           CALL ADDAHLBC     ;ALLOW FOR BASIC PROG TERMINATOR
           PUSH AF
           PUSH HL
           CALL ADDRWK
           POP BC
           POP AF
           CALL RECL2BIG     ;DELETE LOADED NVARS+GAP

;MERGE STRINGS/ARRAYS (PART OF PROGRAM FILE)
;ENTRY: DEST PTS TO LOADED DATA

MSTAR:     CALL ADDRWK       ;PT TO SRC (TLBYTE OR VAR, OR FF)
           LD A,(HL)
           INC A
           JP Z,GT4R         ;END IF ALL DONE - TERMINATOR HIT

           LD DE,TLBYTE
           AND &0F
           LD C,A
           LD B,0
           LD A,(HL)
           LDIR              ;COPY TLBYTE AND NAME TO BUFFER
           CALL STARYLK2     ;CALL WITH A=DESIRED T/L
           CALL NZ,ASDEL2    ;DELETE STRING/ARRAY AT (STRLOCN) IF IT WAS FOUND

           CALL ADDRWK       ;SRC
           LD BC,11
           ADD HL,BC         ;PT TO LEN DATA
           LD A,(HL)
           INC HL
           LD E,(HL)
           INC HL
           LD D,(HL)
           EX DE,HL
           LD C,14
           CALL ADDAHLBC     ;AHL=TOTAL LEN OF STR/ARRAY (PAGEFORM)
           PUSH AF
           PUSH HL
           CALL ADDRELND
           POP BC
           POP AF
           PUSH AF
           PUSH BC
           CALL MKRBIG       ;MAKE ABC BYTES AT HL FOR STR/ARRAY
           EX DE,HL
           IN A,(251)
           LD C,A            ;ROOM IS AT CDE
           POP HL
           RES 7,H
           LD (MODCOUNT),HL
           POP AF
           LD (PAGCOUNT),A
           CALL ADDRWK       ;PT TO SRC
           IN A,(251)        ;AHL=SRC, CDE=DEST
           CALL FARLDIR      ;COPY TO DEST
           CALL ADDRWK
           CALL ASDEL3       ;DELETE SRC
           JR MSTAR

;MERGE BASIC LINES

MBASLNS:   CALL ADDRWK       ;PT TO LOADED BLOCK (SRC)

MPRG1:     LD B,(HL)
           INC HL
           LD A,B
           INC A
           RET Z             ;RET IF ALL LINES DONE

           LD C,(HL)
           CALL FNDLP        ;FIND LINE BC, STARTING FROM PROG
           PUSH HL
           IN A,(251)
           PUSH AF           ;DESTINATION VARS
           CALL Z,NORECL     ;RECLAIM IF IT EXISTS

           CALL ADDRWK       ;PT TO SRC
           INC HL
           INC HL
           LD C,(HL)
           INC HL
           LD B,(HL)
           INC BC
           INC BC
           INC BC
           INC BC            ;BC=TOTAL SRC LINE LEN
           POP AF
           POP HL
           PUSH HL
           PUSH AF
           PUSH BC
           CALL TSURPG
           CALL MAKEROOM     ;MAKE ROOM FOR LINE
           CALL ADDRWK       ;AHL=SRC
           POP BC            ;LEN
           CALL SPLITBC
           POP BC
           LD C,B
           POP DE            ;CDE=DEST
           CALL FARLDIR      ;COPY TO PROGRAM
           CALL ADDRWK       ;PT TO SRC
           CALL NORECL       ;DELETE LINE FROM WORKSP
           JR MPRG1

;MERGE NUMBERS - WORKS WITH 16K OR LESS OF NUMERIC VARS.

MNUMS:     LD A,"a"

MNUML:     LD (FIRLET),A
           LD E,(HL)
           INC HL
           LD D,(HL)
           INC D
           CALL NZ,MNUMSR    ;CALL IF LETTER LIST HAS BEEN USED

           INC HL
           LD A,(FIRLET)
           INC A
           CP "z"+1
           JR C,MNUML

           RET

MNUMSR:    PUSH HL           ;SRC PTRS LIST POSN

MNSRL:     DEC D
           ADD HL,DE
           LD A,(HL)
           AND &A0           ;MASK ALL EXCEPT 'HIDDEN' AND 'UNUSED' BITS
           JR NZ,MNSR3       ;DO NOT DEAL WITH SUCH VARS

           IN A,(251)
           PUSH AF
           PUSH HL
           LD A,(HL)
           AND &1F
           LD C,A
           LD A,(HL)
           RES 6,A           ;'NOT A FOR-TYPE VARIABLE'**
           LD (TLBYTE),A
           INC HL
           INC HL
           INC HL            ;PT TO NAME SECOND LET, OR VALUE
           JR Z,MNSR2        ;JR IF 1-LET NUMBER

           LD B,0
           LD DE,FIRLET+1
           LDIR              ;COPY REST OF NAME TO BUFFER

MNSR2:     CALL HLTOFPCS
           CALL CRTVAR4      ;CREATE NUMERIC VAR WITH VALUE ON FPCS, NAME IN
                             ;BUFFER, TYPE IN A
           POP HL            ;TLBYTE OF SRC VAR JUST DEALT WITH
           POP AF
           OUT (251),A

MNSR3:     INC HL
           LD E,(HL)
           INC HL
           LD D,(HL)
           INC D
           JR NZ,MNSRL       ;JR IF MORE VARS IN LIST

           POP HL            ;LIST POSN
MEEND:     RET

MELN:     EQU MEEND+1-MEPRO2

 ORG &C000+RENLN+GETLN+DELLN+KEYLN+POPLN+INPLN+DKLN+RDLN+DFNLN+TOKLN+MELN

                                 ;MERGE, EOF, PTR, PATH$, FN STUBS, LINK

;          INCLUDE FPCMAIN.SAM    ;CALCVARS, FPCMAIN
;FPCMAIN.SAM
;FLOATING POINT CALCULATOR CODES AND ADDRESSES

;BINARY
FPATAB:       DW FPMULT     ;00 MULT
              DW FPADDN     ;01 ADDN (NUMBERS)
              DW FPCONCAT   ;02 ADDN (STRINGS)
              DW FPSUBN     ;03 SUBN
              DW FPPOWER    ;04 TO-POWER-OF
              DW FPDIVN     ;05 DIVN

              DW FPSWOP     ;06 SWOP
              DW FPDROP     ;07 DROP

              DW FPMOD      ;08 MOD
              DW FPIDIV     ;09 IDIV
              DW FPBOR      ;0A BOR
              DW NONSENSE   ;0B BXOR
              DW FPBAND     ;0C BAND

              DW FPOR       ;0D OR

MULT:      EQU &00
ADDN:      EQU &01
CONCAT:    EQU &02
SUBN:      EQU &03
POWER:     EQU &04
DIVN:      EQU &05
SWOP:      EQU &06
DROP:      EQU &07
MOD:       EQU &08
IDIV:      EQU &09
NUOR:      EQU &0D

              DW FPAND      ;0E N AND N
              DW FPNNOTE    ;0F N<>N
              DW FPNLESE    ;10 N<=N
              DW FPNGRTE    ;11 N>=N
              DW FPNLESS    ;12 N<N
              DW FPNEQUAL   ;13 N=N
              DW FPNGRTR    ;14 N>N

              DW FPSAND     ;15 $ AND N
              DW FPSNOTE    ;16 $<>$
              DW FPSLESE    ;17 $<=$
              DW FPSGRTE    ;18 $>=$
              DW FPSLESS    ;19 $<$
              DW FPSEQUAL   ;1A $=$
              DW FPSGRTR    ;1B $>$

;BINARY INTERNAL OPERATIONS (ALSO DROP, SWOP ABOVE)

              DW FPSWOP13   ;1C SWOP13
              DW FPSWOP23   ;1D SWOP23
              DW FPJPTR     ;1E JPTRUE
              DW FPJPFL     ;1F JPFALSE

NUAND:     EQU &0E
NNOTE:     EQU &0F
NLESE:     EQU &10
NGRTE:     EQU &11
NLESS:     EQU &12
NEQUAL:    EQU &13
NGRTR:     EQU &14

SAND:      EQU &15
SNOTE:     EQU &16
SLESE:     EQU &17
SGRTE:     EQU &18
SLESS:     EQU &19
SEQUAL:    EQU &1A
SGRTR:     EQU &1B

SWOP13:    EQU &1C
SWOP23:    EQU &1D
JPTRUE:    EQU &1E
JPFALSE:   EQU &1F

;UNARY INTERNAL OPERATIONS

              DW FPJUMP     ;20 JUMP
              DW FPLDBREG   ;21 LDBREG
              DW FPDECB     ;22 DECB
              DW FPSTKBR    ;23 STKBREG
              DW FPUSEB     ;24 USEB
              DW FPDUP      ;25 DUP
              DW FP1LIT     ;26 ONELIT
              DW FP5LIT     ;27 FIVELIT
              DW FPSOMELIT  ;28 SOMELIT
              DW FPLKADDRB  ;29 LKADDRB
              DW FPLKADDRW  ;2A LKADDRW
              DW FPREDARG   ;2B REDARG
              DW FPLESS0    ;2C LESS0
              DW FPLESE0    ;2D LESE0
              DW FPGRTR0    ;2E GRTR0
              DW FPGRTE0    ;2F GRTE0
              DW FPTRUNCT   ;30 TRUNC
              DW FPFORM     ;31 RESTACK
              DW FPPOWR2    ;32 POWR2
              DW FPEXIT     ;33 EXIT
              DW FPEXIT2    ;34 EXIT2
              DW FPEXIT2    ;35 SPARE
              DW FPEXIT2    ;36 SPARE
              DW FPEXIT2    ;37 SPARE
              DW FPEXIT2    ;38 SPARE

JUMP:      EQU &20
LDBREG:    EQU &21
DECB:      EQU &22
STKBREG:   EQU &23
USEB:      EQU &24
DUP:       EQU &25
ONELIT:    EQU &26
FIVELIT:   EQU &27
SOMELIT:   EQU &28
LKADDRB:   EQU &29
LKADDRW:   EQU &2A
REDARG:    EQU &2B
LESS0:     EQU &2C
LESE0:     EQU &2D
GRTR0:     EQU &2E
GRTE0:     EQU &2F
TRUNC:     EQU &30
RESTACK:   EQU &31
POWR2:     EQU &32
EXIT:      EQU &33
EXIT2:     EQU &34


;OPERATIONS USED BY BASIC.

;PRIORITY 16,NUMERIC ARG, NUMERIC RESULT

              DW FPSIN      ;39 SIN
              DW FPCOS      ;3A COS
              DW FPTAN      ;3B TAN
              DW FPARCSIN   ;3C ASN
              DW FPARCCOS   ;3D ACS
              DW FPARCTAN   ;3E ATN
              DW FPLOGN     ;3F LOGN
              DW FPEXP      ;40 EXP

SIN:       EQU &39
COS:       EQU &3A
TAN:       EQU &3B
ASN:       EQU &3C
ACS:       EQU &3D
ATN:       EQU &3E
LOGN:      EQU &3F
EXP:       EQU &40

              DW FPABS      ;41 ABS
              DW FPSGN      ;42 SGN
              DW FPSQR      ;43 SQR
              DW FPINT      ;44 INT

              DW FPUSR      ;45 USR
              DW FPIN       ;46 IN
              DW FPPEEK     ;47 PEEK
              DW FPDPEEK    ;48 DPEEK
              DW FPDVAR     ;49 DVAR
              DW FPSVAR     ;4A SVAR
              DW FPBUTTON   ;4B BUTTON
              DW FPEOF      ;4C EOF
              DW FPPTR      ;4D PTR - DISC USE
              DW NONSENSE   ;4E UNUSED

ABS:       EQU &41
SGN:       EQU &42
SQR:       EQU &43
INT:       EQU &44
INP:       EQU &46
PEEK:      EQU &47
EOF:       EQU &4C

;PRIORITY 15, STRING ARG, NUMERIC RESULT

              DW FPUDG      ;4F UDG ADDRESS
              DW NONSENSE   ;50 NUMBER
              DW FPLEN      ;51 LEN
              DW FPCODE     ;52 CODE

;PRIORITY 15, STRING ARG, STRING RESULT

              DW FPVALS     ;53 VAL$

;PRIORITY 15, STRING ARG, NUMERIC RESULT

              DW FPVAL      ;54 VAL

;PRIORITY 15, STRING ARG, STRING RESULT

              DW FPTRUSTR   ;55 TRUNC$

UDGA:      EQU &4F
LEN:       EQU &51
CODE:      EQU &52
VALS:      EQU &53
VAL:       EQU &54

;PRIORITY 16, NUMERIC ARG, STRING RESULT

              DW FPCHRS     ;56 CHR$
              DW FPSTRS     ;57 STR$
              DW FPBINS     ;58 BIN$
              DW FPHEXS     ;59 HEX$
              DW FPUSRS     ;5A USR$
              DW FPINKEY    ;5B INKEY$

CHRS:      EQU &56
STRS:      EQU &57
INKEY:     EQU &5B

;ODD PRIORITY, N ARG, N RESULT

              DW FPNOT      ;5C NOT     PRIORITY 4
              DW FPNEGAT    ;5D NEGATE  PRIORITY 9

NOT:       EQU &5C
NEGATE:    EQU &5D

CALC:      EQU &EF
STOD0:     EQU &C8
STOD1:     EQU &C9
STOD2:     EQU &CA
STOD3:     EQU &CB
STOD4:     EQU &CC   ;USED BY DRCURVE

STO0:      EQU &D0
STO1:      EQU &D1
STO2:      EQU &D2
STO3:      EQU &D3
STO4:      EQU &D4   ;USED BY DRCURVE
STO5:      EQU &D5   ;USED BY DRCURVE

RCL0:      EQU &D8
RCL1:      EQU &D9
RCL2:      EQU &DA
RCL3:      EQU &DB
RCL4:      EQU &DC   ;USED BY DRCURVE
RCL5:      EQU &DD   ;USED BY DRCURVE

STKHALF:   EQU &E0
STKZERO:   EQU &E1
STK16K:    EQU &E2
STKFONE:   EQU &E6
STKONE:    EQU &E9
STKTEN:    EQU &EC
STKHALFPI: EQU &F0


;FPCMAIN.SAM - FLOATING POINT CALCULATOR CONTROL
;ENTRY FROM RST 28H. B=JUNK OR VALUE FOR LOOP COUNTER OR CALC CODE FOR USEB

FPCMAIN:   LD DE,(STKEND)

FPCLP:     LD BC,FPCLP
           PUSH BC           ;'RET' WILL LOOP BACK HERE AT END OF A ROUTINE
           LD (STKEND),DE    ;RESET STKEND IN CASE A BINARY OPERATION HAS
                             ;COMBINED TWO VALUES INTO ONE, OR VALUE HAS BEEN
                             ;STACKED

           LD A,(IX+0)       ;GET A PARAMETER
           INC IX            ;PT TO NEXT ONE

;ENTRY POINT IF 'A' REGISTER ALREADY HAS CALC CODE.

BREGEN:    LD HL,(RST28V)
           INC H
           DEC H
           CALL NZ,HLJUMP    ;CALL WITH A=CODE, IX PAST CODE, DE=STKEND
                             ;ALLOWS DIRECT TRANSLATION OF ALL ZX FPC CODES
                             ;EXCEPT 34H (STK LITERAL) USING A LOOK-UP TABLE.
                             ;SEE FILES FOR 34H METHOD.

           LD B,0            ;USED LATER..
           CP &20
           JR C,FPCBIN       ;JR IF BINARY OPERATOR (00-1FH)

           CP &60
           JR C,FPCUNA       ;JR IF UNARY OPERATOR (20-5FH)

           ADD A,&20         ;E0-FF ->00-1F
           JR C,FPCONST

           ADD A,8           ;D8-DF ->00-07
           JR C,FPRCL

           LD HL,-5
           ADD HL,DE         ;HL=STKEND-5 (SRC FOR STORED VALUE)
           ADD A,8           ;D0-D7 ->00-07
           JR C,FPSTO

           ADD A,8           ;C8-CF ->00-07
           JR C,FPSTOD

           RST &08
           DB 51             ;'FPC error'

;HANDLE BINARY FPC OPERATION

FPCBIN:    LD HL,-5
           ADD HL,DE
           EX DE,HL          ;BACK DE UP TO PT TO STKEND-5

;HANDLE UNARY FPC OPERATION

FPCUNA:    LD C,A
           RLC C             ;BC=PARAM*2 - WORD INDEX
           LD HL,FPATAB
           ADD HL,BC
           LD C,(HL)
           INC HL
           LD B,(HL)
           PUSH BC           ;ROUTINE ADDR
           LD HL,-5
           ADD HL,DE         ;IF UNARY  OP, HL=STKEND-5, DE=STKEND
                             ;IF BINARY OP, HL=STKEND-10, DE=STKEND-5
           RET               ;TO ROUTINE. CY SET

;USE (BCREG) SYS VAR AS SOURCE OF CALCULATOR CODE. USED BY EXPR. EVALUATOR
;UNARY

FPUSEB:    LD A,(BCREG+1)
           JR BREGEN

;STORE-WITH-DELETE USED ABOUT 27 TIMES, SO COMBINE
;STOD0, STOD1, ETC

FPSTOD:    PUSH HL
           DB &FE            ;'JR+1'

;STORE TO A MEMORY (NO DELETE)

FPSTO:     PUSH DE           ;STKEND

           EX DE,HL
           CALL LOCMEM1
           EX DE,HL          ;CALC MEM ADDR TO DE, BC=5

           LDIR              ;COPY TOP STACK ENTRY TO CALC MEMORY
           POP DE            ;STKEND OR STKEND-5 IF DELETE WANTED
           RET

;RECALL A MEMORY

FPRCL:     CALL LOCMEM1      ;FIND CALC MEM ADDR, GET BC=5
           LDIR              ;COPY MEMORY TO STKEND
           RET

LOCMEM1:   LD HL,(MEM)

LOCMEM2:   LD C,A
           ADD A,A
           ADD A,A
           ADD A,C           ;*5
           LD C,A
           LD B,0
           ADD HL,BC
           LD C,5
           RET

FPCONST:   LD C,A            ;C=00-1F. MANY VALUES OF C MAKE NO SENSE.
           LD HL,FPCTAB
           ADD HL,BC         ;PT TO A CONSTANT. DE=STKEND
           LD C,5
           LDIR
           RET               ;TO FPCLP WITH DE=NEW STKEND

FPCTAB:    DB &80            ;DISP 0 - 0.5
           DB 0              ;DISP 1 - ZERO
           DB 0              ;DISP 2 - 16384
           DB 0
           DB 0
           DB &40
           DB &81            ;DISP 6 - FP ONE
           DB 0
           DB 0
           DB 0              ;DISP 9 - INTEGER ONE
           DB 0
           DB 1
           DB 0              ;DISP 0C - TEN
           DB 0
           DB 10
           DB 0

           DB &81,&49,&0F,&DA,&A2   ;DISP 10H - PI/2

;TERMINATE FPC PARAM LIST

FPEXIT:    POP BC            ;JUNK FPC LOOPING ADDRESS
           RET               ;RET TO ROM0'S RST 28H ROUTINE

;TERMINATE FPC PARAM LIST AND JUNK A RET ADDR (REPLACES DB EXIT: RET)

FPEXIT2:   POP BC            ;FPC LOOPING ADDR
           POP BC            ;ROM0 RST 28H RET ADDR
           POP AF            ;PORT STATUS
           POP IX            ;ORIG IX
           JP LRPOUT

;DUPLICATE LAST ENTRY. UNARY OP

FPDUP:     LD BC,5
           LDIR

FPDROP:    RET               ;EXIT IS A UNARY OP SO HL=STKEND-5, DE=STKEND
                             ;DELETE (DROP) IS BINARY SO DE=STKEND-5 - DROP.
FPLDBREG:  LD A,(IX+0)
           CP A              ;SET ZERO
           JR FPLDDCC

;USE (BCREG) SYS VAR AS A COUNTER. DEC AND JR NZ. UNARY

FPDECB:    LD A,(BCREG+1)
           DEC A

FPLDDCC:   LD (BCREG+1),A
           JR Z,FPPSKIP

;UNCONDITIONAL JUMP OF PARAM PTR BY (IX) BYTES. UNARY

FPJUMP:    LD A,(IX+0)
           LD C,A
           RLA
           SBC A,A
           LD B,A            ;B=FF OR 00 ACCORDING TO C
           ADD IX,BC         ;ADJUST IX UP OR DOWN
           RET

;JUMP IF ZERO. BINARY OPERATOR. DE=STKEND-5 SO 'LAST VALUE' DROPPED

FPJPFL:    CALL TSTZERO      ;Z IF VALUE AT (DE) (IE N2) IS ZERO
           JR FPJPTF

;JUMP IF TRUE. BINARY OPERATOR. DE=STKEND-5

FPJPTR:    LD H,D
           LD L,E
           INC HL
           INC HL            ;PT TO 1/0 ON FPCS
           DEC (HL)          ;SET ZERO IF TRUE (1)

FPJPTF:    JR Z,FPJUMP

FPPSKIP:   INC IX            ;SKIP BYTES TO JUMP BY
           RET

;STACK SOME LITERALS FROM PARAM LIST

FPSOMELIT: LD B,(IX+0)       ;FETCH NUMBER OF LITERAL BYTES (5,10,15,20 ETC)
           INC IX
           DB &21            ;"JR+2"

;STACK 5-BYTE LITERAL FROM PARAM LIST

FP5LIT:    LD B,5

FIVLTLP:   LD A,(IX+0)       ;SRC=PARAM LIST
           LD (DE),A
           INC IX
           INC DE
           DJNZ FIVLTLP

           RET               ;DE=NEW STKEND

;'PEEK' USING ADDRESS IN PARAM LIST

FPLKADDRB: CALL LKADDRSR
           JR STACKC

;'DPEEK' USING ADDRESS IN PARAM LIST

FPLKADDRW: CALL LKADDRSR
           JP STACKBC

LKADDRSR:  EX DE,HL
           LD E,(IX+0)
           INC IX
           LD D,(IX+0)
           INC IX
           EX DE,HL     ;STKEND TO DE AGAIN
           LD C,(HL)
           INC HL
           LD B,(HL)
           RET

;STACK BCREG+1 SYSTEM VAR (HOLDS B REGISTER ENTRY VALUE)

FPSTKBR:   LD A,(BCREG+1)
           LD C,A
           JR STACKC

;STACK 1-BYTE LITERAL FROM PARAM LIST. ENTRY: DE=STKEND

FP1LIT:    LD C,(IX+0)
           INC IX
           JR STACKC         ;STACK 00 00 C 00

;SET LAST VALUE TO TRUE (1) IF IT IS >=0 (+VE). UNARY

FPGRTE0:   CALL TSTZERO2     ;SEE IF (HL) NUMBER IS ZERO
           EX DE,HL
           JR Z,SETTRUE

;SET LAST VALUE TO TRUE (1) IF IT IS >0 (+VE AND NON-ZERO). UNARY

FPGRTR0:   INC HL
           LD A,(HL)
           RLA               ;CY IF -VE
           DEC HL
           JR C,SETFALSE

           INC HL
           INC HL
           INC HL
           LD A,(HL)         ;MSB
           DEC HL
           OR (HL)           ;LSB
           DEC HL
           DEC HL
           OR (HL)           ;EXP
           JR Z,SETFALSE

           JR SETTRUE

;SET LAST VALUE TO TRUE (1) IF IT IS 0. UNARY

FPNOT:     CALL TSTZERO2
           EX DE,HL          ;REVERSE EX AT END OF TSTZERO

;SET TRUE IF ZERO, FLASE IF NZ

ZTRUE:     JR Z,SETTRUE

           JR SETFALSE

;SET LAST VALUE TO TRUE (1) IF IT IS <=0. UNARY

FPLESE0:   CALL TSTZERO2
           EX DE,HL
           JR Z,SETTRUE

;SET LAST VALUE TO TRUE (1) IF IT IS <0 (-VE). UNARY

FPLESS0:   INC HL
           LD A,(HL)
           DEC HL
           RLA               ;CY IF -VE

;SET TRUE IF CY, FALSE IF NC

CYTRUE:    JR NC,SETFALSE

;SET LAST VALUE TO 'TRUE' (1). ENTRY: HL PTS TO LAST VALUE

SETTRUE:   LD C,1
           DB &FE            ;'JR+1'

;SET LAST VALUE TO 'FALSE' (0). ENTRY: HL PTS TO LAST VALUE.
;EXIT: HL UNCHANGED, DE=HL+5, A=0

SETFALSE:  LD C,&00
           LD D,H
           LD E,L

;STACK C TO (DE) AS 00 00 C 00 XX

STACKC:    XOR A
           LD (DE),A         ;'INTEGER'
           INC DE
           LD (DE),A         ;'+VE'
           INC DE
           LD A,C
           LD (DE),A         ;LSB FROM PARAM LIST
           XOR A
           INC DE
           LD (DE),A         ;MSB IS ZERO
           INC DE
           INC DE
           RET

;N1 AND N2 - BINARY OPERATION

FPAND:     CALL TSTZERO
           JR Z,SETFALSE     ;SET RESULT TO 0 IF N2 WAS ZERO

           RET               ;ELSE LAST VALUE=N1

;N1 OR N2 - BINARY OPERATION

FPOR:      CALL TSTZERO
           JR NZ,SETTRUE     ;SET RESULT TO 1 IF N2 WAS NON-ZERO

           RET               ;ELSE LAST VALUE=N1

;A$ AND N2 - BINARY OPERATION

FPSAND:    CALL TSTZERO
           RET NZ            ;RETURN A$ IF N2 WAS NON-ZERO

           DEC DE
           LD (DE),A
           DEC DE
           LD (DE),A         ;MAKE STRING LEN=0
           INC DE
           INC DE
           RET

;*******************************************************************************
;STRING COMPARISONS. BINARY
;NOTE: S1<S2 IS TRUE WHEN S1 WOULD APPEAR HIGHER IN AN ALPHABETIC LIST.
;ENTRY: S1,S2 ON STACK. BINARY OP. EXIT FROM STRCOMP WITH HL=S1 PTR, SET TRUE/
;FALSE OVERWRITES S1 WITH 0/1, EXITS WITH DE=NEW STKEND

;S1=S2

FPSEQUAL:  CALL STRCOMP
           JR ZTRUE          ;SET TRUE ON Z, ELSE FALSE

;S1<S2

FPSLESS:   CALL STRCOMP
           JR CYTRUE         ;SET TRUE ON CY

;S1>S2

FPSGRTR:   CALL STRCOMP
           JR Z,SETFALSE

           JR NCTRUE         ;SET TRUE ON NC

;S1<=S2

FPSLESE:   CALL STRCOMP
           JR Z,SETTRUE

           JR CYTRUE         ;SET TRUE ON CY

;S1>=S2

FPSGRTE:   CALL STRCOMP

NCTRUE:    CCF               ;SET TRUE ON NC
           JR CYTRUE

;S1<>S2

FPSNOTE:   CALL STRCOMP

NZTRUE:    JR Z,SETFALSE

           JR SETTRUE

;NUMERIC COMPARISONS. BINARY. N1,N2 -> TRUE/FALSE

;NUMERIC N1=N2

FPNEQUAL:  DB CALC
           DB SUBN
           DB NOT            ;SET TRUE IF ZERO
           DB EXIT2

;NUMERIC N1<N2

FPNLESS:   DB CALC
           DB SUBN
           DB LESS0          ;SET TRUE IF N1-N2 GIVES -VE
           DB EXIT2

;NUMERIC N1>N2

FPNGRTR:   DB CALC
           DB SUBN
           DB GRTR0          ;SET TRUE IF N1-N2 GIVES +VE, NON-ZERO
           DB EXIT2

;NUMERIC N1<=N2

FPNLESE:   DB CALC
           DB SUBN
           DB LESE0          ;SET TRUE IF N1-N2 GIVES -VE OR ZERO
           DB EXIT2


;NUMERIC N1>=N2

FPNGRTE:   DB CALC
           DB SUBN
           DB GRTE0          ;SET TRUE IF N1-N2 GIVES +VE
           DB EXIT2

;NUMERIC N1<>N2

FPNNOTE:   DB CALC
           DB SUBN
           DB NOT            ;SET TRUE IF N1=N2
           DB NOT            ;SET TRUE IF N1<>N2
           DB EXIT2

;TEST IF ZERO AT (DE). Z IF ZERO, ELSE NZ. HL UNCHANGED

TSTZERO:   EX DE,HL

TSTZERO2:  LD A,(HL)         ;EXP
           INC HL
           INC HL
           OR (HL)           ;LSB
           INC HL
           OR (HL)           ;MSB
           DEC HL
           DEC HL
           DEC HL
           EX DE,HL
           RET

;N1 MOD N2. RETURNS N1-N2*INT(N1/N2). BINARY

FPMOD:     DB CALC           ;N1,N2
           DB DUP            ;N1,N2,N2
           DB SWOP13         ;N2,N2,N1
           DB DUP            ;N2,N2,N1,N1
           DB SWOP13         ;N2,N1,N1,N2
           DB DIVN
           DB INT            ;N2,N1,INT(N1/N2)
           DB STO3           ;COMES IN HANDY FOR UNSTADDR
           DB SWOP23         ;N1,N2,INT(N1/N2)
           DB MULT           ;N1,N2*INT(N1/N2)
           DB SUBN           ;N1-N2*INT(N1/N2)
           DB EXIT2

;INTEGER DIVIDE. RETURNS INT (N1/N2). BINARY

FPIDIV:    DB CALC           ;N1,N2
           DB DIVN           ;N1/N2
           DB INT            ;INT(N1/N2)
           DB EXIT2


;N1 BOR N2 (BIT-WISE OR). BINARY

FPBOR:     CALL GETHLBC
           OR L
           LD C,A
           LD A,B
           OR H
           JR BSTKBCH

;N1 BAND N2 (BIT-WISE AND). BINARY

FPBAND:    CALL GETHLBC
           AND L
           LD C,A
           LD A,B
           AND H

BSTKBCH:   LD B,A
           JP STACKBC

;GET 2 NUMBERS FROM FPCS AS INTEGERS IN BC (N1) AND HL (N2). A=C

GETHLBC:   CALL GETINT
           PUSH BC
           CALL GETINT
           POP HL
           RET

;          INCLUDE TRANSEND.SAM   ;SIN, COS, EXP, ETC

;TRANSEND.SAM - TRANSCENDENTAL FUNCTIONS, AND ARITHMETIC
;W.E. THOMSON FASTER SINE/COSE

FPSIN:     DB CALC           ;X
           DB REDARG         ;W
           DB DUP
           DB DUP
           DB MULT           ;W,W*W
           DB STOD0          ;W
           DB STKHALFPI      ;W, FIRST TERM
           DB SOMELIT
           DB 25             ;25 BYTES FOLLOW (5 CONSTS)

           DB &80,&A5,&5D,&E7,&2A
           DB &7D,&23,&35,&E0,&36
           DB &79,&99,&68,&97,&AE
           DB &74,&28,&0A,&10,&9E
           DB &6E,&E6,&4F,&48,&19

           DB LDBREG         ;COUNTER
           DB &05

SINELP:    DB RCL0
           DB MULT
           DB ADDN
           DB DECB
           DB &FC            ;LOOP TO SINELP, 5 TIMES

           DB MULT
           DB EXIT2

;COSINE=SINE(ANGLE+PI/2)

FPCOS:     DB CALC
           DB STKHALFPI
           DB ADDN
           DB SIN
           DB EXIT2

;TAN=SIN X/COS X

FPTAN:     DB CALC
           DB DUP
           DB SIN
           DB SWOP
           DB COS
           DB DIVN
           DB EXIT2

;REDARG - REDUCE ANGLE ARGUMENT TO -180 TO +180 DEGREE RANGE

FPREDARG:  DB CALC
           DB FIVELIT
           DB &7E,&22,&F9
           DB &83,&6E        ;1/(2*PI)
           DB MULT           ;X/(2*PI)=X IN 360 DEGREE UNITS
           DB DUP
           DB STKHALF        ;HALF =180 DEGREES IN THIS CONTEXT
           DB ADDN
           DB INT            ;X IN 360 DEGREE UNITS, INT 360 DEGREE UNITS+.5
           DB SUBN           ;X REDUCED TO -180 TO +180 DEGREES
           DB ONELIT
           DB &04
           DB MULT           ;REDUCED X*4
           DB DUP
           DB ABS
           DB STKFONE
           DB SUBN
           DB DUP
           DB GRTR0
           DB JPTRUE         ;TO REDARG2
           DB 3

           DB DROP
           DB EXIT2

REDARG2:   DB STKFONE        ;(FLOATING PT)
           DB SUBN
           DB SWOP
           DB LESS0
           DB JPTRUE         ;TO REDARG3
           DB 2
           DB NEGATE

REDARG3:   DB EXIT2


;EXPONENTIAL - FPC UNARY FUNCTION. (W.E.T.)
;EXP(N)=e^X

FPEXP:     PUSH HL           ;PTR TO EXP. OF X

           DB CALC           ;X
           DB FIVELIT
           DB &81,&38
           DB &AA,&3B,&29    ;X,1/LN 2

           DB MULT           ;X/LN 2=Y. NOW 2^Y IS REQUIRED RESULT
           DB EXIT

           POP HL

;CALCULATE 2^Y

FPPOWR2:   PUSH HL           ;PTR TO EXP. OF TOP ENTRY

           DB CALC
           DB DUP
           DB INT            ;Y,INT Y
           DB STO1           ;THE INTEGER PART OF THE POWER CAN JUST
                             ;BE ADDED TO EXP OF X (LATER).
           DB SUBN           ;Y-INT Y=W. NOW DO CLEVER THINGS WITH THE
                             ;FRACTIONAL PART OF THE POWER

           DB STOD0          ;(M0=W)
           DB STKFONE        ;FIRST CONST IS 1 (FP FORM)
           DB SOMELIT
           DB 35             ;35 BYTES FOLLOW (7 CONSTS)

           DB &80,&31,&72,&18,&16
           DB &7E,&75,&FD,&E5,&E7
           DB &7C,&63,&59,&85,&4A
           DB &7A,&1D,&82,&11,&42
           DB &77,&30,&07,&1F,&00
           DB &74,&15,&F0,&51,&92
           DB &71,&35,&A0,&6F,&0B

           DB LDBREG
           DB &07            ;COUNTER

EXPLP:     DB RCL0
           DB MULT
           DB ADDN
           DB DECB
           DB &FC            ;LOOP TO EXPLP, 7 TIMES

           DB RCL1           ;2^W,INT Y
           DB EXIT

           CALL FPTOA        ;GET INTEGER PART OF POWER. CY IF >FF, Z IF +VE.
           JR Z,FPEXP3       ;JR IF +VE (BC HOLDS RESULT)

           JR NC,FPEXP2      ;JR IF IN RANGE (-255 TO -1 AS FF TO 01)

           POP HL            ;SET ZERO IF UNDERFLOW

SETFALSH:  JP SETFALSE

FPEXP2:    NEG
           LD C,A
           DEC B             ;NEGATE BC IF -VE

FPEXP3:    POP HL            ;PTR TO 2**W
           LD E,(HL)
           LD D,0            ;DE=EXP OF 2^W
           EX DE,HL          ;HL=EXP
           ADD HL,BC         ;ADD POWER TO GET NEW EXPONENT
           EX DE,HL          ;DE=NEW EXP, HL PTS TO LAST VALUE
           INC D
           JR Z,SETFALSH     ;ZERO RESULT IF UNDERFLOW

           DEC D
           JP NZ,NTLERR      ;ERROR IF OVERFLOW

           LD A,E
           AND A
           JR Z,SETFALSH

           LD (HL),A
           JP SETUPDE


;TO POWER - N1**N2. BINARY
;SPECIAL CASES: N1**0=1, 0**NZ=0

FPPOWER:   INC DE
           INC DE
           LD A,(DE)
           AND &3F
           LD B,A            ;IF N2=0-3FH, B=N2

           DB CALC           ;N1,N2
           DB DUP            ;N1,N2,N2
           DB STKBREG        ;N1,N2,N2,BREG
           DB SUBN           ;N1,N2,N2-BREG
           DB JPFALSE        ;JP TO IPOWER IF BREG=N2
           DB &0C

           DB SWOP           ;N2,N1
           DB DUP            ;N2,N1,N1
           DB JPFALSE        ;JP TO ZPOWER IF N1=ZERO
           DB &05

           DB LOGN           ;N2,LN N1
           DB MULT           ;N2*LN N1
           DB EXP            ;E**(N2*LN N1)
           DB EXIT2

;ZERO TO A NON-ZERO POWER

ZPOWER:    DB SWOP           ;0,N2
           DB DROP           ;0
           DB EXIT2          ;0 TO ANY POWER GIVES RESULT 0

;N1 TO POWER 0-3FH

IPOWER:    DB DROP           ;N1
           DB STOD0          ;(MEM0=N1)
           DB STKONE         ;1
           DB STKBREG        ;1,BREG
           DB JPFALSE        ;1
           DB &05            ;JP IF N1 TO POWER 0 - RESULT=1

           DB RCL0           ;T,N1
           DB MULT           ;NEW T
           DB DECB
           DB &FD            ;LOOP, DOING N1*N1*N1*N1...BREG TIMES

           DB EXIT2

;*******************************************************************************
;LOGN - NATURAL LOG

FPLOGN:    DB CALC           ;X
           DB RESTACK
           DB DUP            ;X,X
           DB LESE0          ;X,1/0
           DB DROP           ;X
           DB EXIT

           INC DE
           INC DE
           LD A,(DE)
           AND A
           JP NZ,INVARG      ;INVALID ARG IF X IS ZERO OR -VE

           LD A,(HL)         ;A=EXPONENT OF X
           LD (HL),&80       ;X REDUCED TO 0.5-0.999999 RANGE
           LD B,A

           DB CALC
           DB STKBREG        ;NX,EXP
           DB ONELIT
           DB &80            ;NX,EXP,80H
           DB SUBN           ;NX,TRUE EXP (PERHAPS -VE)
           DB SWOP           ;TE,NX
           DB DUP            ;TE,NX,NX
           DB FIVELIT
           DB &80,&CC,&CC
           DB &CC,&CD        ;TE,NX,NX,-0.8
           DB ADDN           ;TE,NX,NX-0.8
           DB GRTR0          ;TE,NX,1/0
           DB SWOP23         ;NX,TE,1/0
           DB JPTRUE         ;TO LOGN3
           DB &07

           DB STKFONE        ;NX,TE,1
           DB SUBN           ;NX,TE-1
           DB SWOP           ;TE-1,NX
           DB STKHALF        ;TE-1,NX,0.5
           DB DIVN           ;TE-1,2*NX
           DB SWOP           ;2*NX,TE-1

LOGN3:     DB FIVELIT
           DB &80,&31,&72
           DB &17,&F8        ;NX (OR 2*NX), TE (OR TE-1), LN2
           DB MULT           ;NX,TE*LN 2
           DB SWOP
           DB STKFONE        ;TE*LN 2-1,NX,1
           DB SUBN           ;TE*LN 2-1,NX-1
           DB DUP
           DB FIVELIT
           DB &82,&20,&00    ;TE*LN 2-1,NX-1,NX-1,2.5
           DB &00,&00
           DB MULT           ;              ,(NX-1)*2.5
           DB STKHALF        ;
           DB SUBN           ;              ,2.5*NX-3
           DB STOD0
           DB SOMELIT
           DB 60             ;12 CONSTANTS

           DB &80,&6E,&23,&80,&93
           DB &7D,&A7,&9C,&7E,&5E
           DB &7A,&1B,&43,&CA,&36
           DB &77,&A0,&FE,&5C,&FC
           DB &74,&31,&9F,&B4,&00
           DB &71,&CB,&DA,&96,&00
           DB &6E,&70,&6F,&61,&00
           DB &6C,&90,&AA,&00,&00
           DB &69,&30,&C5,&00,&00
           DB &66,&DA,&A5,&00,&00
           DB &64,&09,&00,&00,&00
           DB &61,&AC,&00,&00,&00

           DB EXIT

           JR SERIES

;*******************************************************************************
;ARCTAN

FPARCTAN:  DB CALC
           DB DUP            ;X,X
           DB ABS            ;X,ABS X       **
           DB STKFONE        ;X,ABS X,1
           DB SUBN           ;X,ABS X-1
           DB GRTE0          ;X,1/0
           DB DUP            ;X,1/0,1/0 (1 IF ABS X>=1, ELSE 0)
           DB JPFALSE        ;JP IF ABS X<1, ARCTAN2, WITH X,0 ON FPCS
           DB &0B

           DB SWOP           ;1,X
           DB DIVN           ;1/X
           DB NEGATE         ;-1/X
           DB DUP            ;-1/X,-1/X
           DB STKHALFPI      ;-1/X,-1/X,PI/2
           DB SWOP           ;-1/X,PI/2,-1/X
           DB LESS0          ;-1/X,PI/2,1/0
           DB JPTRUE         ;JP IF -1/X IS -VE, ARCTAN2. (-1/X, PI/2 ON FPCS)
           DB &02

           DB NEGATE         ;NEGATE PI/2 IF -1/X IS -VE

ARCTAN2:   DB SWOP           ;(+/-PI/2 OR 0),V
           DB DUP            ;               V,V
           DB DUP            ;               V,V,V
           DB MULT           ;               V,V*V
           DB STKHALF        ;               V,V*V,0.5
           DB DIVN           ;               V,2*V*V
           DB STKFONE        ;               V,2*V*V,1
           DB SUBN           ;(+/-PI/2 OR 0),V,2*V*V-1
           DB STOD0          ;(+/-PI/2 OR 0),V

           DB SOMELIT
           DB 60             ;12 CONSTANTS

           DB &80,&61,&A1,&B3,&0C
           DB &7C,&D8,&DE,&63,&BE
           DB &79,&36,&73,&1B,&5D
           DB &76,&B5,&09,&36,&BE
           DB &73,&42,&C4,&00,&00
           DB &70,&DB,&E8,&B4,&00
           DB &6E,&00,&36,&75,&00
           DB &6B,&98,&FD,&00,&00
           DB &68,&39,&BC,&00,&00
           DB &65,&E4,&8D,&00,&00
           DB &63,&0E,&00,&00,&00
           DB &60,&B2,&00,&00,&00

           DB EXIT

SERIES:    LD B,12           ;LOOP COUNTER

           DB CALC
           DB RCL0           ;(+/-PI/2 OR 0),V,12 CONSTS,2*V*V-1
                             ;IGNORE ALL EXCEPT CONSTS AND 2*V*V-1 (CALL IT X)
           DB STKHALF        ;C,C,..C,X,0.5
           DB DIVN           ;       ,2*X
           DB STOD0          ;
           DB STKZERO        ;0
           DB STO1           ;0 (INITIAL N)

SERILP:    DB DUP            ;   N,N
           DB RCL0           ;   N,N,M0
           DB MULT           ;   N,N*M0
           DB RCL1           ;   N,N*M0,M1
           DB STO2
           DB SUBN           ;,C,N,N*M0-M1
           DB SWOP23         ;,N,C,N*M0-M1
           DB ADDN           ;,N,C+N*M0-M1
           DB SWOP           ;,C+N*M0-M1,N
           DB STOD1          ;,C+N*M0-M1
           DB DECB           ;DEC BREG, JR NZ, TO SERILP
           DB &F5

           DB RCL2
           DB SUBN
           DB MULT
           DB ADDN
           DB EXIT2

;ARCSIN

FPARCSIN:  DB CALC           ;X
           DB DUP            ;X,X
           DB DUP            ;X,X,X
           DB MULT           ;X,X*X
           DB STKFONE
           DB SWOP
           DB SUBN           ;X,1-(X*X)
           DB SQR
           DB STKFONE
           DB ADDN           ;X,SQR(1-(X*X))+1
           DB DIVN           ;TAN
           DB ATN
           DB STKHALF
           DB DIVN
           DB EXIT2

;ARCCOS. (ACS X=PI/2-ASN X)

FPARCCOS:  DB CALC
           DB ASN
           DB STKHALFPI
           DB SWOP
           DB SUBN
           DB EXIT2

;          INCLUDE MULT.SAM       ;ARITHMETIC

;MULT.SAM - MULTIPLY, DIVIDE, SUBTRACT, ADD

;*******************************************************************************
;QMULT - MULTIPLY HL*DE. RESULT IN HL. FASTER IF EITHER NUMBER IS ONE BYTE.
;USES HL,AF. CY IF OVERFLOW OF 16 BITS.

QMULT:        PUSH BC
              LD B,8           ;BITS TO DO
              LD A,H
              AND A
              JR Z,QMULT2      ;JR IF HL NUMBER IS ONLY 8 BITS - QUICK MULT OK

              EX DE,HL         ;SWOP NUMBERS AND SEE IF ORIG DE IS 8 BIT
              LD A,H
              AND A

QMULT2:       LD C,L
              LD HL,0
              JR Z,SHORTMUL

QHLLP2:       ADD HL,HL        ;DOUBLE RESULT
              JR C,QOVERFL

              RLA              ;TEST NEXT BIT OF ORIG H
              JR NC,NOQADN

              ADD HL,DE
              JR C,QOVERFL

NOQADN:       DJNZ QHLLP2

              LD B,8

SHORTMUL:     LD A,C           ;A=ORIG L

QHLLOOP:      ADD HL,HL        ;DOUBLE RESULT
              JR C,QOVERFL

              RLA              ;TEST NEXT BIT OF ORIG HL
              JR NC,NOQADDIN

              ADD HL,DE
              JR C,QOVERFL

NOQADDIN:     DJNZ QHLLOOP

QOVERFL:      POP BC
              RET              ; RESULT IS IN HL IF NC SIGNALS 'OK'
;*******************************************************************************
;FPC MULTIPLY. BINARY OP WITH HL AND DE PTING TO N1,N2

FPMULT:       LD A,(DE)
              OR (HL)
              JR NZ,FPMULT2    ;JR IF EITHER NUMBER IS FLOATING-POINT

              PUSH DE          ;N2 PTR
              PUSH HL          ;N1 PTR
              CALL FETCHI      ;GET N1 IN DE, SGN IN C
              PUSH DE
              LD B,C
              INC HL
              INC HL           ;PT TO N2
              CALL FETCHI
              POP HL           ;N1
              LD A,C
              XOR B
              LD C,A           ;HL=N1, DE=N2, C=SGN OF RESULT
              CALL QMULT       ;HL=HL*DE
              POP DE           ;N1 PTR
              EX DE,HL         ;HL=N1 PTR, DE=RESULT
              JR C,QMOVERF     ;JR IF OVERFLOW OF 16 BITS

              JR STICZ

;LOAD (HL) WITH INTEGER DE, SGN A

STORADE:   CP 2
           SBC A,0           ;01->00, FF->FF
           CPL               ;01->FF, FF->00
           LD C,A            ;C=SGN
           PUSH DE             ;JUST TO BALANCE STACK **

STICZ:     LD A,D
           OR E
           JR NZ,STOREI

           LD C,A           ;ENSURE SGN OF ZERO IS +VE

;*******************************************************************************
;STORE INTEGER TO (HL). DE=INTEGER, C=SGN. ENTRY WITH STKEND ON STACK

STOREI:       LD (HL),0        ;'INTEGER'
              INC HL
              LD (HL),C        ;SGN
              INC HL
              INC C
              JR NZ,STORPI

              LD A,E           ;NEGATE DE IF SGN IS -VE
              CPL
              LD E,A
              LD A,D
              CPL
              LD D,A
              INC DE

STORPI:       LD (HL),E
              INC HL
              LD (HL),D
              POP DE           ;NEW STKEND
              RET

;*******************************************************************************
;FETCH INTEGER FROM (HL). DE=INTEGER, C=SGN

FETCHI:       INC HL
              LD C,(HL)
              INC HL
              LD E,(HL)
              INC HL
              LD D,(HL)
              DEC C
              INC C
              RET Z            ;RET IF +VE

NEGDE:        DEC DE

CPLDE:        LD A,E           ;NEGATE DE, SINCE SGN IS -VE
              CPL
              LD E,A
              LD A,D
              CPL
              LD D,A
              OR E             ;Z IF DE=0
              RET

NEGDEDE:      CALL NEGDE
              EXX              ;EXIT WITH REGS SWITCHED
              JR NZ,CPLDE      ;CPL MSW UNLESS Z SHOWS

              JR NEGDE


;DEAL WITH INTEGER MULTIPLY OVERFLOW

QMOVERF:      POP DE           ;N2 PTR

;*******************************************************************************
;FLOATING POINT MULTIPLY OF 2 NUMBERS. N1, N2 ARE ON FPCS AT (HL) AND (DE)

FPMULT2:      CALL DFPFORM     ;GET FP FORMS ON FPCS. EXIT WITH Z IF N1 IS A
                               ;POWER OF TWO, CY IF IT IS ZERO. F'=DITTO FOR N2
              RET C            ;IF N1=0, RET (BIN. OP MEANS ONLY 0 LEFT ON FPCS)

              EX AF,AF'
              JR C,MSETZ2      ;JR IF N2 IS ZERO - SET ZERO RESULT **

              PUSH HL          ;N1 PTR
              EX AF,AF'
              JR Z,FPQM1       ;JR IF N1 IS A POWER OF TWO

              EX AF,AF'
              JR NZ,FPMULT3    ;JR IF N2 ISN'T A POWER OF TWO

;SPECIAL CASE - EITHER NUMBER (OR BOTH) IS A POWER OF TWO, I.E. EXP 80 00 00 00
;OR EXP 00 00 00 00. XOR WILL GIVE CORRECT SGN BIT AND COPY NON-ZERO MANTISSA
;BITS. THEN EXPS CAN BE ADDED.

FPQM1:        LD A,(DE)
              LD C,A
              LD B,0
              LD L,(HL)
              LD H,B
              ADD HL,BC
              LD BC,-129

;ENTRY FROM QUICK DIVIDE

FPQMDC:       ADD HL,BC
              INC H
              JR Z,MSETZERO    ;SET ZERO IF UNDERFLOW

              DEC H
              JP NZ,NTLERR     ;ERROR IF OVERFLOW

              LD A,L           ;EXP OF RESULT
              AND A
              JR Z,MSETZERO

              POP HL           ;N1 PTR
              LD (HL),A
              LD B,4           ;4 MANT BYTES

FPQMULP:      INC HL
              INC DE
              LD A,(DE)
              XOR (HL)
              LD (HL),A
              DJNZ FPQMULP

              INC HL
              EX DE,HL         ;DE=NEW STKEND
              RET

MSETZERO:     POP HL

MSETZ2:       JP SETFALSE

FPMULT3:      CALL MUDIADSR    ;GET N1 IN B DE'DE, N2 IN C A'B'C'A, PUT
                               ;RESULT SIGN ON STACK, SET TRUE NUMERIC BITS

              PUSH BC          ;EXP BYTES
              LD HL,0          ;ZERO RESULT LSW
              EXX
              LD HL,0          ;ZERO RESULT MSW
              EXX

;MULTIPLIER IS IN A',B',C',A
;RESULT IS IN HL'HL
;MULTIPLICAND IS IN DE'DE

              LD C,4         ;4 BYTES IN MULTIPLIER

FPMULCLP:     LD B,8         ;8 BITS PER MULTIPLIER BYTE
              AND A
              JR NZ,FPMULBLP ;JR IF ANY BIT IN MULTIPLIER IS HIGH

              LD B,L         ;EXTRA BITS TO B
              LD L,H

              EXX
              LD A,L
              LD L,H
              LD H,0
              EXX

              LD H,A         ;0->H'->L'->H->L->B. SHIFT RESULT RIGHT 8 TIMES -
                             ;THIS IS ALL THAT HAPPENS IF ALL MULTIPLIER BITS=0
              JR NXMBYTE     ;GET NEXT MULTIPLIER BYTE

FPMULBLP:     RRA            ;TEST EACH BIT IN MULTIPLIER, FROM RHS TO LHS
              JR NC,FPMULT25 ;JR IF NO ADD OF MULTIPLICAND

              ADD HL,DE      ;ELSE ADD HL'HL,DE'DE
              EXX
              ADC HL,DE
              EXX

FPMULT25:     EXX            ;HALVE RESULT IN HL'HL
              RR H
              RR L           ;HALVE HL'
              EXX
              RR H
              RR L           ;HALVE HL
              DJNZ FPMULBLP

              RRA
              LD B,A         ;SAVE BITS THAT 'FELL OFF' HL'HL IN CASE THIS IS
                             ;FINAL BYTE OF MULTIPLIER.
NXMBYTE:      EXX
              LD A,C
              LD C,B
              EX AF,AF'
              LD B,A
              EX AF,AF'      ;A'->B'->C'->A. A IS NEXT MULTIPLIER BYTE
              EXX

              DEC C
              JR NZ,FPMULCLP

              LD A,B         ;A=EXTRA BITS (7 AND 6 MATTER)
              LD B,C         ;B=0
              EX DE,HL       ;PROTECT RESULT LSW IN DE
              POP HL         ;EXP BYTES (BOTH NON-ZERO)
              LD C,H         ;BC=N1 EXP (B IS 0)
              LD H,B         ;HL=N2 EXP
              ADD HL,BC      ;HL=EXP SUM+80H+80H
              LD BC,-&80

;ENTRY USED BY DIVIDE
;RESULT IS IN HL'DE, EXTRA BITS IN A. BC=+/-80H. BIT 7 OF STACKED AF=RESULT SGN
;HL=COMBINED EXP. BELOW SGN ON STACK IS N1 PTR

DIVISE:       ADD HL,BC      ;SUBTRACT 80H FROM COMBINED EXP TO CORRECT FOR 2
                             ;+80Hs AS A RESULT OF ADDING 2 EXP BYTES.
                             ;(OR VV. IF DIVIS - ADD 80H TO COMP FOR 80H-80H)
              EXX
              BIT 7,H        ;H'
              JR NZ,MULNORM  ;IF NO LEADING ZERO BITS, OK

              EXX
              DEC HL         ;DEC COMBINED EXP.
                             ;MOVE RESULT TO THE LEFT. ADD IN A 'LOST'
              RLA            ;BIT THAT HAS BEEN IN 'A'
              RL E           ;SINCE LAST HALVING OF RESULT.
              RL D
              EXX            ;SMALLEST MULT IS .1000*.1000 GIVES .01 SO

              ADC HL,HL      ;1 MOVE IS ALWAYS ENOUGH TO NORMALISE RESULT.
                             ;(DITTO FOR DIV)
MULNORM:      EXX
              RLA            ;LOOK AT A 'LOST' BIT FOR FINAL ROUNDING

;ENTRY FROM FPADDN WITH CY IF NEEDS ROUND UP, HL'DE=RESULT, HL=EXP, SGN AND N1
;PTR ON STACK

FPADDNEN:     JR NC,RNDDONE  ;JR IF NO NEED TO ROUND UP

              INC E
              JR NZ,RNDDONE

              INC D
              JR NZ,RNDDONE

              EXX
              INC L
              EXX
              JR NZ,RNDDONE

              EXX
              INC H
              EXX
              JR NZ,RNDDONE

              INC HL         ;ONLY IF ROUNDING RIPPLES RIGHT FORWARDS INC EXP
              EXX
              LD H,&80       ;AND MAKE MANTISSA .1000000
              EXX

RNDDONE:      POP AF         ;BIT 7=SGN BIT

;ENTRY FROM FPSUBN WITH BIT 7,A=SGN, HL'DE=MANT, HL=EXP, (SP)=N1 PTR

FPSUBNEN:     INC H
              JP Z,MSETZERO  ;IF EXP UNDERFLOWED, USE ZERO

              DEC H          ;ZERO UNLESS OVERFLOW
              JP NZ,NTLERR   ;H MUST BE ZERO NOW, SINCE WE ONLY USE 1 BYTE EXPS!

              INC L          ;RESULT NOW IN L HL'DE
              DEC L
              JP Z,MSETZERO  ;JR IF EXP IS ZERO

              EXX
              PUSH HL        ;GET RESULT MSW FROM HL'
              EXX

              POP BC         ;RESULT MSW
              XOR B
              AND &80        ;USE BIT 7 FROM A, REST FROM B. A=SGNED MANT 1
              XOR B
              LD B,L

LDMRSLT:      POP HL         ;N1 PTR
              LD (HL),B
              INC HL
              LD (HL),A
              INC HL
              LD (HL),C
              INC HL
              LD (HL),D
              INC HL
              LD (HL),E
              INC HL
              EX DE,HL       ;DE PTS TO N2 (WILL BE STKEND)
              RET
;DIVISION
;34-BIT DIVISION. MANTISSAS COULD BE 0.999/0.5=1.999 OR 0.5/0.999=0.5
;RANGE OF RESULTS=0.5-1.999 BUT METHOD GIVES HALF THIS (0.25-0.999). ALWAYS
;INC EXPONENT TO DOUBLE VALUE. A 33RD BIT MAY BE NEEDED TO NORMALISE RESULT
;TO 0.5-0.999, AND A FINAL BIT IS NEEDED FOR ROUNDING. (SHARED WITH MULTIPLY)


FPDIVN:       CALL DFPFORM     ;GET FP FORMS ON FPCS. EXIT WITH Z IF N1 IS A
                               ;POWER OF TWO, Z/C IF IT IS ZERO. F'=DITTO FOR N2
              RET C            ;IF N1=0, RET (BIN. OP MEANS ONLY 0 LEFT ON FPCS

              PUSH HL          ;N1 PTR
              EX AF,AF'
              JP C,NTLERR      ;JP IF N2 IS ZERO - OVERFLOW FROM DIVN BY ZERO

              JR NZ,FPDIVN2    ;JR IF N2 ISN'T A POWER OF TWO

;SPECIAL CASE - N2 IS A POWER OF TWO, E.G. EXP 80 00 00 00 OR EXP 00 00 00 00.
;THIS ALLOWS A SIMPLE EXP SUBTRACTION.

FPQD1:        LD A,(DE)
              LD C,A
              LD B,0
              LD L,(HL)
              LD H,B           ;NC HERE
              SBC HL,BC        ;SUB N1 EXP,N2 EXP
              LD BC,129
              JP FPQMDC

FPDIVN2:      CALL MUDIADSR
              EX DE,HL
              EXX
              EX DE,HL
              EXX              ;GET DIVISOR IN DE'DE, DIVIDEND IN HL'HL
                               ;SGN OF RESULT TO STACK, SET TRUE NUM. BITS
              CALL NEGDEDE
              EXX              ;NEGATE DIVISOR IN DE'DE. COMP FOR EXX IN NEGDEDE

              PUSH BC          ;EXP BYTES

           LD BC,&08FC       ;8 BITS PER BYTE OF RESULT.
                             ;C GOES FD,FE,FF,00 FOR 4 BYTES OF RESULT,
                             ;SAVES 33RD BIT AS CY ON FINAL LOOP WITH C=0
           JR FPDIVE

FPDIV3:    LD B,8            ;8 BITS PER BYTE

           EXX
           EX AF,AF'
           LD A,B
           EX AF,AF'
           LD B,C
           LD C,A            ;A'<- B'<- C'<-A. MOVE RESULT BYTES
           EXX

FPDIVLP:   ADD HL,HL
           EXX
           ADC HL,HL         ;MOVE DIVIDEND LEFT
           EXX
           JR NC,FPDIVE

           ADD HL,DE         ;IF CY, ADD NEG DIVISOR, SCF
           EXX
           ADC HL,DE
           SCF
           JR FPDIV4

FPDIVE:    ADD HL,DE         ;ADD NEGATED DIVISOR IN DE'DE TO DIVIDEND IN HL'HL
           EXX
           ADC HL,DE         ;MSW
           JR C,FPDIV4       ;JR IF OK, ELSE REVERSE

           EXX
           SBC HL,DE
           EXX
           SBC HL,DE         ;MSW. NC

FPDIV4:    EXX
           RLA               ;SHIFT RESULT BIT IN
           DJNZ FPDIVLP

           INC C
           JP M,FPDIV3       ;JP IF C=FD/FE/FF

           PUSH AF           ;SAVE LAST WHOLE RESULT BYTE, OR 33RD AND 34TH BITS

           LD B,2
           JR Z,FPDIVLP      ;JR IF STILL GOT 33RD AND 34TH BITS TO DO

           EXX               ;RESULT FROM A'B'C'A TO HL' DE
           LD A,C
           EXX
           LD D,A            ;D
           EXX
           LD L,B            ;L'
           EX AF,AF'
           LD H,A            ;H'
           EXX
           POP AF            ;33/34
           RRCA
           RRCA              ;33/34 BITS TO BITS 7 AND 6
           POP HL
           LD E,H            ;E

           POP BC            ;EXP BYTES
           LD L,B
           LD H,0
           LD B,H            ;HL=N1 EXP, BC=N2 EXP
           AND A
           SBC HL,BC
           LD C,&81          ;80H TO BE ADDED TO COMP FOR 80H-80H IN EXP SBC,
                             ;PLUS 1 TO COMP FOR RESULT IN 0.25-0.999 RANGE

;HL'DE=MANT, EXTRA BITS IN A. BC=81H. BIT 7 OF STACKED AF=SGN. (SP+2)=N1 PTR

           JP DIVISE         ;NORMALISE  (SHARED WITH MULIPLY)

;ADDITION/SUBTRACTION
;FPC BINARY OPERATION.

FPSUBN:       EX DE,HL
              PUSH HL
              CALL FPNEGAT     ;FOR SUBTRACTION, NEGATE N2, THEN ADD
              POP HL
              EX DE,HL

FPADDN:       LD A,(DE)
              OR (HL)
              JR NZ,FPADDN2    ;JR IF EITHER NUMBER IS FLOATING-POINT

              PUSH DE          ;N2 PTR
              INC HL
              PUSH HL          ;PTR TO SGN N1
              INC HL
              LD C,(HL)
              INC HL
              LD B,(HL)        ;BC=N1
              INC HL
              INC HL
              INC HL
              LD A,(HL)        ;SGN N2
              INC HL
              LD E,(HL)
              INC HL
              LD D,(HL)        ;DE=N2
              EX DE,HL         ;HL=N2
              ADD HL,BC
              LD B,0
              EX DE,HL         ;DE=N1+N2
              POP HL           ;PTR TO N1 SGN
              ADC A,(HL)
              RRCA
              ADC A,B
              JR NZ,ADDNOVERF

              SBC A,A
              LD (HL),A        ;SIGN

              LD A,D           ;DEAL WITH MINUS ZERO
              OR E
              JR NZ,MIN0OK     ;JR IF CANNOT BE 00 FF 00 00

              LD A,(HL)
              INC A
              JR NZ,MIN0OK     ;DITTO

              DEC HL
              LD (HL),&91      ;EXP
              INC HL
              LD (HL),&80      ;MAKE RESULT=65536

MIN0OK:       INC HL
              LD (HL),E
              INC HL
              LD (HL),D
              INC HL
              LD (HL),B        ;ZERO MANT 4 IN CASE RESULT IS 65536
              POP DE           ;DE=NEW STKEND
              RET

;*******************************************************************************
ADDNOVERF:    POP DE
              DEC HL           ;GET N1 AND N2 PTRS CORRECT

;N1+N2
FPADDN2:      PUSH HL          ;N1 PTR
              CALL DFPFORM     ;USE FULL FP FORMS
              CALL MUDIADSR    ;N1 IN DE'DE, N2 IN HL'HL, EXPS IN BC
                               ;TRUE NUMERIC BITS, XORED SGNS ON STACK
              LD A,C
              SUB B            ;SUB N2 EXP, N1 EXP. CY IF N1 EXP >N2 EXP
              JR NC,FPADD2     ;JR IF MAX EXP IN C ALREADY

              LD C,B
              NEG              ;A=EXP DIFF.
              EX DE,HL
              EXX
              EX DE,HL         ;SWOP MANTISSAS OF N1 AND N2 SO THAT HL'HL
                               ;IS THE NUMBER WITH THE LARGER EXP. AND DE'DE
              EXX              ;IS THE NUMBER WITH LOWER EXP (NEEDING SHIFT)
              CALL ADDALIGN    ;B=0
              JR FPADD3

FPADD2:       CALL NZ,ADDALIGN ;CALL UNLESS EXPS MATCH - NO NEED TO SHIFT
              EX DE,HL
              EXX
              EX DE,HL
              EXX
              LD B,0           ;BC=COMMON EXP

FPADD3:       POP AF           ;SGNS DO/DONT MATCH FLAG. N1 IN HL'HL NOW
              RLA
              JR C,FPSUBN2     ;SUBTRACT IF SIGNS MISMATCH - SUBTRACT

              ADD HL,DE

              EXX
              ADC HL,DE
              EXX

              EX DE,HL         ;RESULT IN HL'DE
              POP HL           ;N1 PTR
              PUSH HL
              INC HL           ;PT TO SGN OF RESULT
              JR NC,FPADD4     ;JR IF EXP OK AS IT IS

              INC BC           ;INC MAX (COMMON) EXP

              EXX
              RR H             ;BIT 7 BECOMES 1
              RR L
              EXX

              RR D
              RR E             ;NORMALIZE MANTISSA. CY IF NEEDS ROUNDING
                               ;NOTE: -VE NUMBERS ARE ROUNDED IN THE SAM WAY,
                               ;AS WITH MULT AND DIVN, SO BECOME MORE -VE.

FPADD4:       LD A,(HL)
              PUSH AF          ;SGN OF RESULT
              LD H,B
              LD L,C           ;HL=EXP, HL'DE=RESULT, SGN AND N1 PTR ON STACK
              JP FPADDNEN      ;CY IF NEEDS ROUNDING UP


;SGN DON'T MATCH SO SUBTRACT. E.G. N1+(-N2) OR -N1+N2. BC=COMMON EXP

FPSUBN2:      AND A
              SBC HL,DE
              EXX
              SBC HL,DE        ;MSW
              JR NZ,FPSUBN3    ;JR IF MSB OF RESULT IS NZ

              EX AF,AF'        ;PROTECT CY (Z,CY POSSIBLE)**
              EXX
              LD A,H
              OR L
              EXX

              JP Z,MSETZERO    ;JP IF LSW OF RESULT IS ALSO ZERO - ZERO RESULT

              EX AF,AF'        ;** SUBN BUG FIX

;HL'HL=RESULT (NON-ZERO). CY WILL SHOW IF SGN NEEDS REVERSAL

FPSUBN3:      POP DE
              PUSH DE          ;N1 PTR
              INC DE
              LD A,(DE)
              JR NC,FPSUBN4    ;JR IF NO NEED TO REVERSE ORIG SGN AND NEG RESULT

              XOR &80          ;FLIP SGN BIT OF ORIG N1
              EX AF,AF'
              EX DE,HL         ;MSW
              EXX
              EX DE,HL         ;LSW. RESULT IN DE'DE
              CALL NEGDEDE     ;NEGATE DE'DE, EXIT WITH DE' SELECTED
              EX DE,HL         ;MSW
              EXX
              EX DE,HL         ;LSW. RESULT IN HL'HL
              EXX
              EX AF,AF'
              JR FPSUBN4

FPSUBNLP:     EXX
              DEC BC           ;EXP
              ADD HL,HL
              EXX
              ADC HL,HL        ;SHIFT HL'HL LEFT

FPSUBN4:      BIT 7,H          ;H'
              JR Z,FPSUBNLP    ;LOOP UNTIL NUMBER IS NORMALIZED

              EXX
              EX DE,HL         ;RESULT IN HL'DE
              LD H,B
              LD L,C
              JP FPSUBNEN      ;BIT 7,A=RESULT SGN, HL'DE=MANT, HL=EXP
                               ;(SP)=N1 PTR


;ADDALIGN SR. ENTRY:DE'DE=MANT, A=BITS

ADDALIGN:     LD B,A
              CP 33            ;CP BITS TO ROTATE (EXP DIFF)
              JR C,ADDALILP    ;JR IF LESSER WON'T BE SHIFTED TO ZERO

              LD B,33          ;ENSURE DE'DE IS ROTATED TO ZERO

ADDALILP:     EXX
              SRL D
              RR E             ;MSW
              EXX
              RR D
              RR E             ;LSW
              DJNZ ADDALILP    ;LOOP UNTIL NUMBERS ALIGNED FOR COMMON EXP. B=0

              RET NC           ;RET IF NO NEED TO ROUND UP: ALWAYS TRUE IF ZERO

              INC E
              RET NZ

              INC D
              RET NZ

              EXX
              INC DE           ;NEVER CARRIES BECAUSE BIT 7 STARTS AS 0
              EXX
              RET

;MULT/DIV/ADD SR
;ENTRY: HL PTS TO FIRST OF TWO NUMBERS, DE TO SECOND. THEY ARE UNSTACKED TO:
;D'E'DE=(N1 MANTISSA) H'L'HL AND A'B'C'A=(N2 MANTISSA) B/C=(N1/N2 EXP)
;(SP)=SGN OF RESULT (BIT 7). D' AND H' HAVE TRUE NUMERIC BITS SET

MUDIADSR:     INC DE
              LD A,(DE)        ;N2 SGN
              LD B,(HL)        ;N1 EXP
              INC HL           ;PT TO N1 SGN
              XOR (HL)         ;BIT 7 IS XORED SGN BITS - UNLIKE=1
              POP DE           ;RET ADDR
              PUSH AF
              PUSH DE          ;RET ADDR
              LD D,(HL)        ;N1 MANT 1
              SET 7,D          ;TRUE NUMERIC BIT SET
              INC HL
              LD E,(HL)
              INC HL
              PUSH DE          ;N1 MANT 1 AND 2
              LD D,(HL)
              INC HL
              LD E,(HL)        ;DE=N1 MANT 3 AND 4
              INC HL
              LD C,(HL)        ;BC=N1/N2 EXP
              INC HL
              EX AF,AF'
              LD A,(HL)        ;A'=N2 MANT 1
              OR &80
              EX AF,AF'
              INC HL
              LD A,(HL)
              INC HL

              EXX
              LD B,A           ;B'=N2 MANT 2
              LD L,A           ;L'=N2 MANT 2 ALSO
              EX AF,AF'
              LD H,A           ;H'=N2 MANT 1
              EX AF,AF'
              EXX

              LD A,(HL)
              INC HL

              EXX
              LD C,A           ;BC'=N2 MANT 2 AND 3
              POP DE           ;DE'=N1 MANT 1 AND 2
              EXX

              LD L,(HL)        ;L=N2 MANT 4
              LD H,A           ;H=N2 MANT 3
              LD A,L           ;A=N2 MANT 4
              RET

;DOUBLE FPFORM. EQU TO EX DE,HL:CALL FPFORM:EX AF,AF':EX DE,HL: JP FPFORM
;EXIT: NUMBER AT HL AND NUMBER AT DE ARE IN FP FORM. F'=Z IF DE NUMBER IS
;A POWER OF TWO, Z IF HL NUMBER IS.

DFPFORM:      CALL FPFORMX
              EX AF,AF'

FPFORMX:      EX DE,HL

;CHANGE NUMBER AT (HL) TO FP FORM IF NEEDED
;EXIT: HL AND DE UNCHANGED, A, BC CORRUPT, Z IF NUMBER IS A POWER OF 2, CY IF 0

FPFORM:       LD A,(HL)
              AND A
              JR Z,FPFORM2     ;JR IF INTEGER

              INC HL
              LD A,(HL)
              DEC HL
              AND &7F          ;TEST MANT 1, IGNORING SGN BIT
              RET NZ           ;RET IF NOT A POWER OF TWO

              PUSH HL          ;NOW DO A LONGER TEST FOR POWERS OF 2. OTHER MANT
              INC HL           ;BYTES MUST BE ZERO
              INC HL
              OR (HL)          ;TEST MANT 2
              INC HL
              OR (HL)          ;MANT 3
              INC HL
              OR (HL)          ;MANT 4
              POP HL
              RET              ;Z MEANS NUMBER IS AN EXACT POWER OF TWO

FPFORM2:      PUSH DE
              CALL FETCHI      ;INTEGER IN DE, HL PTS TO MANT 3
              XOR A
              INC HL
              LD (HL),A        ;MANT 4
              DEC HL
              LD (HL),A        ;MANT 3 AND 4 WILL BE ZERO
              DEC HL
              DEC HL           ;PT TO MANT 1
              LD A,D
              LD C,&90
              AND A
              JR NZ,FPFORM3    ;JR IF INT IS >8 BITS

              OR E
              JR Z,FPFORM4     ;RET IF INT IS ZERO. ELSE A=E

              LD E,0          ;LS PART OF NUMBER
              LD C,&89        ;INIT EXP

FPFORMLP:     DEC C

FPFORM3:      RL E             ;NC INITIALLY AND LATER...
              RLA
              JR NC,FPFORMLP   ;SHIFT INTEGER TILL IT OVERFLOWS ON THE LHS

              RL (HL)          ;SGN TO CY
              RRA
              RR E             ;ROT. SGN BIT INTO AB - REPLACES TRUE NUMERIC BIT
              LD (HL),A
              INC HL
              LD (HL),E
              DEC HL
              DEC HL
              LD (HL),C        ;PLACE EXPONENT
              AND &7F          ;IGNORE SGN BIT
              OR E             ;Z IF POWER OF TWO
              POP DE
              RET

FPFORM4:      DEC HL
              POP DE
              SCF              ;'ZERO'
              RET

;          INCLUDE ROM1FNS.SAM    ;POINT
;ROM1FNS.SAM. CODE, LEN, INKEY$, BUTTON, SVAR, CHR$, BIN$, HEX$, MEM$, STR$,
;CONCAT, SQR, ABS, NEGATE, SGN, INT, TRUNCATE, ATTR, POINT
;*******************************************************************************

FPVAL:     DB &3E            ;'LD A,&AF'

FPVALS:    XOR A
           PUSH IX           ;** BUG FIX
           LD BC,(CHADP-1)   ;B=CHADP
           PUSH BC
           LD HL,(CHAD)
           PUSH HL
           AND A
           PUSH AF           ;A=0 IF VAL$, NZ IF VAL
         ;  CALL UNSTKPRT     ;DE=START, BC=LEN, A=PORT
           CALL GETSTRING
           INC BC            ;LEN OF AT LEAST 1; ROOM FOR TERMINATOR
          ; LD (BCSTORE),BC
;          CALL R1OFFCL      ;**
           CALL SCOPYWK        ;COPY STRING PLUS 1 BYTE OF JUNK TO WKSPACE
       ;    DEC HL           ;TERMINATE WITH 0DH
      ;     LD (HL),&0D       ;TERMINATE STRING COPY IN WKSPACE
           LD (CHAD),DE
           IN A,(URPORT)
           LD (CHADP),A
           PUSH DE
           CALL R1OFFCL
           DW TOKDE         ;TOKENISE FROM DE ON
           POP HL
           LD (CHAD),HL
           PUSH HL
           LD HL,FLAGS
           RES 7,(HL)        ;'SYNTAX CHECK' SO FP FORMS INSERTED
           CALL EXPTEXPR     ;RETURN WITH Z FOR STRING, NZ FOR NUM.
           EX AF,AF'
           LD A,(HL)         ;TERMINATOR
           CP &0D
           JR NZ,VALNONS     ;CHECK FOR TERMINATOR

           POP HL            ;STRING START IN WKSPACE
           POP AF            ;VAL/VAL$ FLAG
           JR NZ,FPVAL2      ;JR IF VAL

           EX AF,AF'
           JR Z,FPVALOK      ;IF VAL$, STRING RESULT IS OK. ELSE EX AF, AF'
                             ;GIVES Z, THEN ERROR
FPVAL2:    EX AF,AF'
           JR Z,VALNONS      ;IF VAL, STRING EXPR IS AN ERROR

FPVALOK:   LD (CHAD),HL
           LD HL,FLAGS
           SET 7,(HL)        ;'RUNNING'
           CALL SCANNING     ;GET EXPR TO FPC STACK
           POP HL
           LD (CHAD),HL      ;ORIGINAL CHAD
           POP AF
           LD (CHADP),A
           CALL SELURPG
           POP IX            ;** BUG FIX

SETUPDE:   LD DE,(STKEND)
           RET

VALNONS:   RST &08
           DB 29

FPDVAR:    RST &08           ;LET DOS STACK ADDR OF ITS VARS
           DB DVHK
           DB &21            ;'JR+2'

FPEOF:     RST &08
           DB EOFHK          ;DOS EOF
           DB &21            ;'JR+2'

FPPTR:     RST &08
           DB PTRHK          ;DOS PTR
           JR SUDH

IMPATHS:   CALL SABORTER

           RST &08
           DB PATHHK

SUDH:      JR SETUPDE


IMRND:     RST &20           ;SKIP 'RND'
           CALL RUNFLG
           JR NC,IMRND4      ;JR IF NOT RUNNING

           LD B,0
           LD HL,(SEED)
           LD E,&FD
           LD D,L
           LD A,H
           ADD HL,HL
           SBC A,B
           EX DE,HL
           SBC HL,DE
           SBC A,B
           LD C,A
           SBC HL,BC
           JR NC,IMRND1

           INC HL

IMRND1:    LD (SEED),HL
           CALL STACKHL

           DB CALC
           DB RESTACK        ;EXP WILL BE 00 IF ZERO, ELSE 81-90H
           DB EXIT

           LD A,(HL)
           SUB &10           ;DIVIDE BY 65536
           JR C,IMRND4       ;LEAVE IT ALONE IF ZERO

           LD (HL),A         ;NEW EXP

IMRND4:    RST &18
           CP "("
           RET NZ

           CALL SEX1NUMCB    ;SKIP, GET 'N)', PASS CLOSING BRACKET
           RET NC            ;RET IF NOT RUNNING

           DB CALC           ;RND,PARAM
           DB STKONE         ;RND,P,1
           DB ADDN           ;RND,P+1
           DB MULT           ;RND*(P+1)
           DB TRUNC
           DB EXIT2          ;EXIT WITH INTEGER BETWEEN 0 AND PARAM

;ATTR(L,C)

IMATTR:    CALL EXB2NUMB  ;CHECK (X,Y). CY IF RUNNING
           RET NC

           LD HL,&1820       ;LINE/COL LIMITS (PLUS 1)
           CALL GETCP        ;GET CHAR POSITION WITHIN LIMITS, IN DE
           LD A,(MODE)
           CP 2
           JP NC,INVMERR      ;INVALID MODE UNLESS 0 OR 1

           AND A
           JR Z,DOATT2       ;JR IF MODE 0

           CALL M1DEADDR     ;GET CHAR ADDR
           LD A,D
           ADD A,&20         ;GET ATTR ADDR (ADD 8K)
           JR DOATT3

DOATT2:    CALL M0DEADDR
           LD A,D
           RRCA
           RRCA
           RRCA
           AND &03
           OR &98            ;FORM ATTR ADDR IN AE

DOATT3:    LD D,A
           EX DE,HL
           CALL SREAD
           JR POATC

;POINT(X,Y)

IMPOINT:   CALL EXB2NUMB  ;CHECK (X,Y). CY IF RUNNING
           RET NC

           CALL GTFCOORDS    ;GET COORDS IN B,C OR B,HL (THIN) AND CY
           CALL ANYPIXAD     ;GET ADDRESS IN HL, PIXEL OFFSET IN A
           INC A
           LD B,A            ;B=X MOD 8+1
           CALL SREAD
           LD E,A            ;E=SCREEN BYTE
           LD D,&01          ;MODE 0/1 MASK
           LD A,(MODE)
           CP 2
           JR C,DPOINTC      ;JR IF MODE 0/1

           LD D,&0F          ;MODE 3 MASK
           JR NZ,M3POINT     ;JR IF MODE 3

           LD D,3            ;MODE 2 MASK
           LD A,E
           RLA
           RR E
           XOR E
           AND &AA
           XOR E
           LD E,A            ;SWAP ODD/EVEN BITS IN MODE 2

           LD A,(THFATT)
           AND A
           JR NZ,M3POINT     ;DO MODE 3 POINT IF FATPIX 1

           LD A,B
           DEC A
           AND D             ;AND 3
           INC A
           ADD A,A           ;IF THIN PIX, A=2/4/6/8 FOR PIX 0/1/2/3
           LD B,A

DPOINTC:   LD A,E

POINLP:    RLCA
           DJNZ POINLP

           JR M3ODPT

M3POINT:   LD A,E
           LD B,4
           BIT 0,C           ;SEE IF X IS ODD
           JR Z,POINLP

M3ODPT:    AND D

POATC:     CALL RCURP
           JR STKAB          ;ATTR OR POINT


;GET CHAR POSITION LESS THAN LIMITS H/L (LINE/COL) IN DE (LINE/COL)

GETCP:     PUSH HL           ;LINE/COL MAX
           CALL GETBYTE      ;COL
           POP HL
           CP L
           JR NC,OSERR

           PUSH BC
           PUSH HL
           CALL GETBYTE      ;LINE
           POP HL
           POP DE
           LD D,A
           CP H
           RET C

OSERR:     RST &08
           DB 32             ;'Off screen'


;*******************************************************************************
;INKEY$ #N

FPINKEY:   LD DE,&1100+30    ;LIMIT <17
           CALL LIMBYTE

           LD HL,(CURCHL)
           PUSH HL
           CALL SETSTRM      ;SET STREAM 'A'
           CALL INPUTAD      ;SCAN INPUT STREAM WITHOUT WAITING
           POP HL            ;PREV. CHANNEL
           PUSH AF           ;INKEY VALUE
           CALL CHANFLAG     ;RESTORE ORIG CHANNEL
           POP AF

FPINKEN:   LD D,A
           JR C,CHRINKC      ;IF GOT KEY, D=BYTE. COPY TO WKSPACE

           XOR A             ;IF NO INPUT - NULL STRING
           JR STKAB


;MOUSE BUTTON N (1/2/3) RETURNS 1 IF PRESSED, 0 IF NOT

FPBUTTON:  LD DE,&0400+30    ;LIMIT TO 0-3
           CALL LIMBYTE
           CP 3              ;CY IF 0/1/2, NC IF 3
           SBC A,&FF         ;00,01,02,04
           JR NZ,FPBT2

           CPL               ;'BUTTON 0' TEST ALL 3

FPBT2:     LD HL,BUTSTAT     ;HAS BITS 2-0 SET FOR BUTTONS 3-1
           AND (HL)
           JR Z,STKAB

           LD A,1

STKAB:     JP STACKA

;SVAR JUST ADDS BASE ADDR OF SYSTEM VARS TO ARGUMENT

FPSVAR:    DB CALC
           DB LKADDRW
           DW VVAR2
           DB ADDN
           DB EXIT2

;*******************************************************************************
;CHR$ - CREATE 1 CHAR STRING IN WKSPACE, PARAMS ON FPCS

FPCHRS:    CALL GETBYTE      ;B=0, L=BYTE
           LD D,L

CHRINKC:   LD BC,1           ;LEN=1

INKYEN:    LD HL,TEMPW1+1
           LD (HL),E
           DEC HL
           LD (HL),D
           JP CWKSTK         ;COPY BC FROM (HL) TO WKSPACE, PARAMS TO FPCS
                             ;EXITS WITH DE=STKEND

;*******************************************************************************
;BIN$ N. RETURN BINARY STRING 8 OR 16 DIGITS LONG

FPBINS:    CALL GETINT
           EX DE,HL          ;INT IN DE
           LD A,D
           LD C,8            ;ASSUME LEN 8 FOR RESULT STRING
           AND A
           JR Z,BINS2

           LD C,16           ;USE 16 IF NEEDED

BINS2:     LD HL,MEMVAL+16   ;GET HL POINTING TEMP $ BUFFER IN MEMS
           LD B,C

BINSLP:    DEC HL
           SRL D
           RR E              ;SHIFT LS BITS OUT FIRST
           LD A,(BIN1DIG)
           JR C,BINS4        ;LEAVE IT IF CY

           LD A,(BIN0DIG)

BINS4:     LD (HL),A
           DJNZ BINSLP
                             ;HL=START, BC=LEN
BCWKHP:    JP CWKSTK         ;COPY BC FROM (HL) TO WKSPACE, PARAMS TO FPCS

;*******************************************************************************
;HEX$ N. RETURN HEX VERSION OF N, 2, 4 OR 6 DIGITS LONG, ACCORDING TO MAGNITUDE

FPHEXS:    CALL UNSTLEN      ;ABC=PAGE/'ADDR' **
           RRCA
           RRCA              ;LS 2 BITS TO POSN 7,6
           LD H,A
           XOR B
           AND &C0
           XOR B
           LD B,A            ;HBC=20-BIT NUMBER
           LD E,0            ;INIT DIGIT COUNTER
           OR H
           JR Z,HEX2DIG      ;JR IF MS 2 BYTES (OF 3)=0

           LD A,H
           AND &0F
           JR Z,HEX4DIG      ;JR IF MSB=0

           EX AF,AF'
           LD A,B
           EX AF,AF'         ;SAVE MIDDLE BYTE IN A'
           LD B,A            ;B=MS BYTE
           CALL HEXASCSR
           EX AF,AF'
           LD B,A            ;MIDDLE BYTE

HEX4DIG:   CALL HEXASCSR     ;DERIVE 2 DIGITS FROM B, STACK THEM

HEX2DIG:   LD B,C            ;LS BYTE
           CALL HEXASCSR
           LD C,E
           LD B,0
           LD HL,MEMVAL+6    ;TEMP BUFFER
           LD B,C

HEXPUTLP:  DEC HL
           POP AF            ;UNSTACK AN ASCII DIGIT
           LD (HL),A
           DJNZ HEXPUTLP
                             ;HL=START-1, BC=LEN
           JR BCWKHP         ;STACK STRING FROM HL ON FPCS


;HEX$ ASCII SR TO CONVERT VALUE IN B TO 2 ASCII HEX DIGITS ON STACK

HEXASCSR:  INC E
           INC E             ;COUNT OF DIGITS ON STACK=COUNT+2
           LD A,B
           LD D,2            ;2 DIGITS
           POP HL            ;RET ADDR
           RRCA              ;MS NIBBLE FIRST
           RRCA
           RRCA
           RRCA

HEXSRLP:   AND &0F
           CP &0A
           SBC A,&69         ;
           DAA               ;A STRANGE TWIDDLE THAT GIVES THE RIGHT ANSWER!
           PUSH AF           ;SAVE ASCII 0-9, A-F
           LD A,B
           DEC D
           JR NZ,HEXSRLP

           JP (HL)           ;RETURN

;*******************************************************************************
;PT 2 OF MEMORY$

MEMRYSP2:  DB CALC
           DB SWOP           ;N2,N1
           DB STO0
           DB SUBN           ;N2-N1
           DB STKONE         ;ALLOW FOR INCLUSIVE CHAR.
           DB ADDN           ;LEN
           DB DUP
           DB LESS0          ;LEN, 1/0
           DB JPFALSE        ;JP IF LEN <0
           DB &03

           DB DROP
           DB STKZERO        ;NULL STRING IF LEN <0

           DB RCL0           ;LEN,N1
           DB EXIT

           CALL UNSTLEN      ;GET AHL=START
           SET 7,H           ;PAGE FORM
           DEC A
           PUSH AF
           PUSH HL
           CALL GETINT       ;GET BC=LEN
           POP DE            ;ADDR
           POP AF
           JP STKSTOS

;*******************************************************************************
;S1+S2. PRODUCE A CONCATENATED STRING IN WKSPACE, PARAMS ON FPCS
;BINARY - ALTHOUGH ONLY RELEVANT FOR ENTRY DE

FPCONCAT:  IN A,(URPORT)
           PUSH AF
           PUSH DE           ;S2 PTR WILL BE NEW STKEND
           CALL STKFETCH     ;ADE=S2 START, BC=S2 LEN
           PUSH AF
           PUSH DE
           PUSH BC           ;S2 LEN
           PUSH BC
           CALL STKFETCH
           POP HL            ;S2 LEN
           ADD HL,BC         ;TOTAL LEN
           JP C,STLERR       ;** BUG FIX

           PUSH AF           ;PAGE OF S1
           PUSH DE           ;START OF S1
           PUSH BC           ;LEN OF S1
           LD B,H
           LD C,L            ;BC=TOTAL LEN
           CALL WKROOM       ;GET DE=START, BC=TOTAL LEN, PAGED IN
           CALL STKSTOREP    ;PARAMS OF STRING TO BE CREATED TO FPCS

           POP BC            ;LEN OF S1
           CALL SPLITBC      ;SET UP PAGCOUNT/MODCOUNT
           IN A,(251)
           LD C,A            ;DEST=CDE
           POP HL            ;START OF S1
           POP AF            ;PAGE OF S1
           CALL FARLDIR
           POP BC            ;LEN OF S2
           CALL SPLITBC
           POP DE            ;START OF S2
           POP HL            ;H=PAGE OF S2
           SCF
           CALL FARLDIR2     ;ENTRY PT 2 BECAUSE TEMPW1 AND TEMPB2 = DEST
           POP DE            ;NEW STKEND
           JP PPORT

;AMPERSAND-PREFACED HEX, E.G. &FC0D OR 12345H (6 DIGITS OK)
;VALUE EVALUATED DURING SYNTAX CHECK AND INSERTED AS A 5-BYTE FORM.

AMPERSAND: XOR A
           LD H,A
           LD L,A            ;INIT RESULT TO ZERO
           EX AF,AF'         ; IN A'HL

AMPDILP:   EX DE,HL
           RST &20
           EX DE,HL          ;HL=RESULT
           SUB &30           ;NUMS NOW 00-09, LETS 11-2A, 31-4A
           JR C,AMPEND

           CP &0A
           JR C,AMPVALID     ;JR IF DIGIT

           ADD A,&30
           OR &20            ;LETS NOW 61-7A
           CP "a"
           JR C,AMPEND

           CP "g"
           JR NC,AMPEND

           SUB &57           ;a-f->0A-0F

AMPVALID:  LD B,4
           EX AF,AF'

AMPERLP:   ADD HL,HL
           RLA
           JP C,NTLERR       ;NUM. TOO LARGE (ONLY SEE MSG WITH EG VAL("&"+A$))

           DJNZ AMPERLP

           EX AF,AF'
           OR L
           LD L,A            ;ADD IN NEW HEX DIGIT
           JR AMPDILP

AMPEND:    LD B,H
           LD C,L
           EX AF,AF'
           AND A
           JR Z,STACKBCH     ;JR IF SMALL INTEGER

           LD B,&98          ;EXP FOR FF FF FF

AMPALLP:   BIT 7,A
           JR NZ,AMPFP

           ADD HL,HL         ;ALIGN MANTISSA IN AHL
           RLA
           DJNZ AMPALLP      ;B NEVER HITS ZERO!

AMPFP:     AND &7F           ;+VE SIGN BIT
           LD E,A
           LD D,H
           LD C,L
           LD A,B            ;EXP
           LD B,0           ;FP NUM IN A E D C B
           JP STKSTORE

FPUSRS:    CALL R1OFFJP      ;JP TO MAIN ROUTINE IN ROM 0 WITH ROM1 OFF
           DW R0USRS

FPUSR:     CALL R1OFFJP
           DW R0USR

;UNARY
FPPEEK:    CALL PDPSUBR      ;GET HL=ADDR (PAGED IN), A=ORIG URPORT
           LD D,A
           XOR A
           JR FPPDPC

;UNARY
FPDPEEK:   IN A,(URPORT)
           PUSH AF
           CALL NPDPS        ;GET HL=ADDR
           INC HL
           CALL R1OFRD
           DEC HL
           POP DE

FPPDPC:    LD B,A
           CALL R1OFRD
           LD C,A
           LD A,D

OSBC:      OUT (251),A

STACKBCH:  JP STACKBC

;*******************************************************************************
;TRUNC$ - RETURN STRING STRIPPED OF TRAILING SPACES (E.G. FROM ARRAYS)
; E.G. LET A$=TRUNC$ B$(34)
;ENTRY WITH STRING ON FPCS

FPTRUSTR:  CALL SBUFFET      ;DE=START, A AND BC=LEN, PAGING UNCHANGED
                             ;LEN 1-255
           LD H,D
           LD L,E
           ADD HL,BC         ;PT PAST END OF STRING
           LD A," "

TRUNCSLP:  DEC HL
           CP (HL)
           JR NZ,FPSTRS2     ;JR WITH DE=START, BC=LEN

           DEC C
           JR NZ,TRUNCSLP    ;TRUNC$ OF ALL-SPACES STRING=NULL STRING

           JR STACKBCH

;STR$
FPSTRS:    CALL PFSTRS       ;GET NUMBER AS BC DIGITS AT (DE) IN COMMON MEM

;FROM TRUNC$

FPSTRS2:   EX DE,HL
           JP CWKSTK

;CODE RETURNS ASCII CODE OF FIRST CHAR OF STRING ON FPCS, OR 0 IF STRING IS NULL

FPCODE:    IN A,(251)
           PUSH AF
           CALL GETSTRING    ;UNSTACK STRING. DE=START, BC=LEN, PAGED IN
           LD A,B
           OR C
           JR Z,FPCODE2      ;JR IF NUL STRING

           LD A,(DE)
           LD C,A
           LD B,0

FPCODE2:   POP AF
           JR OSBC


;LEN RETURNS STRING LENGTH

FPLEN:     CALL STKFETCH     ;BC=LEN, NO PAGING
           JR STACKBCH

;SQUARE ROOT (W.E. THOMSON)

FPSQR:     DB CALC
           DB RESTACK        ;USE FULL F.P. FORMS
           DB STO0
           DB EXIT

           LD A,(HL)
           AND A
           RET Z             ;RET IF SQR(0) WITH ZERO ON FPCS, DE=STKEND

           ADD A,&80         ;GET TRUE EXPONENT. CY IF WAS >=80H
           RRA               ;/2, WITH BIT 7 AS ORIGINAL
           LD (HL),A
           INC HL
           LD A,(HL)         ;FETCH SGN BIT
           RLA
           JP C,INVARG       ;ERROR IF SQR OF -VE NUMBER

           LD (HL),&7F       ;MANTISSA STARTS AT ABOUT ONE
           LD B,5            ;5 ITERATIONS

SQURLP:    DB CALC
           DB DUP            ;X,X
           DB RCL0           ;X,X,N
           DB SWOP           ;X,N,X
           DB DIVN           ;X,N/X
           DB ADDN           ;X+N/X
           DB EXIT

           DEC (HL)          ;DEC EXPONENT (HALVE VALUE)
           DJNZ SQURLP

           RET               ;DE=STKEND

;*******************************************************************************
;ABS FPCS TOP ENTRY - UNARY FPCS FUNCTION.

FPABS:     LD A,(HL)
           INC HL
           AND A
           JR NZ,FPABS2      ;JR IF FP

           LD A,(HL)         ;SGN BYTE
           INC A
           RET NZ            ;RET IF SIGN WAS 0 (+VE), OK
                             ;ELSE SIGN WAS FF, NOW A=0
           JR NEGABSC

FPABS2:    RES 7,(HL)        ;SIGN=POS.
           RET


;*******************************************************************************
;NEGATE FPCS TOP ENTRY. UNARY FPCS FUNCTION.

FPNEGAT:   LD A,(HL)
           INC HL
           AND A
           JR NZ,FPNEGAT2    ;JR IF FP

           INC HL
           OR (HL)
           INC HL
           OR (HL)           ;TEST FOR INTEGER=0
           RET Z             ;DO NOTHING IF SO

           DEC HL
           DEC HL
           LD A,(HL)         ;SGN
           CPL

NEGABSC:   LD (HL),A         ;REVERSE SIGN (OR MAKE +VE IF ABS)
           INC HL
           LD A,(HL)
           CPL
           LD C,A
           INC HL
           LD A,(HL)
           CPL
           LD B,A
           INC BC            ;NEGATE INTEGER
           LD (HL),B
           DEC HL
           LD (HL),C         ;LOAD IT BACK
           RET

FPNEGAT2:  LD A,&80
           XOR (HL)          ;REVERSE SIGN BIT
           LD (HL),A
           RET

;*******************************************************************************
;RETURN SGN N1 (-1, 0 OR 1). UNARY

FPSGN:     CALL TSTZERO2
           EX DE,HL
           RET Z             ;SGN ZERO=0

           PUSH DE
           INC HL
           LD A,(HL)
           RLA
           DEC HL

           SBC A,A           ;-VE=FF, +VE=00
           LD C,A
           LD DE,&0001
           JP STOREI         ;STORE SIGNED INTEGER, POP DE, RET

;*******************************************************************************
;INT - EQUIVALENT TO TRUNCATE (ZERO BITS AFTER BINARY POINT) IF +VE
;FOR -VE, TRUNC E.G. -5.9=-5.0, SO SUB 1 TO GET -6.9 -> 6.0

FPINT:     LD A,(HL)
           AND A
           RET Z             ;RET IF INTEGER ALREADY (OR ZERO)

           DB CALC
           DB DUP            ;N1,N1
           DB GRTR0          ;N1,(0 OR 1)
           DB JPTRUE         ;JP IF +VE, FPINTP
           DB &0B            ;** BUG FIX

           DB DUP            ;N,N
           DB TRUNC          ;N,TRUNC N
           DB DUP            ;N,TRUNC N,TRUNC N
           DB SWOP13         ;TRUNC N,TRUNC N,N
           DB SUBN           ;TRUNC N,0 IF N WAS A WHOLE NUMBER
           DB JPFALSE        ;TRUNC N. JP IF VALUE WAS INTEGER, TO EXIT2
           DB &03

           DB STKONE         ;TRUNC N,1
           DB SUBN           ;TRUNC N-1
           DB EXIT2

FPINTP:    DB TRUNC          ;INT(N)
           DB EXIT2

;*******************************************************************************
;TRUNCATE - ZERO THE BITS AFTER BINARY POINT, FORCE INTEGER FORM IF POSSIBLE.
;UNARY

FPTRUNCT:  LD A,(HL)
           AND A
           RET Z             ;RET IF INTEGER

           LD B,8            ;FOR LATER
           CP &81
           JR C,TRUNC0       ;JR IF LESS THAN 1

           CP &91
           JR NC,TRUNCLG     ;JR IF >=65536

           PUSH DE
           INC HL
           LD D,(HL)
           INC HL
           LD E,(HL)
           DEC HL
           DEC HL
           LD C,&FF
           BIT 7,D
           JR NZ,TRUNCI2     ;JR IF -VE WITH C=SIGN BYTE FOR SMALL INTEGER

           SET 7,D           ;TRUE NUMERIC BIT
           INC C             ;SIGN BYTE FOR +VE=0

TRUNCI2:   CPL
           ADD A,&91
           SUB B             ;B=8
           ADD A,B
           JR C,TRUNCI3

           LD E,D
           LD D,0
           SUB B

TRUNCI3:   JR Z,TRUNCI5

           LD B,A

TRUNCI4:   SRL D
           RR E
           DJNZ TRUNCI4

TRUNCI5:   JP STOREI

TRUNCLG:   ADD A,&60
           RET P

           CPL
           INC A             ;NEG
           DB &22            ;"JR+2"

;NIL-BYTES.

TRUNC0:    LD A,&28          ;ZERO 40 BITS - ALL OF THEM!

NILBYTES:  PUSH DE
           EX DE,HL          ;PT TO AFTER LAST BYTE OF NUMBER
           DB &22            ;"JR+2"

NILBYLP:   LD (HL),0

NILBYT2:   DEC HL
           SUB B             ;B=8
           JR NC,NILBYLP

           ADD A,B           ;CY SET
           JR Z,NILBYEND

           LD B,A
           SBC A,A           ;A=FF

NILBMASK:  ADD A,A           ;MASK FOR RHS BITS PRODUCED
           DJNZ NILBMASK

           AND (HL)
           LD (HL),A         ;DO THE MASKING

NILBYEND:  EX DE,HL
           POP DE
           RET


;*******************************************************************************
;UDG A$. UDG ADDR. E.G. UDG "A". TRANSLATOR CHANGES USR "A" TO UDG "(CHR$ 144)"
;UNARY. ENTRY WITH STRING ON FPCS AT (HL)

FPUDG:     CALL SBUFFET
           DEC A

IAHOP:     JP NZ,INVARG      ;LEN MUST BE 1

           LD A,(DE)         ;READ CHAR FROM BUFFER
           CP &20
           JR C,IAHOP

           LD HL,(CHARS)
           CP &80
           JR C,FPUDG3       ;JR IF RANGE 20H-7FH

           LD HL,(UDG)
           LD DE,-144*8
           ADD HL,DE         ;ALLOW FOR UDG VAR. POINTING TO CHR$ 144
           CP 169
           JR C,FPUDG3       ;JR IF CHR$ 80H-A8H (LOW UDGS)

           SUB 169
           LD HL,(HUDG)

FPUDG3:    EX DE,HL
           LD L,A
           LD H,0
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL
           ADD HL,DE
           JP STACKHL        ;STACK CHAR PATTERN ADDR


;          INCLUDE SCRSEL1.SAM    ;OPEN/CLOSE SCREEN/PAGES, INTS, BOOTEX, SOUND,
;SCRSEL1.SAM.  SCREEN, OPEN SCREEN, CLOSE SCREEN, SOUND

;SELECT SCREEN C

JSCRN:     CALL SCRNTLK2
           JR JSCR2

;SCREEN N - PRINT/PLOT ETC ON SCREEN N, DISPLAY PAGE N IF (CURDISP)=0

SCREEN:    CALL SYNTAX6

           CALL SCRNTLK1     ;GET MODE/PAGE FOR SCREEN C, Z IF UNUSED

JSCR2:     JR Z,ISCEH        ;'INVALID SCREEN NUMBER' IF NOT OPEN

           LD A,(CUSCRNP)
           LD DE,(SCPTR)
           LD (DE),A         ;UPDATE SCLIST MODE AS WE SWITCH OUT THIS SCREEN
           LD (SCPTR),HL
           LD A,(HL)
           PUSH AF
           CALL SSVARS       ;SAVE SCREEN VARS TO STORE IN SCREEN PAGE
           POP AF
           CALL PRSVARS       ;COPY VARS FROM SELECTED SCREEN TO SYS VARS
           LD A,(CURDISP)
           AND A
           JP Z,DEFDISP

           RET               ;RET - DISPLAY FIXED ON A GIVEN SCREEN


SCRNTLK1:  CALL GETBYTE      ;GET SCREEN NUMBER FROM FPCS

;GET MODE/PAGE FOR SCREEN C FROM LIST. RETURN NZ IF OPEN, Z AND A=FF IF CLOSED
;EXIT WITH HL POINTING TO ENTRY FOR SCREEN. SCREEN NUMBER 1-16 OR ERROR MSG.

SCRNTLK2:  DEC C
           LD A,C
           CP &10

ISCEH:     JP NC,ISCRERR     ;LIMIT SCREENS TO ORIG. OF 1-16

           LD HL,SCLIST
           LD B,0
           ADD HL,BC
           LD A,(HL)         ;BIT 7=0, BITS 6-5=MODE, BITS 4-0=PAGE (BIT 0=0)
           CP &FF
           RET               ;Z IF FF (CLOSED)

;*******************************************************************************
;CLOSE SCREEN N
;CLOSE #N
;CLOSE N  - CLOSE N PAGES

CLSCRN:    CP "#"
           JR NZ,CLNCH       ;JR IF NOT A STREAM CLOSE

           CALL SSYNTAX6     ;CLOSE #S

           CALL STRMINFO
           RET Z             ;RET IF CLOSED

           PUSH HL
           CALL CHLTCHK
           JR Z,CLOS1        ;OK IF K, S, P, $ OR B **
                             ;HL=PTR TO LETTER IN CHANNEL, A=LETTER
           POP DE            ;STREAM PTR
           RST &08           ;CLOSE A NON-K/S/P STREAM.
           DB CSHK           ;DOS CLOSE.
           RET

CLOS1:     LD DE,0           ;VALUE FOR STRM PTR IF CLOSING 4-15
           LD A,C
           CP 4
           JP NC,OLT4

           LD E,A
           LD HL,STRMTAB+5
           ADD HL,DE         ;PT HL TO INITIAL VALUE FOR STREAMS 0-3
           JP OPEN2

CLNCH:     CP &E7            ;SCREENTOK
           JR Z,CLSC0

;CLOSE N PAGES

           CALL SYNTAX6      ;NUMBER OF PAGES TO CLOSE

CLTO:      CALL OCPSR        ;GET L=PAGES USED NOW, HL PTING TO PAST LAST
                             ;ENTRY IN ALLOCT, B/C=PAGES TO CLOSE
           LD A,(RAMTOPP)
           INC A             ;NO. OF PAGES THAT *MUST* BE USED BY BASIC
           LD E,A            ;(UNLESS RAMTOP MOVED)
           LD A,L
           SUB C             ;PAGES THAT WILL BE LEFT AFTER CLOSE
           JR C,OMH

           CP E

OMH:       JP C,OOMERR       ;MUST BE >=MINIMUM NO.

           XOR A

CLPL1:     DEC HL
           LD (HL),A         ;FREE PAGE
           DJNZ CLPL1

SETLPG:    DEC HL
           LD A,L
           LD (LASTPAGE),A
           RET

JCLSCR:    CALL SCRNTLK2
           JR JCS2

CLSC0:     CALL SSYNTAX6      ;N

           CALL SCRNTLK1

JCS2:      RET Z             ;END IF NOT USED YET

           INC C
           DEC C             ;Z IF ORIG SCREEN NUMBER WAS 1 (C=0)
           JP Z,ISCRERR      ;CANNOT CLOSE SCREEN 1!

           AND &1F           ;ISOLATE PAGE USED BY SCREEN TO CLOSE
           LD B,A
           LD A,(CUSCRNP)
           AND &1F
           CP B
           JR NZ,CNCS

           RST &08           ;CANNOT CLOSE CURRENT SCREEN
           DB 46             ;'Current screen'

CNCS:      LD (HL),&FF       ;MARK SCREEN ENTRY AS CLOSED
           LD L,B            ;HL WILL PT TO ALLOC TABLE ENTRY FOR SCRN PAGE
           LD H,ALLOCT/256
           XOR A
           LD (HL),A
           INC HL
           LD (HL),A
           RET

;*******************************************************************************
;OPEN SCREEN N,M<,C> (NUMBER, MODE)
;OPEN #N,A$  (OPEN A STREAM TO A CHANNEL)
;OPEN N      (OPEN A NUMBER OF PAGES FOR USE)

OPSCRN:    CP "#"
           JP NZ,OPNCH       ;JR IF NOT 'OPEN TO A CHANNEL'

;CHECK FOR OPEN #S;A$ OR OPEN #S,A$

           CALL SEXPT1NUM
           CALL INSISCSC     ;',/;'
           CALL SYNTAXA

           CALL SWOP12       ;GIVES NAME,STREAM
           CALL STRMINFO     ;Z IF CLOSED. HL PTS TO STRM PTR MSB
           PUSH HL
           JR Z,OPEN1        ;JR IF CHANNEL IS CLOSED

           CALL CHLTCHK
           JR NZ,SAOERR      ;ERROR IF NOT OPEN TO K/S/P/$/B/N ALREADY

           JR NC,OPEN1       ;JR IF OPEN TO K/S/P, ERROR IF OPEN TO $/B/N

SAOERR:    RST &08
           DB 45             ;'Stream is already open'

OPEN1:     CALL SBFSR        ;COPY FILE NAME TO BUFFER. DE=START, A/C=LEN
           JP Z,IFNER        ;JP IF LEN ZERO

           DEC A
           JR NZ,INVCHP      ;ERROR (OR DOS) IF NAME LONGER THAN 1. E.G.
                             ;OPEN #4;"S" IS OK BUT OPEN #4;"FILE" JUMPS
           LD A,(DE)
           OR &20            ;LETTERS BECOME L.C. AND '$' UNCHANGED
           LD HL,CLTAB
           LD B,5            ;CHECK 5 CHANNEL TYPES

OPCL:      CP (HL)
           INC HL
           JR Z,OPEN2

           INC HL
           DJNZ OPCL

INVCHP:    POP HL            ;PTR TO STREAM PTR MSB
                             ;DE POINTS TO NAME, C=LEN
           RST &08           ;OPEN #S,A$ WITH A$ NOT K, S, P, $, OR B OR LEN>1
           DB OSHK           ;DOS OPEN
           RET

OPEN2:     LD E,(HL)         ;GET DISPLACEMENT FROM TABLE

OLT4:      POP HL
           LD (HL),0
           DEC HL
           LD (HL),E
           RET

CLTAB:     DB "k",1
           DB "s",6
           DB "p",16
           DB "$",21
           DB "b",26

OPNCH:     CP &E7            ; SCREENTOK
           JR Z,OPSCR0

;OPEN N PAGES  OR OPEN TO PAGE N

           CP TOTOK
           JR NZ,NOTP

           CALL SSYNTAX6

           CALL GETBYTE
           DEC C             ;E.G. OPEN TO 1 DOES NOTHING IF LASTPAGE=0
           LD A,(LASTPAGE)
           SUB C
           RET Z             ;RET IF OPEN TO CORRECT PAGE ALREADY

           JR C,TOPO

           CALL STACKA
           JP CLTO

TOPO:      NEG               ;GET PAGES TO OPEN
           CALL STACKA
           CP A

;OPEN N PAGES - NZ ON ENTRY

NOTP:      CALL NZ,SYNTAX6   ;NUMBER OF PAGES TO OPEN

           CALL OCPSR        ;GET HL PTING TO PAST LAST CURRENT PAGE
                             ;ENTRY IN ALLOCT, B/C=PAGES TO CLOSE

OPL1:      INC (HL)
           DEC (HL)
           JP NZ,OOMERR      ;ERROR IF NOT ENOUGH FREE PAGES ABOVE CONTEXT'S
                             ;CURRENT PAGES
           INC HL
           DJNZ OPL1

           LD B,C
           CALL SETLPG       ;DEC HL, SET LAST PAGE

OPL4:      LD (HL),&40       ;RESERVE PAGE
           DEC HL
           DJNZ OPL4

           RET

JOPSCR:    PUSH BC           ;MODE IN B
           CALL SCRNTLK2     ;CHECK SCREEN C
           JR JOPS2

;OPEN SCREEN N,M    (NUMBER, MODE)

OPSCR0:    CALL SSYNTAX8     ;N,M

           LD DE,&0400+34
           CALL LIMDB        ;MODE 0-3 FROM ORIG OF 1-4
           PUSH AF           ;MODE
           CALL SCRNTLK1     ;GET N FROM FPCS, LOOK IN TABLE FOR SCREEN N

JOPS2:     JR Z,OPSCR4       ;OK IF NOT USED YET

           RST &08
           DB 44             ;'Screen already open'

OPSCR4:    PUSH HL           ;SCREEN LIST PTR
           LD HL,ALLOCT+&20  ;HL PTS TO ALLOCT TERMINATOR

OPSCRLP:   DEC L
           LD A,(HL)
           DEC L
           JP Z,OOMERR       ;OUT OF MEMORY IF NO SPACE FOR NEW SCREEN

           OR (HL)           ;Z IF 2 PAGES UNUSED (0)
           JR NZ,OPSCRLP     ;LOOP UNTIL FOUND A FREE 32K BLOCK, EVEN START PAGE

           POP DE            ;SCLIST PTR
           POP AF            ;MODE TO OPEN IN
           PUSH AF

;A=MODE, HL PTS TO ALLOCT ENTRY, DE TO SCLIST ENTRY
;MARK ALLOCT, SCLIST

           LD (HL),&C0
           INC HL
           LD (HL),&C0       ;RESERVE PAGES IN SYSTEM PAGE ALLOC TABLE
           DEC HL            ;L=PAGE NUMBER 02-1EH
           RRCA
           RRCA
           SRL A             ;0MMX XXXX
           XOR L
           AND &E0           ;0MM FROM A, PAGE FROM L
           XOR L
           LD (DE),A         ;MODE/PAGE DATA TO SCRN LIST
           PUSH AF           ;MODE/PAGE FOR NEW SCREEN
           CALL SSVARS       ;STORE CURRENT SCREEN VARS SINCE WE ARE FIDDLING...
           CALL SDISRC       ;STORE CURRENT PALTAB
           LD HL,CUSCRNP
           LD B,(HL)
           POP AF            ;NEW MODE/PAGE
           LD (HL),A
           POP DE            ;D=MODE FOR NEW SCREEN
           PUSH BC           ;B=NORMAL CUSCRNP
           PUSH DE           ;MODE
           LD HL,THFATP
           LD B,(HL)
           LD (HL),1         ;ENSURE NO XRG CHANGE
           POP AF            ;MODE
           PUSH BC
           CALL MODPT2       ;CLEAR NEW SCREEN IN DESIRED MODE, SET UP EXPAN.
                             ;TABLES, ETC

           CALL SDISRC       ;COPY PALTAB TO NEW SCREEN AREA
           POP AF
           LD (THFATP),A     ;ORIG STATUS
           CALL SSVARS       ;SET UP VARS IN NEW SCREEN PAGE
           POP AF            ;ORIG CUSCRNP
           CALL PRSVARS      ;RESTORE SCREEN VARS
           SCF               ;"RESTORE PALTAB"
           DB &3E            ;"JR+1"

SDISRC:    AND A             ;NC - "SAVE PALTAB"

           LD A,(CUSCRNP)
           JP SDISR


;SEE IF PAGE L IS IN USE AS A SCREEN PAGE

SPGLOOK:   LD B,&10
           LD DE,SCLIST

SPGLKLP:   LD A,(DE)
           INC DE
           AND &1F
           CP L
           RET Z             ;RET IF THIS CONTEXT USES PG L AS A SCREEN ALREADY

           DJNZ SPGLKLP
           RET               ;NZ IF UNUSED

;OPEN/CLOSE PAGE SR

OCPSR:     LD DE,&1E00+30
           CALL LIMDB        ;ALLOW ONLY 1-30
           LD B,C            ;B AND C=PAGES TO OPEN
           LD HL,ALLOCT

OCL1:      INC HL
           LD A,(HL)
           CP &40
           JR Z,OCL1         ;LOOK PAST LAST PAGE RESERVED BY BASIC

           LD D,L             ;NUMBER OF PAGES CURRENTLY USED
           RET


;CHANNEL LETTER CHECK.
;ENTRY: DE=DISP FROM CHANS TO CHANNEL.
;EXIT: HL POINTS TO CHANNEL LETTER, Z,NC IF K/S/P. Z,CY IF $/B

CHLTCHK:   LD HL,(CHANS)
           ADD HL,DE         ;PT TO 2ND BYTE OF CHANNEL
           INC HL
           INC HL
           INC HL
           LD A,(HL)
           CP "K"
           RET Z

           CP "S"
           RET Z

           CP "P"
           RET Z

           CP "$"
           SCF
           RET Z

           CP "B"
           SCF
           RET Z

           AND A
           RET


;INTERRUPTS. ENTRY VIA RST 38H

INTS:      LD A,C
           LD (LASTSTAT),A
           PUSH BC           ;HMPR/STAT
           PUSH DE
           RRA
           JP NC,LINEINT

           RRA
           JR NC,COMINT

           RRA
           JR NC,MIPINT

           RRA
           JR NC,FRAMINT

;MIDI OUTPUT (OR OTHER) INTERRUPT

           LD HL,(MOPV)
           JR CMMDIC

;COMS (EX MOUSE) INTERRUPT

COMINT:    LD HL,(COMSV)
           JR CMMDIC

;MIDI INPUT INTERRUPT

MIPINT:    LD HL,(MIPV)
           IN A,(MDIPORT)    ;READ MIDI INPUT BYTE (AUTOMATIC INT CANCEL?)

CMMDIC:    INC H
           DEC H
           CALL NZ,HLJUMP

           JP INTEND

FRAMINT:   LD HL,(FRAMIV)
           LD A,H
           OR L
           CALL NZ,HLJUMP

           LD HL,LINICOLS
           LD (LINIPTR),HL           ;RESET LINE INT COL CHANGE LIST PTR
                                     ;TO START
           LD A,(HL)                 ;LINE TO INT ON,
           OUT (STATPORT),A          ;OR FF FOR 'NEVER INTERRUPT'

           LD A,(PALFLAG)
           LD HL,PALTAB+15
           RRA
           JR NC,FRMI3

           LD L,(PALTAB+35)\256

FRMI3:     LD BC,16*256+CLUTPORT
           OTDR                      ;SET UP PALETTE MEMORIES

           LD HL,SPEEDIC             ;COUNTER FOR DELAY BETWEEN SWAPPING INKS
           DEC (HL)
           JR NZ,FRMI5

           INC HL                    ;PT TO PALETTE FLAG
           INC (HL)                  ;FLIP BIT 0 OF PALFLAG - USE OTHER PALET
           LD A,(SPEEDINK)
           DEC HL
           LD (HL),A                 ;RELOAD COUNTER TILL NEXT FLASH
           LD HL,LINICOLS
           JR FRMI4

FISCL:     INC HL
           INC HL
           LD A,(HL)         ;COL 1
           INC HL
           LD B,(HL)         ;COL 2
           LD (HL),A
           DEC HL
           LD (HL),B
           INC HL
           INC HL            ;NEXT LINE

FRMI4:     LD A,(HL)
           INC A
           JR NZ,FISCL

FRMI5:     LD HL,FRAMES
           INC (HL)
           JR NZ,INTS3

           LD A,(SOFFCT)     ;DECED EVERY 5.1 SECS OR SO, SET TO 0 BY KEYBD USE.
           DEC A             ;IF DECED TO ZERO, KYBD NOT USED FOR ABOUT 22 MINS.
           LD (SOFFCT),A
           JR NZ,INTS2       ;JR IF USED WITHIN LAST 22 MINS.

           LD A,(SOFE)
           AND A
           JR NZ,INTS2       ;JR IF 'SCREEN OFF' DISABLED

           LD A,&80
           OUT (KEYPORT),A
           LD (SOFLG),A      ;'SCREEN OFF'

INTS2:     INC HL
           INC (HL)          ;INC SECOND BYTE OF FRAMES
           JR NZ,INTS3

           INC HL
           INC (HL)          ;AND THIRD
           JR NZ,INTS3

           LD HL,(FRAMES34)
           INC HL            ;FOURTH AND FIFTH
           LD (FRAMES34),HL

INTS3:     LD HL,(MOUSV)
           DEC H
           LD A,H
           INC H
           JR NZ,INTS4       ;IF JR NOT TAKEN, A=FF

           IN A,(KEYPORT)
           LD HL,MSEDP
           LD B,8            ;READ MOUSE 9 TIMES TO CANCEL IT

MSDML:     LD A,&FF
           IN A,(KEYPORT)
           LD (HL),A
           INC HL
           DJNZ MSDML        ;ALWAYS Z HERE

INTS4:     CALL NZ,HLJUMP

INTS5:     CALL KEYRD2
           JR INTEND


;ENTRY:
;LINIPTR POINTS TO SCAN LINE VALUE IN 4-BYTE CURRENT ENTRY (SCAN/PAL/INK1/INK2)
;BORDER TIME HAS FINISHED BEFORE WE GET HERE

LINEINT:     LD HL,(LINIPTR)

LNINSCAN:    LD D,(HL)                 ;D=SCAN LINE IN LINICOL ENTRY
             LD BC,&0100+CLUTPORT      ;PORT BC READS PEN Y (SCAN LINE)
             IN A,(KEYPORT)
             AND &20
             JR NZ,LINILP              ;JR IF LIGHT PEN KEEPS PEN Y FROZEN

LNWAITLP:    IN A,(C)
             CP D
             JR Z,LNWAITLP             ;WAIT FOR NEXT SCAN'S BORDER

LINILP:      INC HL
             LD B,(HL)                 ;PALETTE MEMORY NO.
             INC HL
             LD A,(HL)                 ;NEW VALUE
             OUT (C),A                 ;OUT (BC) WRITES DESIRED PAL. MEM.
             INC HL                    ;SKIP ALTERNATE VALUE FOR FLASHING
             INC HL
             LD A,(HL)                 ;NEXT SCAN VALUE (MIGHT BE THE SAME)
             SUB D
             JR Z,LINILP               ;DO MORE CHANGES FOR THIS SCAN (SCAN D+1)
                                       ;TAKES ABOUT 32 T'S FOR FIRST COLOUR,
                                       ;THEN ABOUT 80 T'S PER LOOP, SO SHOULD
                                       ;GET 2 CHANGES IN BORDER TIME, AND ABOUT
                                       ;3 IN MIDDLE PART.
                                       ;(IF WE USE TOO MANY CHANGES, WE MIGHT
                                       ;MISS A CLOSE-FOLLOWING LINE INT CHANGE
                                       ;AND THEN MISS ALL LATER CHANGES COS
                                       ;LINE INT REG NOT SET UP.)

             CP 1                      ;IS NEXT ENTRY FOR NEXT SCAN?
             JR Z,LNINSCAN             ;IF SO, WAIT FOR IT

             ADD A,D
             LD (LINIPTR),HL
             OUT (STATPORT),A          ;IF A>191, NO MORE COLOUR CHANGES

INTEND:      LD HL,(SPSTORE)
             POP DE
             POP AF          ;A=FORMER HMPR
             RET


;FROM INTS

KEYRD2:    CALL KINTER       ;SCAN KEYBD, PLACE CHAR IN BUFFER IF THERE IS ONE.
           LD HL,(KBQP)      ;L=KEY BUFFER QUEUE END (POSN TO PLACE CHAR AT)
                             ;H=QUEUE HEAD (PTS TO NEXT CHAR TO BE READ)
                             ;BOTH ARE DISPLACEMENTS FROM KBQB (BUFFER START)
                             ;IF H=L, BUFFER IS EMPTY.
           LD A,H
           CP L
           RET Z             ;RET IF NO CHARS IN BUFFER

           LD HL,FLAGS
           BIT 5,(HL)
           RET NZ            ;RET IF LAST KEY NOT READ YET (KEY AVAILABLE)

           SET 5,(HL)        ;'KEY PRESSED'
           LD L,A
           LD H,0
           INC A
           AND &07
           LD (KBQP+1),A     ;NEW HEAD POSN REFLECTS CHAR TRANSFER TO COME
           LD DE,KBQB
           ADD HL,DE         ;PT TO HEAD
           LD A,(HL)
           LD (LASTK),A      ;TRANSFER TO LASTK
           RET

KINTER:    CALL KEYSCAN
           LD A,0
           JR NZ,LDLH        ;JR IF NO KEY PRESSED
                             ;(NLASTH=0 IF NO KEY OR JUST A SHIFT KEY. USED BY
                             ;AUTO-REPEAT)
           LD HL,NLASTH
           LD A,E            ;UNSHIFTED KEY CODE
           CP (HL)
           JR Z,KBCR         ;JR IF SAME KEY AS LAST TIME

           INC HL
           CP (HL)
           JR Z,KBCR         ;OR TIME BEFORE

           CP 65             ;CODE FOR ENTER KEY - PRONE TO STUTTER
           JR NZ,KBCR

           INC HL            ;EXTRA CHECK FOR ENTER KEY ONLY
           CP (HL)           ;TIME-BEFORE-TIME BEFORE

KBCR:      PUSH AF
           CALL KYVL         ;GET A=CHAR, USING D AND E
           LD C,A
           LD HL,REPCT
           POP AF
           JR NZ,KBDI        ;JR IF NOT SAME KEY AS LAST TIME, OR TIME BEFORE

           DEC (HL)
           RET NZ            ;RET IF NOT TIME TO REPEAT KEY

           PUSH HL           ;ELSE CHECK IT IS STILL HELD DOWN (NOT SOME OTHER
           LD DE,KBUFF+8     ;KEY)
           LD HL,(LKPB)
           LD A,H            ;A=1 FOR PORT FE, 9 FOR FF
           ADD A,E
           LD E,A
           LD A,(DE)         ;A=BYTE FOR DESIRED PORT FROM KBUFF BIT MAP
                             ;'CURRENT' DATA
                             ;L=1 FOR BIT 7, 8 FOR BIT 0
KBXL:      RLCA
           DEC L
           JR NZ,KBXL        ;GET DESIRED KEY BIT TO CARRY

           POP HL
           RET C             ;NO AUTO-REPEAT IF KEY NO LONGER HELD DOWN

           INC (HL)
           LD A,(FLAGS)
           AND &20
           RET NZ            ;RET IF STILL KEYS IN BUFFER (DO NOT ACCUMULATE
                             ;AUTO-REPEATING KEYS)

           LD A,(REPPER)     ;RELOAD REPCT FROM REPPER (DELAY BETWEEN REPEATS)
           JR KBRK

KBDI:      LD A,(REPDEL)

KBRK:      LD (HL),A         ;NEW KEY - SET UP REPCT FOR INITIAL DELAY BEFORE
                             ;AUTO-REPEAT

           LD HL,(KBQP)      ;L=KEY BUFFER QUEUE END (POSN TO PLACE CHAR AT)
                             ;H=QUEUE HEAD (PTS TO NEXT CHAR TO BE READ)
                             ;BOTH ARE DISPLACEMENTS FROM KBQB (BUFFER START)
                             ;IF H=L, BUFFER IS EMPTY. IF *NEW* POSN OF H=L,
                             ;BUFFER IS FULL
           LD A,L
           INC A
           AND &07
           CP H
           RET Z             ;RET IF BUFFER FULL (WRAPPED SO END=HEAD)

           LD (KBQP),A
           LD H,0
           LD DE,KBQB
           ADD HL,DE         ;PT TO END
           LD (HL),C         ;PLACE CHAR IN BUFFER
           LD A,(LASTKV)

LDLH:      LD HL,NLASTH
           LD C,(HL)
           LD (HL),A
           INC HL
           LD B,(HL)
           LD (HL),C
           INC HL
           LD (HL),B
           RET

;GET KEY CODE FROM MAP USING E AND D (SHIFT)

KYVL:      LD HL,(KBTAB)
           LD A,D            ;00 IF NO SHIFT, OR 1/2/3 FOR CAPS/SYM/CNTRL
           LD D,0
           ADD HL,DE
           AND A
           JR Z,KINT4       ;JR IF NO SHIFT USED

           LD E,70

KYVLP:     ADD HL,DE         ;PT TO CAPS SHIFT/SYM/CNTRL TABLE
           DEC A
           JR NZ,KYVLP

KINT4:     LD A,(FLAGS2)
           AND &08           ;Z=CAPS LOCK OFF
           LD A,(HL)
           RET Z

           CALL ALPHA
           RET NC            ;RET IF NOT A LETTER

           AND &DF           ;FORCE LOWER CASE LETTERS TO UPPER CASE
           RET

;KEYSCAN.
;ACTION: LOOK FOR CHANGED BITS IN KEYBOARD STATE SINCE LAST SCAN, SO THAT
;SEVERAL KEYS CAN BE PRESSED DOWN AND A NEW KEY WILL STILL BE NOTICED. IGNORE
;KEY RELEASES. IF THERE HAVE BEEN NO NEW PRESSES, RETURN THE SAME KEYSCAN
;CODES AS LAST TIME, UNLESS ALL KEYS ARE RELEASED - THEN RETURN NULL CODE.

;ENTRY: NO CONDITIONS
;EXIT: IF NZ, NO KEY PRESSED AND DE=FFFF
;      IF Z, E=KEY VALUE
;            IF D=0, NO SHIFT, ELSE D=1 (CAPS SH.) 2 (SYM. SH.) OR 3 (CONTROL)

;ENTER AT KEYSCAN+3 WITH HL=DIFFERENT 18-BYTE KBUFF IF DESIRED

;USED BY INKEY$ - 2 SCANS IN CASE OF INTERRUPT

TWOKSC:    CALL KEYSCAN
           RET Z

KEYSCAN:   LD HL,KBUFF       ;18-BYTE STORE
           PUSH HL
           LD BC,&FE00+KEYPORT
                             ;C HAS PORT FOR BITS 4-0, B STARTS
                             ;WITH A8 LOW FOR 1ST KEY ROW
           LD D,&E0          ;MASK TO KEEP BITS 7-5 OF A, USE 4-0 OF E

KBSL:      IN E,(C)          ;READ BITS 4-0
           LD A,B            ;A WILL BE ON HI ADDR LINES DURING PORT READ
           IN A,(STATPORT)   ;READ BITS 7-5
           XOR E
           AND D
           XOR E
           INC B
           JR Z,KBEL         ;JR IF WE JUST DID 'SPECIAL' PORT FFFEH

           LD (HL),A
           DEC B
           INC HL
           RLC B             ;NEXT PORT (FEFE, FDFE, FBFE...7FFE)
           JR C,KBSL         ;LOOP UNTIL BACK TO PORT FEFE AGAIN

           LD B,&FF
           JR KBSL

KBEL:      OR &E1            ;ONLY BITS 4-0 VALID FOR PORT FFFE, AND FORCE
           LD (HL),A         ;BIT 0 (CONTROL KEY BIT) HI TOO
           POP HL            ;KBUFF
           LD D,H
           LD E,L
           SET 0,(HL)        ;'NO CAPS SHIFT' (SCAN SEPARATELY FOR IT)
           INC HL
           INC HL
           INC HL
           SET 5,(HL)        ;'NO ESC'
           INC HL
           INC HL
           INC HL
           INC HL
           SET 1,(HL)        ;'NO SYM. SHIFT' (SCAN SEPARATELY FOR IT)
           INC HL
           INC HL            ;PT TO LAST SCAN DATA (BYTES 10-18)
           LD B,9            ;(HL=KBUFF+9, DE=KBUFF)

KBCL:      LD A,(DE)         ;THIS SCAN DATA
           LD C,(HL)         ;LAST SCAN DATA
           LD (HL),A         ;LAST SCAN DATA UPDATED WITH NEW DATA - BUT WE
                             ;HAVE IT IN C NOW
           XOR C
           CPL               ;GET ALTERED BITS SINCE LAST SCAN AS 0'S
           OR (HL)           ;KEEP AS 0'S IF CHANGE WAS 1->0 (PRESSED)
           LD (DE),A         ;'CHANGED' DATA TO KBUFF
           INC HL
           INC DE
           DJNZ KBCL

           LD B,9

KBDL:      DEC DE
           LD A,(DE)
           INC A
           JR NZ,KBYK        ;JR IF ANY BIT RESET

           DJNZ KBDL

;NO NEW PRESSES SINCE LAST SCAN. HL=KBUFF+18

           LD B,9
           LD DE,(LASTKV)    ;E=LAST VALUE

KBAKL:     DEC HL
           LD A,(HL)
           INC A
           JR NZ,KBSH        ;JR IF KBUFF SHOWS ANY KEY PRESSED APART FROM SHIFT
                             ;USE LAST VALUE, PLUS CURRENT SHIFT STATUS
           DJNZ KBAKL

           INC B             ;NZ
           RET

KBYK:      DEC A
           LD C,9

KBBL:      DEC C
           RRA
           JR C,KBBL         ;CHANGE BIT POSN TO NUMBER IN C (1-8)

           LD (LKPB),BC      ;LAST KEY PORT/BIT SAVED FOR AUTO-REPEAT CHECKING
                             ;B=1 IF LAST PORT = FEFE, 9 IF FFFE. C=8 FOR BIT
                             ;0, 1 FOR BIT 7
           LD A,C
           ADD A,A           ;*2
           ADD A,A           ;*4
           ADD A,A           ;*8
           ADD A,C           ;*9 (09-48H)
           SUB B             ;SUB 1-9 TO GET 00-47H
           LD E,A            ;SCAN CODE TO E
           LD HL,SOFFCT
           XOR A
           LD (HL),A         ;ZERO SCREEN OFF COUNTER - KEYBOARD USED
           INC HL
           ADD A,(HL)        ;SOFLG
           JR Z,KBSH         ;JR IF SCREEN NOT TURNED OFF BY NO KEY USE

           XOR A
           LD (HL),A         ;'ON'
           LD A,(BORDCOL)
           AND &7F
           LD (BORDCOL),A
           OUT (KEYPORT),A

KBSH:      LD BC,&FEFE
           IN A,(C)
           LD D,1
           AND D
           JR Z,KBLD         ;JR IF CAPS SHIFT - D=1
                             ;ELSE D=1
           INC B
           IN A,(C)
           AND D
           LD D,3
           JR Z,KBLD         ;JR IF CONTROL - D=3

           DEC D
           LD B,&7F
           IN A,(C)
           AND D
           JR Z,KBLD         ;JR IF SYM SHIFT - D=2

           DEC D
           DEC D             ;Z=KEY OBTAINED. D=0 FOR NO SHIFT

KBLD:      LD (LASTKV),DE
           RET
                                  ;KEYRD2

;          INCLUDE SCRSEL2.SAM    ; GOTO, CONT, GETTOKEN, MODPT2, AUTO
;SCRSEL2.SAM.

GOSUB:     LD HL,GOSUB2
           DB &DD            ;"JR+3"

GOTO:      LD HL,GOTO2

GSUBTOC:   PUSH HL
           CP &DE            ;ONTOK
           JR Z,GOTON

           CALL EXPT1NUM     ;LINE NUMBER
           POP HL            ;ADDR OF GOTO OR GOSUB ROUTINE
           CALL CHKEND

           JP (HL)

;E.G. GOSUB (OR GOTO) ON X;100,234,400

GOTON:     CALL SEXPT1NUM    ;SKIP 'ON', EVAL NUMBER
           PUSH AF
           CP ";"
           JP NZ,NONSENSE

           POP AF
           JR C,GOTON2       ;JR IF RUNNING

           POP HL            ;GOTO/GOSUB ADDR

GOTONSL:   CALL SEXPT1NUM    ;SKIP E.G. 100,200,400
           CP ","
           JR Z,GOTONSL

           RET               ;TO NEXT STAT

GOTON2:    CALL FPTOA        ;GET NUMBER AFTER 'ON' IN C AND A
                             ;CY IF >255
           SBC A,A           ;A=255 IF OUT OF RANGE, ELSE 0
           JR Z,GOTONRL      ;C IS OK IF A=0

           LD C,A            ;ELSE LET C=255

GOTONRL:   PUSH BC           ;C=EXPR NUMBER
           CALL SEXPT1NUM
           POP BC
           DEC C
           RET Z             ;RET TO GOTO OR GOSUB IF THIS IS DESIRED EXPR

           CALL FDELETE      ;DISCARD EXPR FROM FPCS
           RST &18
           CP ","
           JR Z,GOTONRL      ;LOOP IF THERE ARE MORE LINE NOS TO SKIP

           POP DE            ;GOTO/GOSUB ADDR
           RET               ;TO NEXT STAT - LINE NOS RAN OUT.

GOSUB2:    CALL GETINT
           LD A,H
           INC A
           JP Z,IOORERR

           LD B,&00          ;'GOSUB' TYPE
           PUSH HL           ;LINE NO.
           CALL BSTKE        ;STACK RETURN ADDR
           POP HL
           JP GOTO3

;GET TOKEN SR - VIA JUMP TABLE

GETTOKEN:  LD C,A
           EX AF,AF'         ;NO OF WORDS TO CHECK,+1

GTTOK1:    INC HL

GTTOK2:    BIT 7,(HL)
           JR Z,GTTOK1       ;LOOP TILL WE FIND THE END OF A KEYWORD
                             ;32 TS PER LOOP

           DEC C
           RET Z             ;RET IF WE HAVE CHECKED THEM ALL - Z=FAILED
                             ;DE=FIRST LETTER OF ELINE WORD COPY
           INC HL
           LD A,(DE)
           XOR (HL)
           AND &DF
           JR NZ,GTTOK2      ;LOOP BACK AND CHECK ANOTHER WORD IF MATCH FAILS
                             ;ABOUT 80 TS PER LOOP IF NO MATCH. ABOUT 35USEC
                             ;PER 5-LETTER WORD OR 5.3MSEC FOR 150 WORDS.
           PUSH DE           ;PTR TO FIRST LETTER IN ELINE WORD
           INC DE

GTTOK3:    INC HL
           LD A,(HL)
           CP " "
           LD A,(DE)
           INC DE
           JR NZ,GTTOK4      ;JR IF NO EMBEDDED SPACE IN KEYWORD IN LIST

           CP (HL)
           JR Z,GTTOK3       ;ELSE ACCEPT ONE IN INPUT

           INC HL            ;BUT DON'T INSIST - SKIP LIST PTR IF NO SP IN INPUT

GTTOK4:    XOR (HL)
           AND &DF
           JR Z,GTTOK3       ;LOOP IF STILL MATCHING OK

           AND &7F
           JR NZ,GTTOK5      ;JR IF INPUT AND LIST WORDS DON'T END NOW

           LD A,(HL)
           RLCA
           JR C,GTTOK6       ;OK IF LIST WORD HAS FINISHED

GTTOK5:    POP DE
           JR GTTOK2

GTTOK6:    CP &7E            ;('=' TERMINATOR =7B AFTER RLCA, '>'=7DH, '$'=49H)
           CCF               ;NC IF '=' OR '>' OR '$'
           LD A,(DE)         ;INPUT CHAR AFTER MATCHED WORD
           CALL C,ALDU       ;CALL TO INSIST ON NON-LETTER AFTER E.G. PRINTx
                             ;BUT NOT AFTER <>,>= OR <= OR CHR$a
           JR C,GTTOK5       ;('=' AND '>' NEVER CALL ALPHA OR JR HERE)

           POP HL            ;FIRST LETTER OF ELINE WORD COPY
           EX AF,AF'
           SUB C             ;A=1 IF FIRST WORD MATCHES, ETC.
           RET


MODPT2:    AND &03
           LD HL,MODE
           LD C,(HL)
           PUSH BC           ;SAVE PREVIOUS MODE
           LD (HL),A         ;NEW MODE
           CP 2
           PUSH AF
           CALL NC,SUET      ;SET UP EXPANSION TABLE IF NEEDED

           POP AF
           PUSH AF           ;MODE
           RRCA
           RRCA
           RRCA              ;MODE BITS TO BITS 6 AND 5
           LD C,A
           LD HL,CUSCRNP
           LD A,(HL)         ;KEEP CURRENT VID PAGE,
           XOR C             ;BUT
           AND &9F           ;USE BITS 6 AND 5 OF C TO SET MODE
           XOR C
           LD (HL),A
           IN A,(VIDPORT)
           XOR (HL)
           AND &1F
           JR NZ,MDL2        ;JR IF WE ARE NOT DISPLAYING THIS SCREEN - AVOID
                             ;ALTERING HARDWARE MODE
           LD A,(HL)
           OUT (VIDPORT),A

MDL2:      POP AF            ;NEW MODE
           POP BC            ;C=PREV MODE
           PUSH AF           ;NEW MODE
           CP 1              ;CY IF MODE 0
           SBC A,A           ;MODE 0=FF, REST=0
           LD HL,&0809       ;CHAR WIDTH/HEIGHT FOR MODES 1-3
           ADD A,L
           LD L,A            ;DEC HEIGHT TO 8 IF MODE 0, TO FIT ATTR
           POP AF

           CALL MDSR

           LD A,(TEMPB1)     ;OLD MODE
           JR Z,M2ST         ;JR IF MODE 2 BEING SET

           CP 2
           JR NZ,ECLS        ;JR IF NOT MODE 2 NOW, AND NOT CHANGING TO MODE 2

           ;ELSE IF CHANGING FROM MODE 2 TO ANOTHER MODE, SAVE M2 PALTAB
           ; 0-3, GET BACK NON-MODE-2 COLOURS

           LD HL,(M3PAPP)
           LD (M23PAPP),HL
           LD HL,(M3LSC)
           LD (M23LSC),HL
           LD C,A            ;C=NZ - 'HALVE'
           JR M2ST2

;MODE 2 BEING SET

M2ST:      CP 2
           JR Z,ECLS         ;JR IF MODE 2 ALREADY

           LD HL,(M23PAPP)
           LD (M3PAPP),HL
           CALL M3TO2        ;CONVERT L
           PUSH AF
           LD L,H
           CALL M3TO2        ;CONVERT H
           LD H,L
           POP AF
           LD L,A
           LD (M23PAPP),HL   ;PREVENTS STRIPED INKS AFTER MODE 2 SET.
           LD HL,(M23LSC)
           LD (M3LSC),HL
           CALL CVLSP        ;CONVERT LS PAPER
           LD C,0            ;C='HALVE'

M2ST2:     LD A,(THFATP)     ;WE ARE CHANGING TO/FROM MODE 2 -  IF
           AND A             ;'THIN' PIXEL STATUS WILL CHANGE,
           LD A,C
           CALL Z,SETFP      ;FIDDLE XCOORD/XRG

           CALL PALSW

ECLS:      CALL R1OFFJP
           DW MCLS           ;TURN ROM 1 OFF, JP MCLS

;CALLED FROM CSIZE WITH A AND C=MODE, HL=CSIZE

MDSR:      PUSH AF           ;NEW MODE
           LD A,C            ;PREV MODE (SAME IF CALLED FROM CSIZE)
           LD (TEMPB1),A
           LD (CSIZE),HL     ;H=WIDTH, L=HEIGHT
           LD A,192
           LD E,&FC

MDSL:      INC E
           SUB L             ;SUB CHAR HEIGHT
           JR NC,MDSL        ;CALC SCREEN HEIGHT IN LINES, MINUS 3
                             ;(UW BOT)
           ADD A,L           ;'LEFT OVER' PIXELS
           LD (LSOFF),A      ;LOWER SCREEN OFFSET - SO LEFT-OVER PIX BETWEEN
                             ;UPPER SCREEN AND LOWER SCREEN
           LD A,L
           ADD A,A           ;DISP OF GRAPHICS ORIGIN FROM SCREEN BOTTOM IS
           LD (ORGOFF),A     ;2 CHAR HEIGHTS
           LD D,31           ;RHS FOR MODES 0, 1 AND 3
           POP AF            ;MODE
           PUSH AF
           JR NZ,MDSR3       ;JR IF NOT MODE 2

           LD D,63           ;RHS FOR MODE 2 64-COL MODE
           LD A,(FL6OR8)
           AND A
           JR NZ,MDSR3       ;JR IF 8-BIT

           LD D,84           ;RHS FOR MODE 2 85-COL MODE
           LD A,6
           LD (CSIZE+1),A    ;WIDTH

MDSR3:     LD HL,UWRHS
           LD (HL),D         ;UWRHS
           INC HL
           XOR A
           LD (HL),A         ;UWLHS
           INC HL
           LD (HL),A         ;UWTOP
           INC HL
           LD (HL),E         ;UWBOT
           INC HL
           LD (HL),D         ;LWRHS
           LD (WINDMAX),DE
           INC HL
           LD (HL),A         ;LWLHS
           INC HL
           INC E
           LD (HL),E         ;LWTOP=UWBOT+1
           INC HL
           INC E
           LD (HL),E         ;LWBOT=LWTOP+1
           POP AF            ;Z IF MODE 2
           RET

;FATPIX 0=USE THIN PIXELS IN MODE 2. 1=USE FAT PIXELS

FATPIX:    CALL SYNTAX6

           LD DE,&0200+30    ;LIMIT TO <2 OR IOOR
           CALL LIMBYTE

           LD HL,THFATP
           CP (HL)
           RET Z             ;RET IF NO CHANGE IN FATPIX STATUS

           LD (HL),A
           LD A,(MODE)
           CP 2
           RET NZ            ;DON'T FIDDLE XCOORD AND XRG UNLESS MODE 2

           LD A,(HL)

SETFP:     LD HL,(XCOORD)
           AND A
           JR Z,FPX2         ;JR IF CHANGED FROM 1 TO 0 (FAT TO THIN)

           SRL H
           RR L              ;HALVE X
           DB &3E            ;'JR+1'

FPX2:      ADD HL,HL         ;DOUBLE X COORD TO KEEP SAME SCREEN POSN

           LD (XCOORD),HL    ;A=0 FOR DOUBLE, 29H FOR HALVE

           PUSH AF
           CALL ADDRNV
           POP AF
           LD DE,87
           ADD HL,DE         ;PT TO XRG
           CALL R1OFFJP
           DW CGXRG          ;CHANGE XRG WITH ROM1 OFF **

PXIOOR:    RST &08
           DB 30             ;IOOR

;CSIZE W,H
;WIDTH CAN BE 6 OR 8 BUT 6 ONLY EFFECTIVE IN MODE 2
;HEIGHT CAN BE 6-32, DOUBLE HEIGHT USED IF 16 OR MORE.

WIDTH:     CALL SYNTAX8

           CALL GETBYTE      ;H
           PUSH BC
           CALL GETBYTE      ;W
           CP 6
           JR Z,CSZ2

           CP 8
           JR NZ,PXIOOR

CSZ2:      POP DE            ;E=H
           LD D,A            ;D=W
           LD A,E
           CP 6
           JR C,PXIOOR       ;HEIGHTS OF 0-5 ARE CRAZY - BUT 6-7 MIGHT BE OK
                             ;WITH THE RIGHT CHARACTER SET.
           CP 33
           JR NC,PXIOOR      ;HEIGHTS OF 6-32 ARE ALLOWED

           EX DE,HL
           LD A,H            ;WIDTH
           SUB 6
           LD (FL6OR8),A     ;0 IF WIDTH 6, ELSE NZ
           LD A,(MODE)
           LD C,A            ;'PREVIOUS MODE' NEEDED BY MDST2
           CP 2              ;SET Z IF MODE 2
           PUSH AF
           CALL MDSR         ;MODE - SET WIDOWS, CSIZE. HL=CSIZE
           POP AF
           RET NZ            ;RET IF NOT MODE 2

                             ;ELSE SET UP EXPANSION TABLE IF MODE 2, IN CASE
                             ;SWITCHING BETWEEN M2/M3 O/P TYPES

;SET UP EXPANSION TABLE. ENTRY: A=MODE 2/3, Z IF 2

SUET:      LD HL,EXTAB       ;PT TO EXPANSION TABLE
           LD C,0            ;FIRST VALUE TO EXPAND
           JR Z,DBTABCLP     ;JR IF MODE 2

QUADTCLP:  LD A,C
           CALL QUADBITS     ;A->DE, QUADED BITS
           LD (HL),D
           INC HL
           LD (HL),E
           INC HL
           INC C
           LD A,C
           CP 16
           JR C,QUADTCLP     ;QUAD 00-0FH

           RET

DBTABCLP:  LD A,C
           CALL DBBITS       ;A->E, DOUBLED BITS
           LD (HL),E
           INC HL
           INC C
           LD A,C
           CP 16
           JR C,DBTABCLP     ;DOUBLE 00-0FH

           RET

;A->DE, QUADED BITS

QUADBITS:  CALL DBBITS
           LD A,E

;A->DE WITH ALL BITS DOUBLED

DBBITS:    LD B,8            ;BITS TO DO

DBBITSLP:  RRCA
           RR D
           RR E              ;DE HAS DOUBLED BITS
           RLCA
           RRCA
           RR D
           RR E
           DJNZ DBBITSLP

           RET

;AUTO <LINE><,STEP>

AUTO:      CALL CRCOLON
           JR Z,AO1          ;JR IF JUST 'AUTO', USE BOTH DEFAULTS

           CALL GIR2         ;GET LINE VALUE IN HL AND BC
           LD BC,10          ;DEFAULT STEP IS 10
           CP ","
           JR NZ,AO2         ;JR IF NO STEP

           PUSH HL           ;SAVE LINE VALUE
           CALL GIR          ;GET STEP VALUE IN HL,BC
           POP HL
           JR AO2

AO1:       LD HL,(EPPC)
           LD BC,10
           ADD HL,BC         ;DEFAULT LINE VALUE IS EPPC+10

AO2:       CALL RUNFLG
           RET NC            ;CANNOT USE CHKEND - NEED C

           XOR A
           SBC HL,BC
           CCF
           ADC A,A           ;A=O IF STEP>LINE, ELSE A=1
           LD (AUTOFLG),A    ;0=OFF, NZ=ON
           RET Z             ;RET IF OFF

           LD (EPPC),HL      ;INITIAL EPPC=LINE-STEP
           LD (AUTOSTEP),BC
           POP DE            ;NEXT STAT
           POP DE            ;ERROR HANDLER
           LD BC,AULL
           JP R1XJP          ;TURN ROM1 OFF, JP MAINX

SOUND:     LD DE,INSTBUF

SNDLP:     PUSH DE
           CALL EXPT2NUMS
           POP DE
           JR NC,SND1

           PUSH DE
           CALL GETBYTE
           PUSH AF
           LD DE,&2000+30
           CALL LIMBYTE      ;ALLOW 0-31
           POP BC
           POP DE
           LD (DE),A
           INC E
           LD A,B
           LD (DE),A
           INC E
           JP Z,NRFLERR      ;LIMIT TO 254 VALUES IN INSTBUF (127 PAIRS)

SND1:      RST &18
           CP ";"
           JR NZ,SND2

           RST &20           ;SKIP ';'
           JR SNDLP

SND2:      CALL CHKEND

           LD A,&FF
           LD (DE),A         ;TERMINATE LIST
           LD BC,256+SNDPORT ;SOUND ADDRESS REG PORT
           LD HL,INSTBUF     ;HOLDS AT LEAST ONE PAIR
           JR SND3

SNDOPL:    OUT (C),D         ;SET REG
           DEC B             ;SOUND DATA REG PORT
           OUT (C),E         ;SEND DATA
           INC B

SND3:      LD D,(HL)
           INC L
           LD E,(HL)
           INC L
           CP D
           JR NZ,SNDOPL      ;LOOP UNTIL TERMINATOR HIT

           RET


;PERFORM BOOT ACTION
;FIND A PAGE FOR DOS AND MARK IT.

BOOT:      CALL SYNTAX3

           CALL GETBYTE
           AND A
           JR NZ,BOOTEX      ;E.G. BOOT 1 FORCES BOOT OR RE-BOOT
                             ;NO AUTO-LOAD
           LD A,(DOSFLG)
           AND A
           JR Z,BOOTNR       ;JR IF DOS NOT RESIDENT - ELSE AUTOLOAD ONLY

           RST &08
           DB ALHK           ; DO AUTO-LOAD
           RET

BOOTNR:    CALL BOOTEX

           RST &08
           DB BTHK           ;DO AUTO-LOAD, BUT NO ERROR IF NONE
           RET

BOOTEX:    LD HL,ALLOCT+&1F

FDPL:      LD A,(HL)
           AND A
           JR Z,GDP          ;JR IF FREE PAGE

           CP &60
           JR Z,GDP          ;JR IF RE-BOOTING TO A DOS PAGE

           DEC L
           JR NZ,FDPL

           RST &08
           DB 1              ;'OUT OF MEMORY' IF NO FREE PAGE FOR DOS

GDP:       LD A,L
           CALL SELURPG      ;DOS PAGE IN AT 8000H

                             ;START OF BRUCE GORDONS CODE
                             ;LOAD STUFF NOW
           LD C,&D0          ;RESET CHIP
           CALL SDCX         ;EXITS WITH B=0
           CALL REST

           ;TEST FOR INDEX HOLE

           LD H,&FE          ;HL=FEXX
           LD E,H            ;E COUNTS 2 OUTER LOOPS
           LD B,6

BOOT2:     DEC HL
           LD A,H
           OR L
           JR NZ,BOOT3

           INC E
           JR NZ,BOOT3

           RST &08           ;'Missing disc'
           DB 55

BOOT3:     IN A,(COMM)
           LD D,A
           XOR C
           AND 2
           JR Z,BOOT2        ;LOOP UNTIL HOLE SIGNAL CHANGES

           LD C,D
           DJNZ BOOT2

           CALL REST
           LD DE,&0401       ;TRACK/SECTOR

;READ SECTOR AT TRACK D, SECTOR E

RSAD:      XOR A
           EX AF,AF'

RSA1:      LD A,E
           OUT (SECT),A

RSA2:      CALL BUSY
           IN A,(TRCK)
           CP D
           JR Z,RSA4

           LD C,STPOUT
           JR NC,RSA3

           LD C,STPIN

RSA3:      CALL SADC
           JR RSA2

RSA4:      DI
           LD C,DRSEC
           CALL SADC
           LD HL,&8000
           LD BC,DTRQ
           DB &FE            ;"JR+2" (CP EDH: AND D)

RSA5:      INI

RSA6:      IN A,(COMM)
           BIT 1,A
           JR NZ,RSA5

           RRCA
           JR C,RSA6

           EI

;CHECK DISC ERROR COUNT

           AND &0E
           JR Z,BTNOE        ;JR IF NO ERRORS

           EX AF,AF'
           INC A
           CP 5
           PUSH AF
           CALL Z,REST
           POP AF
           CP 10
           JP NC,TERROR

           EX AF,AF'
           JR RSA1

BTNOE:     LD DE,&80FF
           LD HL,BTWD
           LD B,4

BTCK:      INC DE
           LD A,(DE)
           XOR (HL)
           AND &5F           ;IGNORE MISMATCH ON BITS 7 OR 5
           JR Z,BTLY

           RST &08
           DB 53             ;'NO DOS' IF NOT 'BOOT'

BTLY:      INC HL
           DJNZ BTCK

           JP &8009          ;DOS INITIALISE

SADC:      CALL BUSY

SDCX:      LD A,C
           OUT (COMM),A
           LD B,0

SDC1:      DJNZ SDC1

           RET

;RESTORE DRIVE TO ZERO

REST:      LD C,DRES
           CALL SADC

;TEST FOR CHIP BUSY

BUSY:      IN A,(COMM)
           RRCA
           RET NC

           CALL BRKCR
           JR BUSY

;          INCLUDE PRINTFP.SAM
;PRINTFP.SAM - PRINT A NUMBER


;*******************************************************************************
;RETURN STR$ OF NUMBER ON FPCS AS BC BYTES AT (DE) IN BUFFER

PFSTRS:    LD A,6

PFSTRSC:   LD (FRACLIM),A    ;UP TO 4 LEADING ZEROS IN FRACTIONS BEFORE EFORM
           CALL PRFPBUF      ;IS USED
           LD A,(DIGITS)
           AND A
           JR NZ,PFNRND      ;JR IF LESS THAN 9 CHARS - RESULT IS EXACT
                             ;ELSE ROUND UP ON 9TH. DIGIT. (NOT A DEC. PT)
           LD HL,(NPRPOS)
           DEC HL
           LD (NPRPOS),HL    ;IGNORE 9TH. DIGIT OTHER THAN FOR ROUNDING
           LD A,(HL)
           CP "5"
           JR C,PFNRND       ;NO ROUND IF E.G. 12345678.4

PFRNDLP:   LD (HL),"0"

PFPSLP:    DEC HL
           LD A,(HL)
           CP "."
           JR Z,PFPSLP

           INC A
           CP "9"+1
           JR NC,PFRNDLP     ;JR IF OVERFLOWED - 0 THIS DIGIT AND KEEP ROUNDING
                             ;EXTREME CASE IS ROUND RIGHT BACK TO FIRST ZERO
                             ;BEFORE EXITING LOOP
           LD (HL),A

PFNRND:    LD HL,(NPRPOS)
           LD DE,PRNBUFF
           AND A
           SBC HL,DE
           LD C,L
           LD B,H
           DEC L
           RET Z             ;IF ONLY 1 CHAR, MUST BE ZERO - LEN 1, AT (DE)

           ADD HL,DE
           INC HL            ;HL=NPRPOS
           LD A,(DECPNTED)
           AND A
           JR NZ,MTRZDLP     ;DELETE TRAILING ZEROS IF DEC PT USED E.G. 1.2300

EFCHECK:   LD A,(EPOWER)
           AND A
           JR Z,PFNPNT       ;JR IF NOT EFORM - LEAVE TRAILING ZEROS

MTRZDLP:   DEC C
           DEC HL
           LD A,(HL)
           CP "0"
           JR Z,MTRZDLP      ;DELETE TRAILING ZEROS

           LD A,(HL)
           CP "."
           JR Z,EFCHECK      ;KEEP "." DELETED AND GOTO PFNPNT IF NOT EFORM
                             ;ELSE PNT IS NOT REAL - DELETE MORE ZEROS IF NEEDED

           INC C             ;ELSE "UNDELETE" LAST NON-"0"/NON-"." CHAR

PFNPNT:    LD A,(DE)
           CP "-"
           JR NZ,PFNMIN     ;SKIP A FIRST "-" IF NEEDED

           INC DE
           LD A,(DE)

PFNMIN:    CP "0"
           JR NZ,PFEXIT      ;JR IF FIRST CHAR USED IN ROUNDING
                             ;(=div by 10 if fract: 0998->999 but 0999->1000)
           LD A,(EPOWER)
           DEC A             ;0->FF
           CP &80            ;CY IF +VE, NZ EPOWER (FRACTION) (80H NOT CRITICAL)
           ADC A,1           ;A=ORIG IF 0 OR -VE, ELSE A=A+1
           CP 8
           JR Z,PFNEZ        ;JR IF FRACTION ROUNDED UP TO 1

           LD (EPOWER),A     ;CAN PUT IN AN EXTRA LEAD ZERO TO COMP FOR
                             ;"MISSED" DIV COS FIRST ZERO NOT DELETED.

PFNEZ:     DEC C             ;COMPENSATE LEN FOR LEADING ZERO TO BE LOST
           LD A,C
           LD HL,(NPRPOS)
           DEC HL
           LD (NPRPOS),HL    ;COMPENSATE NPRPOS IN CASE 9-DIGIT INTEGER LOOP
                             ;USED (SEE LATER)
           LD H,D
           LD L,E
           INC HL
           LD C,10
           LDIR              ;ALIGN TO LHS E.G. 01.23 -> 1.23
           LD C,A

PFEXIT:    LD DE,PRNBUFF
           LD A,(DIGITS)
           LD HL,DECPNTED
           OR (HL)
           LD L,A            ;L=0 IF NINE DIGIT INTEGER
           LD A,(EPOWER)
           LD H,A
           AND A
           LD A,L
           JR NZ,PFEFORM     ;JR IF EFORM (FRACTIONS ARE ALWAYS NOMINALLY EFORM)

;NOW CHECK FOR 9-DIGIT INTEGERS WHICH SHOULD BE EFORM TOO

           AND A
           RET NZ            ;RET IF NOT 9 DIGIT INTEGER

           DEC A
           LD (EPOWER),A     ;POWER FF IS CORRECT FOR E+8
           JR PFNRND         ;PRINT EFORMAT NUMBER

PFEFORM:   AND A
           JR Z,PFPOWOK      ;IF A 9-DIGIT INTEGER WAS PRODUCED
                             ;BY MULTIPLYING BY A POWER - JUMP. IF NOT, FORM
                             ;IS EG 12345678.9 OR 12345678, BECAUSE POWER
                             ;CHOSEN WAS TOO -VE (IN THE CASE OF BIG NUMBERS)
                             ;OR TOO SMALL (IN THE CASE OF SMALL NUMBERS)
                             ;IN WHICH CASE RESULT IS EFFECTIVELY 0.XE+/-H
           INC H             ;CHANGE TO X.XE+/-H

PFPOWOK:   LD A,(FRACLIM)    ;NORMALLY 6, TO ALLOW UP TO 4 LEADING ZEROS
           LD L,A
           LD A,H
           SUB 8
           JR Z,PFSPBH       ;JR IF ROUNDING MEANS *NO* LEADING ZEROS
                             ;(0.999999->1)
           CP L
           JR C,PFFRACT      ;JR WITH 1 FOR 0.1, 2 FOR 0.01,... 5 FOR 0.00001

           BIT 7,H
           JR Z,NEGEFORM

           CPL

NEGEFORM:  LD L,&2F          ;"0"-1

CALCELP:   INC L
           SUB 10
           JR NC,CALCELP

           ADD A,&3A
           PUSH AF
           EX DE,HL          ;RESULT IN EA (POWER AS ASCII)
           ADD HL,BC         ;HL=PRNBUFF, BC=LEN - GET PAST END
           LD (HL),"E"
           INC HL
           LD (HL),"+"
           BIT 7,D
           JR NZ,POWSOK

           LD (HL),"-"

POWSOK:    INC HL
           LD A,E
           CP "0"
           JR Z,POWL10

           INC C             ;LEN IS GREATER BECAUSE "E"+/- 2 DIGITS
           LD (HL),E
           INC HL

POWL10:    POP AF
           LD (HL),A
           INC C
           INC C
           INC C             ;ALLOW FOR E(SGN)1 DIGIT
           LD HL,PRNBUFF
           LD A,(HL)
           CP "-"
           JR NZ,NOMINUS2

           INC HL            ;SKIP "-"

NOMINUS2:  INC HL            ;SKIP FIRST DIGIT
           LD A,(HL)
           CP "E"

PFSPBH:    JR Z,PFSETPRB     ;END NOW IF E.G. 1E+7 - NO PT. INSERTION

           INC C             ;ALLOW FOR GREATER LEN
           LD A,1
           CALL PFSPACE      ;MAKE 1 SPACE AFTER ANY MINUS (CAN BE CONSIDERED
                             ;AS SPACE 1 AFTER THIS, AS LOCNS MATCH)
           INC HL            ;PT TO FIRST DIGIT
           INC HL            ;PT TO SPACE AFTER 1ST DIGIT
           LD (HL),"."
           JR PFSETPRB

;PRINT FRACTION - INSERT LEADING 0./0.0/0.00 ETC.

PFFRACT:   INC A
           CP 20             ;LIMIT TO 17 LEADING ZEROS (FOR PRINT USING)
           JR C,PFFRACT2

           LD A,19

PFFRACT2:  LD B,A            ;B=2-6, C=LEN
                             ;2=0.1, 8=0.0000001
           CALL PFSPACE
           INC HL            ;PT TO SPACE
           LD A,C
           ADD A,B
           CP 22
           JR C,PFFRACT3

           LD A,21

PFFRACT3:  LD C,A            ;NEW LEN (MAX=21)
           LD (HL),"0"
           LD A,"."          ;DECIMAL PT. ON FIRST LOOP ONLY
           JR FRACLPEN

FRACLZLP:  LD (HL),A
           LD A,"0"

FRACLPEN:  INC HL
           DJNZ FRACLZLP

PFSETPRB:  LD DE,PRNBUFF     ;BC=LEN
           RET

;ENTRY:    A=SPACE TO OPEN AFTER ANY MINUS SIGN IN PRNBUFF. (1-19D BYTES)
;EXIT: HL=BEFORE SPACE. BC SAVED

PFSPACE:   PUSH BC
           LD H,&FF
           NEG
           LD L,A            ;HL=-SPACE
           PUSH HL
           LD BC,21          ;BUFF LEN (ACTUALLY, OVERLAPS BCD BUFF, BUT OK)
           ADD HL,BC         ;MAX TO MOVE IS 15; LESS IF BIGGER GAP WANTED
                             ;MIN IS 1
           LD B,H
           LD C,L
           POP HL
           LD A,(PRNBUFF)
           CP "-"
           JR NZ,PFSKMIN

           DEC C             ;1 LESS IF LEADING MINUS - LEAVE IT ALONE

PFSKMIN:   LD DE,PRNBUFF+20  ;DEST=END OF BUFFER
           ADD HL,DE         ;SRC IS SOME BYTES BEFORE
           LDDR
           POP BC
           RET

;*******************************************************************************
;PRFPBUF - "PRINT" A NUMBER (ON FPCS) TO PRNBUFF IN "RAW" STATE. (NO ROUNDING
;OR LEADING ZEROS, NO E+/-, ETC.)
;EXIT: (9-DIGITS)=SIGNIF DIGS IN PRNBUFF. EPOWER=POWER OF 10 USED IF EFORM
;NO DECIMAL PT IF EFORM.
;LEADING MINUS IF -VE, ALWAYS 1 LEADING ZERO.
;E.G. -0.123 OR 01234.5  OR 01.2345

PRFPBUF:   LD HL,DIGITS
           LD (HL),10        ;DIGITS ALLOWED
           INC HL
           XOR A
           LD (HL),A         ;POWER=0 "NOT EFORMAT"
           INC HL
           LD (HL),A         ;"NO DECIMAL PT USED YET"
           INC HL
           LD (NPRPOS),HL    ;PRINT POSN=BUFFER START

           DB CALC
           DB RESTACK
           DB DROP
           DB EXIT           ;DE=DROPPED NUMBER

           LD HL,5
           ADD HL,DE

           EX DE,HL          ;HL=NUMBER, DE=OLD STKEND
           INC HL
           BIT 7,(HL)        ;NZ IF -VE
           DEC HL

           LD A,"-"
           CALL NZ,NPRINT    ;MINUS PRINTED BEFORE -VE NUMBERS
           CALL NPRZERO      ;LEADING ZERO IS USEFUL FOR ROUNDING UP LATER
           LD A,(HL)
           AND A
           RET Z             ;EXIT WITH "0" IF ZERO

           CP &81
           JR C,PRBORS       ;JR IF NO BITS BEFORE BINARY POINT (<1)

           SUB &80           ;=BITS BEFORE BINARY POINT (1-7F)
           CP 30
           JR NC,PRBORS      ;IF MORE THAN 29 BITS - MIGHT NOT FIT IN 9 DIG. BCD

PRMEDN:    INC HL
           LD D,(HL)
           SET 7,D           ;TRUE NUMERIC BIT
           INC HL
           LD E,(HL)
           INC HL
           PUSH DE
           EXX
           POP HL            ;MSW TO HL"
           EXX
           LD D,(HL)
           INC HL
           LD E,(HL)
           EX DE,HL          ;LSW TO HL
           CALL DECIMIZE     ;CONVERT "A" BITS OF HL"HL TO BCD
           EX DE,HL          ;PROTECT LSW
           CALL PRBCD        ;PRINT BCD TO PRINT BUFFER
           EX DE,HL
           RET C             ;RET IF BUFFER FULL

           LD A,H
           OR L
           EXX
           OR H
           OR L
           RET Z             ;RET IF NO SIGNIF BITS LEFT

;BITS REMAINING IN HL"HL ARE THE BITS AFTER THE BINARY POINT, EXP 80H FORM
;EXCEPT THERE MAY BE LEADING ZERO BITS.
;NOW PRINT HL"HL BY MULTIPLYING REPEATEDLY BY 10 TILL BUFFER FULL


PRFRACT:   CALL NPRPNT       ;"."
           EX DE,HL
           EXX
           EX DE,HL          ;TRANSFER NUMBER TO DE"DE

PRFRLP:    XOR A             ;START WITH CARRY OF ZERO
           CALL TENX         ;LE=DE*10+A
           LD D,L            ;DE=DE*10. A=CY
           EXX
           CALL TENX         ;LE=DE*10+A
           LD D,L            ;DE=DE*10. A=CY
           EXX
           CALL NPRINTC
           JR NC,PRFRLP      ;LOOP UNTIL BUFFER FULL

           RET

;LE=DE*10+A. CY IN A

TENX:      LD C,E
           CALL TENMUL
           LD E,L
           LD C,D

;HL=C*10+A.

TENMUL:    LD L,C
           LD H,0
           LD B,H
           ADD HL,HL
           ADD HL,HL
           ADD HL,BC         ;*5
           ADD HL,HL         ;*10
           LD C,A
           ADD HL,BC
           LD A,H            ;A=CARRY FOR NEXT TIME, L=RESULT
           RET

;NUMBERS LESS THAN 1 HAVE EXPONENTS OF 1-80H. EXP 80H MEANS THAT THERE ARE
;NO ZERO BITS AFTER THE BINARY POINT, EXP 71H MEANS THERE ARE 15 BITS, ETC.

PRBORS:    LD (STKEND),DE    ;PUT NUMBER BACK ON FPCS
           JR NC,PRBIGN      ;JR IF BIG

           CALL DECDIGN      ;GET MAX LEADING ZEROS (DECIMAL). 0 OR MORE
           ADD A,9           ;GET AN INTEGER OF 8 OR 9 DIGITS
           JR SHIFTDEC


;NUMBER WITH EXP 9E-FFH (NOW 1E-7FH) - AT LEAST 9 DEC DIGITS

PRBIGN:    CALL DECDIGP      ;FIND MAX DIGITS BEFORE DEC PT, -1. (9 OR MORE)
           SUB 9             ;0 OR MORE.
           CPL               ;-1 OR LESS. GET AN INTEGER OF 8 OR 9 DIGITS

SHIFTDEC:  DEC A
           LD (EPOWER),A     ;..FE=E+9,FF=E+8. GAP=0. 9=E-1,10=E-2...
           INC A
           CALL POFTEN       ;GET N1**A (SIGNED). EXIT WITH RESULT ON FPCS

           CALL FDELETE
           LD A,(HL)         ;A=EXP OF DELETED RESULT
           SUB &80
           JP PRMEDN         ;HL PTS TO DROPPED NUMBER (NOW LARGE INTEGER)

NPRPNT:    LD A,"."
           LD (DECPNTED),A   ;SHOW NON-INTEGER
           JR NPRINT

NPRZERO:   XOR A

;PRINT "A" AND DEC "DIGITS TO COME". CY IF BUFFER FULL (CHAR STILL ENTERED, THO)

NPRINTC:   ADD A,&30
           PUSH HL
           LD HL,DIGITS
           DEC (HL)
           JR NZ,NPRINT2     ;JR IF SPACE OK

           SCF               ;CY=BUFFER FULL
           DB &21            ;"JR+2"

;THIS ENTRY FOR CHARS THAT DON"T COUNT - LIKE "-" AND "."

NPRINT:    PUSH HL

NPRINT2:   AND A             ;NC

NPRINT3:   LD HL,(NPRPOS)
           LD (HL),A
           INC HL
           LD (NPRPOS),HL
           POP HL
           RET

;FIND HOW MANY DECIMAL DIGITS-1 THERE ARE IN A POWER OF TWO (MAXIMUM)
;ENTRY WITH A=POWER OF 2 (-VE IF ENTRY AT DECDIGN)
;EXIT WITH A=DECIMAL DIGITS BEFORE POINT-1 IF DECDIGP OR ZEROS AFTER
;PT. IF DECDIGN

DECDIGN:   LD C,A
           LD A,&80
           SUB C             ;1-80H->7F-00H

DECDIGP:   CALL STACKA

           DB CALC
           DB FIVELIT
           DB &7F,&1A,&20
           DB &9A,&85        ;0.30103
           DB MULT
           DB TRUNC
           DB DROP
           DB EXIT

           INC DE
           INC DE
           LD A,(DE)
           RET

;CONVERT A BITS IN HL"HL TO ASCI IN PRNBUFF. RESULT MAY HAVE UP TO 10 BCD DIGITS

DECIMIZE:  LD C,A

           XOR A
           LD B,5
           LD DE,BCDBUFF     ;ZERO 5-BYTE BCD BUFFER.

ZBCDBLP:   LD (DE),A
           INC DE
           DJNZ ZBCDBLP

DECIMCLP:  ADD HL,HL
           EXX
           ADC HL,HL
           EXX               ;SHIFT LEFT BITS IN HL"HL, TO CY

           LD DE,BCDBUFF+4   ;PT TO RHS BYTE IN BCD BUFFER
           LD B,5

DECIMBLP:  LD A,(DE)
           ADC A,A           ;FOR FIRST BYTE, ADD IN CY FROM HL"HL SHIFT
                             ;FOR LATER BYTES, ADD IN CY FROM PREVIOUS DAA
           DAA
           LD (DE),A
           DEC DE
           DJNZ DECIMBLP

           DEC C
           JR NZ,DECIMCLP    ;SHIFT C BITS

           RET

;PRINT CONTENTS OF 10-DIGIT BCD BUFFER TO PRINT BUFFER AS ASCII.
;EXITS IF ALL BCD DIGITS USED (NC), OR, IF PRINT BUFFER IS PART-FILLED ON ENTRY,
;WHEN DIGIT COUNT REACHES 00 (CY)
;USES HL,BC,AF

PRBCD:     LD C,1            ;NZ C SIGNALS "LEADING ZEROS - IGNORE"
           LD A,&0F          ;CLEAR LHS OF A, AND MARK RHS WITH NON-BCD DIGIT

BCDDIG:    LD B,5            ;BCD ROTATE OF 5 BYTES
           LD HL,BCDBUFF+4

BCDROTL:   RLD               ;RHS NIBBLE OF (HL) TO A, LHS NIBBLE TO RHS,
                             ;RHS NIBBLE OF A TO RHS OF (HL)
           DEC HL
           DJNZ BCDROTL

           JR NZ,PRDIGIT     ;JR IF LAST RLD GAVE A REG A NZ DIGIT

           OR C              ;NZ IF "LEADING ZERO" STATUS
           JR NZ,BCDDIG      ;IGNORE ANY. ELSE A=0 FOR NON-LEADING ZERO

PRDIGIT:   LD C,B            ;C=0 - NO LEADING ZEROS NOW
           AND &0F
           CP &0A
           RET NC            ;RET IF TERMINATOR HIT

           CALL NPRINTC
           JR NC,BCDDIG       ;LOOP UNTIL DIGIT COUNT SHOWS FULL

           RET

;POWER-OF-TEN. MULT. TOP OF FPCS BY 10**"A" REG. WORKS WITH -VE POWERS (A>80H)

POFTEN:    LD C,A            ;BIT 7, C=1 IF -VE POWER
           BIT 7,C
           JR Z,POF10L1

           NEG

POF10L1:   LD B,A            ;B=ABSOLUTE POWER (CORRUPTS!) BC IS SAVED BY SAM
                             ;FPCS
           DB CALC
           DB STKTEN         ;N1,10 (CURRENT POWER. CALL IT P)
           DB EXIT

           JR POF10LPE       ;JUMP INTO THE LOOP

POF10LP:   DB CALC
           DB DUP            ;N1*P,P,P
           DB MULT           ;N1*P,P*P. DOUBLE POWER (WE ARE MOVING MORE SIGNIF
                             ;BITS RIGHT IN B)
           DB EXIT

POF10LPE:  SRL B
           JR NC,POF10L3     ;JR IF NO MULT/DIV ON THIS BIT

           BIT 7,C
           JR NZ,POF10L2     ;JR IF -VE POWER - USE DIV

           DB CALC
           DB STO0           ;N1,P
           DB MULT           ;N1*P
           DB RCL0           ;N1*P,P
           DB EXIT

           JR POF10L3

POF10L2:   DB CALC
           DB STO0           ;N1,P
           DB DIVN           ;N1/P
           DB RCL0           ;N1/P,P
           DB EXIT

POF10L3:   INC B
           DJNZ POF10LP      ;JUMP IF B NOT SHIFTED TO ZERO YET

           LD (STKEND),HL    ;HL PTS TO LAST VALUE (HL IS SET BY "EXIT")
           RET               ;DELETE LAST POWER, LEAVE N1**A ON FPCS


;          INCLUDE TPRINT.SAM
;TPRINT.SAM - PRINT ASCII AND CR.

PROM1:     CP &20
           JP C,PRCRLCDS

           CP &80
           JP NC,PRGR80

PRASCII:   LD DE,(CHARS)
           LD HL,FLAGS
           SET 0,(HL)        ;'SPACE WAS LAST CHAR'
           CP &20
           JR Z,PRINTMN1

           RES 0,(HL)        ;'LAST CHAR WAS NOT SPACE'

PRINTMN1:  LD L,A
           LD H,0
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL
           ADD HL,DE         ;HL PTS TO CHAR DATA

IOPENT:    LD (OPCHAR),A     ;USED BY LPRINT
           LD B,A

;FROM POUDGS, AND AFTER CR

NLENTRY:   CALL POFETCH      ;GET DE=COL/ROW, A=RHS LIMIT
           CP E              ;CURRENT COL
           JR NC,PRNONWLN    ;JR IF COL=LESS THAN OR EQUAL TO RHS LIMIT

           DEC E
           SUB E             ;Z IF JUST 1 PAST RHS LIMIT - LINE FULL; ELSE CR
           LD C,A            ;WAS USED JUST BEFORE
           PUSH BC
           LD E,&FF          ;COL FF SHOWS 'RECURSIVE' CR
           LD A,(DEVICE)
           ADD A,&FE         ;CY IF PRINTER
           PUSH HL
           CALL PRENTER
           POP HL            ;GET CHAR PATTERN BACK
           POP BC            ;B=CHAR CODE
           LD A,(INDOPFG)
           AND A
           JR Z,NLENTRY      ;JR IF NO INDENT O/P WANTED - NOT LISTING.

           LD A,C
           AND A
           JR NZ,NLENTRY

           PUSH BC
           CALL INDOPEN        ;O/P SPACES IF POSN WAS JUST 1 PAST RHS LIMIT -
           POP AF              ;LINE WAS FULL. ELSE CR WAS USED.
           RST &10
           RET

PRNONWLN:  PUSH DE           ;CURRENT PRINT POSN
           LD A,(OVERT)      ;0-3
           CP 1              ;0->CY
           SBC A,A           ;0->FF
           CPL               ;0->00, 1,2,3->FF
           LD B,A
           LD A,(INVERT)     ;0=INVERSE 0, FF=INVERSE 1
           LD C,A
           LD IX,(PATOUT)    ;USUALLY=ENDOUTP
           CALL IXJUMP
           POP HL            ;POSN
           INC L             ;MOVE RIGHT

POSTORE:   LD A,(DEVICE)     ;0=UPPER SCREEN, 1=LOWER, 2=PRINTER OR OTHER
           AND A
           JR Z,POSUSCRN

           DEC A
           JR Z,POSLSCRN

           LD (PRPOSN),HL    ;L=PRINTER COL
           RET

POSLSCRN:  LD (SPOSNL),HL
           RET

POSUSCRN:  LD (SPOSNU),HL
           RET

ENDOUTP:   LD A,(DMPFG)
           AND A
           RET NZ

           LD A,(DEVICE)
           CP 2
           JR Z,ENDOP2       ;JR IF PRINTER

           LD A,(CSIZE)
           CP 16
           JP C,EPSUB        ;JR IF NOT DOUBLE HEIGHT

           CALL DBCHAR       ;EXITS WITH HL PTING TO DOUBLE HEIGHT CHAR MATRIX
           PUSH BC
           PUSH DE
           CALL EPSUB        ;PRINT TOP HALF
           LD A,8
           LD (DHADJ),A      ;ADJUST ADDRESSES TO PRINT 8 SCANS LOWER
           POP DE
           POP BC
           LD HL,MEMVAL+16   ;PTR TO BOTTOM HALF
           CALL EPSUB
           XOR A
           LD (DHADJ),A
           RET

ENDOP2:    LD A,(OPCHAR)
           JP CHBOP          ;SEND CHAR ON 'B' CHANNEL

;*******************************************************************************

PRGR80:    LD C,A
           LD A,(INQUFG)     ;BIT 0=1 IF IN QUOTES
           RRCA
           LD H,A
           LD A,(FLAGX)      ;BIT 7=1 IF INPUT LINE
           OR H
           RLA
           JR C,POUDGH       ;JR IF IN QUOTES, OR INPUT LINE - PRINT UDGS,
                             ;NOT TOKENS
           LD A,C
           CP &85

POUDGH:    JP C,POUDG        ;80-84H ARE ALWAYS UDGS

;USED BY CHANNEL 'R'

PRGR802:   LD HL,(PRTOKV)
           CALL JPOPT

           INC A
           JP Z,POFN         ;JP IF FF FN LEADER

           SUB &86           ;(PLUS 1 TO COMPENSATE FOR INC)
           LD DE,KWDS85      ;SPLIT CMDS LIST INTO 4 SUB-LISTS FOR SPEED
           CP &1B
           JR C,POBTL        ;85-9FH

           SUB &1B
           LD H,&20
           LD DE,KWDSA0      ;A0-BF
           CP H
           JR C,POBTL

           SUB H
           LD DE,KWDSC0      ;C0-DF
           CP H
           JR C,POBTL

           SUB H
           LD DE,KWDSE0      ;E0-FE
           JR POBTL

;*******************************************************************************
;ROUTINES FOR PRINTING ERROR MSGS, CMDS, FNS, MSGS

POFN:      LD DE,POSTFF
           JP SVSETOP        ;SAVE CURRENT O/P ADDR AND SET O/P ADDR TO DE

PSTFF2:    CALL RESTOP       ;RESTORE O/P ADDR. A= CHAR PRINTED AFTER FF
           SUB PITOK
           CP SINTOK-PITOK
           JR C,POIMFN       ;JR IF IMMEDIATE FN

           SUB MODTOK-PITOK
           JR C,POFPCFN      ;JR IF FPC FN

           LD DE,BINFNTL     ;BINARY FN TOKEN LIST
           CP ANDTOK-MODTOK+1
           JR C,POBTL        ;MOD-AND (BIN OPS) HAVE LEADING AND TRAILING SPACE

           JR POMSP2         ;<>, >=, <= HAVE NO SPACES


POIMFN:    LD DE,IMFNTL      ;IMMEDIATE FN TOKEN LIST
           CP FNTOK-PITOK
           JR Z,POTRNL

           CP BINTOK-PITOK
           JR Z,POTRNL       ;FN AND BIN HAVE TRAILING BUT NO LEADING SPACES

           JR POMSP2         ;REST HAVE NEITHER

POFPCFN:   ADD A,MODTOK-SINTOK
           LD DE,FPCFNTL     ;FPC FN TOKEN LIST

POTRNL:    AND A
           PUSH AF           ;TRAILING SPACE
           SCF               ;NO LEADING SPACE
           JR POGEN1

POMSPX:    SCF
           PUSH AF
           PUSH AF
           LD HL,MSGBUFF+11
           CALL POMSR2
           JR POGEN2

POMSP2:    SCF               ;NO LEADING OR TRAILING SPACES
           DB &26            ;"JR+1". FOR MSGS OR E.G. PI/ITEM/POINT

POBTL:     AND A             ;BOTH TRAILING AND LEADING SPACES

POGEN:     PUSH AF           ;TRAILING STATUS

POGEN1:    PUSH AF           ;LEADING  STATUS
           CALL POMSR        ;GET MSG TO BUFFER

POGEN2:    POP AF            ;LEADING STATUS
           JR C,POMSG3       ;NO LEADING SPACE FOR MSG OR FNS (EXCEPT AND/OR)

           LD A,(FLAGS)
           RRA
           LD A," "
           CALL NC,&0010     ;PRINT LEADING SPACE IF PREVIOUS CHAR WASN'T ONE

POMSG3:    CALL PRINTSTR     ;OUTPUT BC FROM (DE)
           POP AF
           RET C             ;RET IF NO TRAILING SPACE WANTED

           DEC DE
           LD A,(DE)         ;LAST CHAR
           CP "A"
           JR NC,POMSG4      ;JR IF LETTER - DO TRAILING SPACE

           CP "$"
           RET NZ            ;'$' IS ALSO FOLLOWED BY A SPACE, BUT NOT =/>/#

POMSG4:    LD A," "
           RST &10
           RET

;A=MSG NUMBER 00->, DE=START OF MSG LIST

POMSR:     LD HL,MSGBUFF

POMSR2:    PUSH HL           ;BUFFER START
           CALL POMSR3
           POP DE            ;BUFFER ST
           AND A
           SBC HL,DE
           LD B,H
           LD C,L            ;LEN
           RET

POMSR3:    LD B,A
           INC B
           JR POMSR4

LKHIBTLP:  LD A,(DE)         ;WITH ABOUT 4 CHARS/TOKEN, TAKES ABOUT 0.7 MS
           INC DE            ;(ON SAM) TO FIND 30TH WORD.
           RLA
           JR NC,LKHIBTLP

POMSR4:    DJNZ LKHIBTLP

MVWORDLP:  LD A,(DE)
           AND &7F
           CP &20
           JR NC,MVWORD2     ;JR WITH ALL EXCEPT COMPRESSION CODES 00-1F

           PUSH DE           ;SAVE MAIN MSG PTR
           LD DE,COMPLIST    ;LIST OF COMPRESSION CODED WORDS
           CALL POMSR3       ;RECURSIVE CALL
           POP DE            ;MAIN MSG PTR
           DB &01            ;'JR+2'

MVWORD2:   LD (HL),A
           INC HL

MVWORD3:   LD A,(DE)
           INC DE
           RLA
           JR NC,MVWORDLP    ;MAIN MSG CAN HAVE COMP CODES AND ASCII. BIT 7 IS
                             ;HI IN LAST CHAR. COMPRESSED WORD CANNOT HAVE COMP
                             ;CODES.
           RET


;*******************************************************************************

POUDG:     LD A,(DEVICE)
           CP 2
           JR NZ,PUDGS       ;JR IF NOT PRINTER

           LD A,C
           LD (OPCHAR),A     ;USED BY LPRINT
           LD HL,(LPRTV)
           CALL JPOPT

PUDGS:     LD A,(BGFLG)      ;BLOCK GRAPHICS FLAG
           AND A
           LD A,C
           JR NZ,POFUDG      ;JR IF FOREIGN SET/UDGS WANTED, NOT BLOCKS

           CP &90
           JR NC,POFUDG      ;>=90H ARE FOREIGN/UDGS ANYWAY

           CALL QUADBITS     ;GET LOWER 4 BITS OF A INTO DE, QUADRUPLED
           LD HL,MEMVAL
           PUSH HL
           LD B,4

BKGRL1:    LD (HL),E
           INC HL
           DJNZ BKGRL1

           LD B,4

BKGRL2:    LD (HL),D
           INC HL
           DJNZ BKGRL2

           POP HL
           LD B,C
           JP NLENTRY

POFUDG:    LD HL,(HUDG)      ;HI UDG FOR CHARS. >A8H
           SUB &A9
           JR NC,POUDG1      ;JR IF HI UDG

           LD A,C
           LD DE,&FB80       ;COMP. FOR A BEING 80H-A8H AND UDG VAR PTING
           LD HL,(UDG)       ;TO CHR$ 144
           ADD HL,DE

POUDG1:    EX DE,HL
           JP PRINTMN1

;PRINT CONTROL CODES
;*******************************************************************************
;ENTRY: JR FROM MAIN PRINT ROUTINE. A=00-1FH

PRCRLCDS:  CP 24
           JR NC,PRQUERY

           CP 6
           JR C,PRQUERY

           LD E,A
           LD D,0
           LD HL,CCPTB-6       ;CONTROL CODE PTR TABLE
           ADD HL,DE
           LD E,(HL)
           ADD HL,DE
           LD C,A
           CALL POFETCH      ;D=ROW, E=COL, A=RHS MAX, CY IF LPRINTING
           JP (HL)

CCPTB:

;           DB PRQUERY-CCPT      ;0
 ;          DB PRQUERY-CCPT-1    ;1
  ;         DB PRQUERY-CCPT-2    ;2
   ;        DB PRQUERY-CCPT-3    ;3  CLS?
    ;       DB PRQUERY-CCPT-4    ;4
     ;      DB PRQUERY-CCPT-5    ;5
           DB PRCOMMA-CCPTB      ;6  PRINT COMMA
           DB PRQUERY-CCPTB-1    ;7  (EDIT)
           DB CURLF-CCPTB-2      ;8  CURSOR LEFT
           DB CURRT-CCPTB-3      ;9  CURSOR RIGHT
           DB CURDN-CCPTB-4      ;10 CURSOR DOWN
           DB CURUP-CCPTB-5      ;11 CURSOR UP
           DB PRDELL-CCPTB-6     ;12 DELETE LEFT
           DB PRENTER-CCPTB-7    ;13 ENTER
           DB PRDELR-CCPTB-8     ;14 DELETE RIGHT
           DB PRQUERY-CCPTB-9    ;15
           DB CC1OP-CCPTB-10     ;16 INK
           DB CC1OP-CCPTB-11     ;17 PAPER
           DB CC1OP-CCPTB-12     ;18 FLASH
           DB CC1OP-CCPTB-13     ;19 BRIGHT
           DB CC1OP-CCPTB-14     ;20 INVERSE
           DB CC1OP-CCPTB-15     ;21 OVER
           DB CC2OPS-CCPTB-16    ;22 AT
           DB CC2OPS-CCPTB-17    ;23 TAB

;*******************************************************************************
;D=LINE, E=COL

PRCOMMA:   LD A,E            ;COL
           LD HL,WINDLHS
           SUB (HL)          ;A=DIST FROM WIND LHS
           PUSH AF
           LD A,(TABVAR)
           AND A
           LD BC,&F010       ;FOR 16-COLUMN TAB
           JR Z,PCOM2

           LD BC,&F808       ;FOR 8-COLUMN TAB

PCOM2:     LD A,(WINDRHS)
           CP E
           JR C,PC25         ;JR IF LINE FULL

           POP AF
           AND B             ;GET DIST DIV 16 OR DIV 8
           ADD A,C           ;ADD 16 OR 8
           ADD A,(HL)        ;ABS DESIRED COLUMN
           DEC HL            ;PT TO RHS
           CP (HL)
           JR C,PCOM3        ;JR IF NEW POSN WOULD NOT REACH RHS MAX

           LD A,(HL)
           INC A

PCOM3:     SUB E

OPAORZ:    RET Z

OPASPACES: LD B,A

OPSPLP:    LD A," "
           RST &10
           DJNZ OPSPLP

           RET

PC25:      POP AF
           LD B,C
           JR OPSPLP


PRQUERY:   LD A,"?"
           RST &10
           RET

;*******************************************************************************
;CURSOR LEFT/UP/RIGHT

CURLF:     LD A,(WINDLHS)
           CP E
           LD A,(WINDRHS)
           JR Z,CURLF2       ;JR IF AT LHS OF WINDOW

           DEC E             ;DEC COL.
           CP E
           JR NC,POSTOREH    ;JR IF NOT PAST RHS ('LINE FULL')

           LD E,A            ;ELSE COL=RHS

POSTOREH:  EX DE,HL
           JP POSTORE


CURLF2:    LD E,A            ;COL=RHS
           LD A,(DEVICE)
           ADD A,&FE         ;CY IF PRINTER (DEVICE 2)

CURUP:     JR C,PRQUERY      ;PRINT '?' IF LPRINTING - POSN UNCHANGED

           LD A,(WINDTOP)
           CP D
           RET Z             ;RET IF WE ARE AT TOP OF WINDOW

           DEC D             ;UP A ROW. C=RHS+1
           JR POSTOREH


CURRT:     LD HL,(OVERT)     ;OVERT/INVERT
           PUSH HL
           LD A,(M23PAPT)
           PUSH AF
           LD HL,&0001       ;OVER 1;INVERSE 0
           LD B,1
           JR SPOX

;DELETE LEFT

PRDELL:    JR C,PRQUERY      ;JR IF LPRINTING

           LD A,8
           RST &10           ;BACKSPACE
           CALL SPO0         ;PRINT OVER 0;' ';
           LD A,8            ;BACKSPACE
           RST &10
           RET

;ERASE OLD CURSOR, GET H=TABLE MSB, GET C=LNPTR

EROC2:     LD A,(WINDTOP)    ;ALLOW FOR WINDOW
           LD C,A
           LD A,(LNPTR)
           SUB C
           JR NC,EROC3

           XOR A

EROC3:     LD C,A
           LD E,5
           CALL ATSR2        ;PRINT AT A,5;
           CALL SPO0         ;ERASE OLD CURSOR
           LD A,C
           LD H,LPT/256
           RET

;DELETE RIGHT=SPACE (OVER 0)

PRDELR:

;PRINT OVER 0;INVERSE 0;" "; (IN PERMANENT PAPER IF MODES 2 AND 3)

SPO0:      LD B,1            ;1 SPACE

;O/P B SPACES (OVER 0;INVERSE 0)

OPBSP:     LD HL,(OVERT)     ;OVERT/INVERT
           PUSH HL
           LD A,(M23PAPT)
           PUSH AF
           LD A,(M23PAPP)
           LD (M23PAPT),A    ;PERM PAPER
           LD HL,&0000       ;OVER 0, INVERSE 0

SPOX:      LD (OVERT),HL

OPSL:      LD A,&20
           RST &10           ;PRINT SPACE
           DJNZ OPSL

           POP AF
           LD (M23PAPT),A
           POP HL
           LD (OVERT),HL
           RET

CURDN:     PUSH DE           ;SAVE COL.
           LD E,&FE          ;FORCE ACTUAL MOVE DOWN
           CALL PRENTER      ;EXIT WITH HL=POSN
           POP DE
           LD L,E            ;UNCHANGED COL.
           JR PRENT5

PRENTER:   JR C,LPRENT       ;JR IF LPRINT

           LD A,E            ;COL
           CP &FE
           JR C,PRENT3       ;IF PREVIOUS CHAR WAS NOT CR, JUST SET COL 0FEH.
                             ;('LINE FULL') ELSE DROP DOWN A LINE
           LD A,(WINDBOT)
           CP D
           JR NZ,PRENT2      ;JR IF NOT ON BOTTOM LINE ALREADY

           PUSH DE
           CALL SCRLSCR      ;SCROLL WINDOW UP
           POP DE
           DEC D             ;LINE VALUE WILL END AS BOTTOM LINE STILL

PRENT2:    INC D             ;DOWN A LINE
           INC E             ;Z IF COL WAS FF (RECURSIVE)
           LD A,(WINDLHS)
           JR Z,PRENT4       ;JR IF WAS RECURSIVE CR FROM 'LINE FULL' - LHS COL
                             ;FOR CHAR COMING NEXT

PRENT3:    LD A,&FE          ;'LINE FULL, NOT RECURSIVE'

PRENT4:    LD E,A
           EX DE,HL

PRENT5:    JP POSTORE

LPRENT:    LD A,&0D
           CALL CHBOP        ;O/P CR ON CHANNEL 'B'
           XOR A
           LD (PRPOSN),A
           LD A,(AFTERCR)
           AND A
           RET Z
                             ;ELSE LPRINT LF IF (AFTERCR)= 0AH
CHBOP:     LD HL,(CHANS)
           LD DE,25
           ADD HL,DE         ;PT TO CHANNEL B
           JP HLJPI
;           LD E,(HL)
 ;          INC HL
  ;         LD D,(HL)
   ;        EX DE,HL          ;HL=O/P ADDR (USUALLY 'SENDA')
    ;       JP (HL)

;CONTROL CODES WITH OPERANDS
;ONE OPERAND - INK, PAPER, OVER, INVERSE, BRIGHT, FLASH

CC1OP:     LD DE,CCRESTOP
           JR SETADCOM

;TWO OPERANDS - TAB OR 'AT' (TAB JUNKS THE SECOND OPERAND!)

CC2OPS:    LD DE,PRERESTOP

SETADCOM:  CALL SVSETOP
           LD A,C            ;CONTROL CODE
           LD (TVDATA),A
           RET

;SAVE CURRENT O/P ADDR AND SET IT TO DE

SVSETOP:   PUSH DE
           CALL SVCUROP
           POP DE
           JP POCHNG

CCRP2:     LD HL,(TVDATA)    ;H=1ST OPERAND (IF 2),L=CONTROL CODE

           LD D,A            ;LAST OPERAND (ONLY OPERAND IF 1, ELSE 2ND)
           LD A,L            ;CONTROL CODE
           CP &16
           JP C,PRCOITEM

           JR Z,POATCC       ;JR IF 'AT'

;DEAL WITH TAB. H=ONLY RELEVANT OPERAND (FIRST - COLUMN)

           CALL POFETCH      ;D=ROW, E=COL, A=RHS MAX, CY IF LPRINTING
           LD C,A
           CP E
           LD A,H            ;PARAM
           JR C,TAB2         ;JR IF LINE FULL

           LD A,(WINDLHS)
           ADD A,H           ;ABS TAB POSN
           SUB E             ;FIND SPACES REQUIRED TO REACH TAB POSN.
           RET Z

           JR NC,TAB2        ;JR IF NOT ALREADY PAST TAB POSN

           LD A,H            ;CALCULATE SPACES NEEDED TO FILL LINE
           ADC A,C           ;AND REACH TAB POSN.
           SUB E

TAB2:      AND A
           JP OPAORZ

;*******************************************************************************
;'AT' ROUTINE

POATCC:    EX DE,HL
           LD E,H            ;D=1ST OPERAND (ROW), E=2ND (COLUMN)
           LD HL,WINDLHS
           LD A,(HL)
           ADD A,E           ;ADD COL
           LD E,A            ;ABS SCREEN COL
           DEC HL
           LD A,(HL)         ;WINDRHS
           CP E
           JR C,PATER        ;ERROR IF TOO FAR RIGHT

           INC HL            ;WINDLHS
           INC HL            ;WINDTOP
           LD A,(HL)
           ADD A,D           ;ABS SCREEN ROW
           LD D,A
           INC HL
           LD A,(HL)         ;WINDBOT
           SUB D
           JR NC,POSTORH     ;JR IF 'AT' NOT OFF BOTTOM

           NEG
           LD B,A            ;NUMBER OF EXTRA ROWS NEEDED IN LS
           LD A,(DEVICE)
           AND A
           JR Z,PATER        ;ERROR IF UPPER SCREEN, BUT LS CAN INCREASE SIZE

           LD D,(HL)
           PUSH DE           ;D=WINDBOT, E=ABS 'AT' COLUMN

SLSLP:     PUSH BC
           CALL SCRLS
           POP BC
           DJNZ SLSLP        ;SCROLL LS UP 'B' TIMES TILL POSN IS ON RIGHT ROW
                             ;(I.E. ADD ROWS TO TOP OF LOWER SCREEN)
           POP DE

POSTORH:   EX DE,HL
           JP POSTORE

PATER:     RST &08
           DB 32             ;'OFF SCREEN'

;SAVE CURRENT O/P ADDR

SVCUROP:   LD HL,(CURCHL)
           LD E,(HL)
           INC HL
           LD D,(HL)
           LD (OPSTORE),DE
           RET

;SCROLL SCREEN

SCRLSCR:   LD A,(TVFLAG)
           AND &10
           JR Z,SCRLSCR2     ;JR IF NOT AUTO-LIST

           LD A,(BCREG)
           DEC A
           JR NZ,DOSCRL      ;JR IF CURRENT LINE NOT PRINTED YET

           CALL SETSTRM      ;(STREAM ZERO)
           LD SP,(LISTSP)    ;CLEAR STACK
           JP AULX           ;JP TO SET 'AUTOLIST FINISHED'

SCRLSCR2:  LD A,(DEVICE)
           DEC A
           JR Z,SCRLS        ;JR IF USING LOWER SCREEN

           CALL BRKCR
           LD A,(SPROMPT)
           AND A
           JR NZ,DOSCRL      ;JR IF PROMPS TURNED OFF

           LD HL,SCRCT
           DEC (HL)
           JR NZ,DOSCRL      ;JR IF NOT TIME FOR PROMPP YET

           CALL SETSCRCT
           CALL SVTEMPS      ;SAVE TEMPORARY ATTRIBUTES ETC
           LD HL,(CURCHL)
           PUSH HL           ;PROBABLY CHANNEL 'S'
           EXX
           PUSH DE
           LD A,1            ;'Scroll?'
           CALL WTBRK
           POP DE
           EXX
           CP " "
           JR Z,BRCH

           AND &DF
           CP "N"

BRCH:      CALL Z,IOPOF      ;INDENT O/P OFF. EXIT WITH Z
           JP Z,BRCERR

           POP HL
           LD (CURCHL),HL
           CALL CHANFLAG
           CALL RSTTEMPS     ;RESTORE TEMPORARY ATTRIBUTES
           CALL COLEX

DOSCRL:    JP EDRS1UP

SETSCRCT:  LD HL,(WINDTOP)
           LD A,H
           SUB L
           INC A             ;A=WINDOW HEIGHT
           LD (SCRCT),A
           RET


;SCROLL LOWER SCREEN. IF THE TOP OF THE LOWER SCREEN HITS UPPER SCREEN PRINT
;POSN THEN THE UPPER SCREEN HAS TO BE SCROLLED AS WELL, FROM TOP TO PRINT POSN

SCRLS:     LD HL,LWTOP
           LD A,(HL)         ;LS TOP WILL MOVE UP BY ONE LINE
           DEC A
           JR Z,PATER        ;OFF SCREEN ERROR IF WINDOW HIT SCREEN TOP

           LD (HL),A         ;NEW LWTOP
           LD (WINDTOP),A    ;ALSO RECORD NEW TOP FOR CURRENT (TEMP) WINDOW (LS)
           LD HL,KPOS+1
           DEC (HL)          ;CURSOR LINE KEPT UP-TO-DATE
           LD HL,SPOSNU+1
           CP (HL)
           JR NZ,DOSCRL      ;JR IF NO CLASH WITH UPPER SCREEN PRINT POSN
                             ;(JR ALSO IF WINDTOP IS ABOVE US PRINT POSN - SIC)
           PUSH AF
           DEC (HL)          ;US PRINT POSN MOVES UP ONE LINE
           CALL STREAMFE     ;MAIN WINDOW
           POP AF
           LD (WINDBOT),A    ;WIND BOT=FORMER PRINT POSN
           CALL EDRS1UP      ;SCROLL MAIN WINDOW UP ONE
           CALL STREAMFD     ;LOWER WINDOW
           JR DOSCRL         ;SCROLL LS

RSTTEMPS:  AND A
           DB &26            ;'JR +1'

SVTEMPS:   SCF
           LD HL,THFATT
           LD DE,TEMPW1      ;8 BYTES OF TEMP STORE AVAILABLE HERE
           JR C,SVRSTTMPS

           EX DE,HL

SVRSTTMPS: JP LDIR8          ;LD BC,8:LDIR:RET


;COPY 8 BYTES FROM HL TO MEM1 AND MEM2, DOUBLING
;EXIT WITH HL PTING TO MEM1

DBCHAR:    PUSH BC
           PUSH DE
           LD DE,MEMVAL+8    ;(MEMVAL+0 MIGHT BE IN USE)
           PUSH DE
           LD B,8

DHLP:      LD A,(HL)
           INC HL
           LD (DE),A
           INC DE
           LD (DE),A
           INC DE
           DJNZ DHLP         ;LOOP DOUBLES CHARACTER BYTES

           POP HL            ;PTR TO TOP HALF OF CHAR PAT
           POP DE
           POP BC
           RET

;USED TO GIVE 'START TAPE..' PROMPT TO LOWER SCREEN, AND
;TO GIVE 'SCOLL?' PROMPT. ON ENTRY, A=UTMSG NUMBER

WTBRK:     CALL WTB2
           CALL UTMSG
           CALL READKEY      ;CLEAR BUFFER
           CALL GTKBK

WTB2:      PUSH AF
           CALL CLSLOWER
           POP AF
           RET

;USED TO PRINT CURSOR

FONOP2:    LD BC,(MNOP)
           PUSH BC
           RET

;          INCLUDE TAPEMN.SAM     ;SAVE, LOAD, MERGE, VERIFY
;TAPEMN.SAM - SAVE/LOAD/MERGE/VERIFY CONTROL
;SYNTAX CHECK FOR ALL TAPE COMMANDS STARTS AT SLMVC

;THERE ARE 2 BUFFERS - HDR (HEADER - REQUESTED) AND HDL (HEADER - LOADED)
;HEADER BUFFER FORMAT:

;0       - TYPE (16=BAS, 17=NUM ARRAY, 18=STR ARRAY, 19=CODE, 20=SCREEN$)
;1-10    - (10) FILE NAME, PADDED WITH SPACES IF NEEDED
;11-14   - (4)  ALLOWS LONGER FILE NAME IF SLDEV<>T
;15      - (1)  FLAGS. BIT 0=INVIS. NAME, BIT 1=PROTECTED CODE
;16-26   - (11) IF TYPE 17 OR 18=ARRAY/STRING TLBYTE/NAME (11)
;16             IF TYPE 20     =SCREEN MODE
;16-18          IF TYPE 16     =PROG LEN EXCLUDING VARS (3)
;19-21          IF TYPE 16     =PROG LEN PLUS NVARS, EXCLUDING GAP AND SAVARS (3)
;22-24          IF TYPE 16     =PROG LEN PLUS NVARS, EXCLUDING SAVARS (3)
;27        (1) DIRE - DIRECTORY ENTRY NUMBER (HDR ONLY) NOT USED
;28-30   - (4)  SPARE

;DISP OF HDN FROM BUFFER START:

;31-33   - (3)  REL PAGE FORM START ADDR IF CODE, ACTUAL ADDR IF PROG OR DATA.
;               (OR FFXXXX IF ARRAY DOESN'T EXIST)
;34-36   - (3)  DATA LENGTH  (PAGEFORM) OR FFFFFF IF E.G. LOAD "" CODE
;               PROG+VARS LENGTH, OR ARRAY LEN (OR FFXXXX IF NON-EXISTENT)
;37-39   - (3)  EXECUTE ADDR. IF CODE, REL PAGE FORM, OR FFXXXX IF NO EXEC.
;               IF BAS AND NO AUTO-RUN, FIRST BYTE=FF, ELSE FIRST=0 AND THE
;               AUTO-RUN LINE NUMBER IS IN THE NEXT TWO BYTES.

;40-79          COMMENT. NOT INITIALISED - CAN BE POKED, PEEKED.

;SAVE, LOAD, VERIFY, MERGE ALL ENTER HERE

SLMVC:     SUB &A6           ;OVERTOK
           LD (OVERF),A
           JR NZ,NOVE

           RST &20           ;SKIP "OVER"

NOVE:      LD HL,(PSLD)
           LD (SLDEV),HL     ;PERM DEVICE TO TEMP
           CALL EXPTSTR      ;NAME
           JR NC,HDR2        ;JR IF NOT RUNNING

           LD HL,HDR+1       ;HEADER BUFFER ADDR
           LD B,25

HDCLP:     LD (HL),&20       ;CLEAR NAMES AREAS WITH SPACES
           INC HL
           DJNZ HDCLP

           LD B,14

HDCLP2:    LD (HL),&FF       ;CLEAR REST WITH FFH
           INC HL
           DJNZ HDCLP2

           CALL SBFSR        ;BC=NAME LEN, DE=START, IN SYS PAGE BUFFER **
           LD H,NMLEN+1
           CALL TCHK
           JR Z,NLTP

           LD H,NMLEN+5      ;ALLOW EXTRA CHARS IF NON-T

NLTP:      LD A,C
           CP H
           JR NC,IFNER       ;LIMIT NAME LEN

           LD HL,HDR+1       ;DEST FOR FIRST NAME CHAR
           LD (HL),&FF       ;ASSUME NAME IS NULL
           AND A
           LD A,(CURCMD)
           JR NZ,TNMOK       ;JR IF NAME LEN IS 1-MAX CHARS LONG

           CP SAVETOK
           JR NZ,HDR2        ;JR IF NOT SAVE (WITH A NULL NAME)

IFNER:     RST &08
           DB 18             ;'Invalid file name'

TNMOK:     CP SAVETOK
           JR NZ,MVTNM

           LD A,(DE)         ;FIRST CHAR OF SAVE NAME CAN BE
           CP 4              ;0 FOR NOT INVIS, NOT PROT
           JR NC,MVTNM       ;1 FOR     INVIS, NOT PROT
                             ;2 FOR NOT INVIS, PROT
                             ;3 FOR INVIS, PROT
           LD (HDR+HFG),A
           INC DE            ;(INVIS. MEANS NAME NOT PRINTED DURING LOADING,
           DEC C             ;PROT. MEANS AUTO-RUN CODE FILE CANNOT BE STOPPED)
           JR Z,HDR2         ;FIRST CHAR IS NOT INCLUDED IN NAME PROPER.

MVTNM:     EX DE,HL
           LDIR              ;COPY NAME TO BUFFER

HDR2:      RST &18
           CP &FF
           JR Z,HDR4         ;JR IF FN LEADER FOUND (SHOULD BE SCREEN$ OR CODE)

HDR3:      CP LINETOK
           JP NZ,HDR6        ;IF NOT 'LINE', CHECK FOR 'DATA', OR CR/COLON

           LD A,(CURCMD)
           CP VERIFYTOK
           JP Z,NONSENSE     ;VERIFY "NAME" LINE n NOT ALLOWED

           CALL SEXPT1NUM
           JR NC,HDRLNOK     ;JR IF NOT RUNNING

           CALL GETINT       ;LINE
           LD HL,HDR+HDN+6   ;PTR TO AUTO-RUN LINE AREA
           LD (HL),0         ;FLAG 'AUTORUN'
           INC HL
           LD (HL),C
           INC HL
           LD (HL),B         ;PLACE LINE NO.

;S/L/V/M "NAME":   ENTERS HERE, AND S/L/M "NAME" LINE n

HDRLNOK:   CALL CHKEND

           CALL ADDRPROG
           LD (HDR+HDN),A
           LD (HDR+HDN+1),HL ;START
           EX DE,HL
           LD C,A            ;CDE=PROG
           CALL ADDRELN
           DEC HL            ;DEC AHL SO PROG LEN-1 USED. END OF SAVARS MARKER
           BIT 7,H           ;NOT SAVED. (SO ELINE NEVER = PROG WHEN PROG
           JR NZ,HDRPLC      ;SPACE IS RECLAIMED, MAKEROOM AT (PROG) ALWAYS OK)

           DEC A

HDRPLC:    CALL SUBAHLCDE    ;GET AHL=PAGE FORM OF DIFFERENCE
           LD (HDR+HDN+3),A
           LD (HDR+HDN+4),HL ;FILE LEN=ELINE-PROG

           LD B,3            ;DO NVARS, NUMEND, SAVARS
           LD IX,NVARS+1
           LD IY,HDR+16      ;STORE IN HDR+16/+19/+22

RNTVL:     LD H,(IX+0)
           DEC IX
           LD L,(IX+0)
           DEC IX
           LD A,(IX+0)
           DEC IX
           CALL SUBAHLCDE
           LD (IY+0),A
           INC IY
           LD (IY+0),L
           INC IY
           LD (IY+0),H
           INC IY
           DJNZ RNTVL
                             ;PROGRAM (EX. STR/ARRAYS AND GAP) LEN
                             ;PROGRAM (EX. STR/ARRAYS) LEN

           LD A,16           ;TYPE=PROG
           JP SLVMC          ;JP TO COMMON ROUTINE

HDR4:      RST &20           ;SKIP FFH
           CP CODETOK
           JR NZ,HDR5

;HANDLE "NAME" CODE <START><,LENGTH><,EXECUTION ADDR>

           LD DE,HDR+HDN     ;PT TO HDR AREA FOR NUMBERS
           LD B,3            ;MAX OF 3 NUMS FOLLOW 'CODE'

           RST &20           ;SKIP 'CODE'
           CALL CRCOLON
           JR NZ,HDRNMS      ;JR IF NOT JUST "NAME" CODE

           LD A,(CURCMD)
           CP SAVETOK
           JR Z,HDNSHP       ;SAVE "NAME" CODE NEEDS PARAMS

           JR HDRNOK

HDRNLP:    DEC B

HDNSHP:    JP Z,NONSENSE     ;JR IF MORE THAN 3 NUMBERS USED

           RST &20

HDRNMS:    PUSH BC           ;COUNT
           PUSH DE           ;PTR
           CALL EXPT1NUM
           JR NC,HDRN1       ;JR IF NOT RUNNING

           CALL UNSTLEN      ;GET NUMBER IN AHL IN PAGE/ADDR FORM
           POP DE
           EX DE,HL          ;HL=PTR, ADE=ADDR
           LD (HL),A
           INC HL
           LD (HL),E
           INC HL
           SET 7,D
           LD (HL),D
           INC HL
           PUSH HL           ;PTR

HDRN1:     POP DE
           POP BC            ;NO. COUNT
           RST &18
           CP ","
           JR Z,HDRNLP       ;LOOP FOR ANOTHER NO. IF A COMMA FOLLOWED THE LAST

           LD A,(CURCMD)
           CP SAVETOK
           JR NZ,HDRNOK

           LD A,B
           CP 3
           JR Z,HDNSHP       ;SAVE CANNOT HAVE JUST SAVE "NAME" START

HDRNOK:    CALL CHKEND

;EXECUTION ROUTINE FOR SAVE/LOAD/VERIFY "NAME" CODE ETC.

           LD A,19           ;TYPE=CODE
           JP SLVMC          ;JP TO COMMON ROUTINE

HDR5:      CP SCRNTOK
           JP NZ,NONSENSE

           CALL SABORTER     ;SKIP 'SCREEN$'

           CALL FLITE        ;GET BC=LINE INT TABLE LEN
           LD HL,&0028
           ADD HL,BC         ;ALLOW FOR PALTAB
           LD A,(MODE)
           LD (HDR+16),A     ;MODE
           CALL SCRLEN       ;GET SCREEN LEN FOR MODE IN ADE
           LD C,A
           PUSH HL           ;LEN OF PALTAB AND LINITAB
           PUSH DE           ;SCREEN LEN
           ADD HL,DE
           EX DE,HL          ;ADE=TOT LEN
           LD HL,HDR+HDN
           LD A,(CUSCRNP)
           LD (HL),A
           INC HL
           LD (HL),0
           INC HL
           LD (HL),&80       ;START IS AT 8000H IN SCREEN PAGE
           INC HL
           LD (HL),C         ;LEN MSB
           INC HL
           LD (HL),E
           INC HL
           LD (HL),D         ;LEN
           POP DE
           SET 7,D           ;DE=SCREEN END IF M0/1
           INC C
           DEC C
           JR Z,HDRSC2       ;JR IF M0 OR M1

           INC A             ;SECOND PAGE OF M2/M3 SCREEN

HDRSC2:    POP BC            ;PALTAB+LINITAB LEN
           LD HL,PALTAB
           CALL TSURPG
           LDIR              ;COPY TO END OF SCREEN
           LD A,20           ;'SCREEN$' TYPE
           JR SLVMC          ;JR TO COMMON ROUTINE

HDR6:      CP &B9            ;DATATOK
           JP NZ,HDRLNOK

           LD A,(CURCMD)
           CP MERGETOK
           JR Z,SVDNH        ;MERGE "NAME" DATA NOT ALLOWED

           RST &20           ;SKIP 'DATA'
           CALL R1OFFCL
           DW LENGSR         ;** BUG FIX
           PUSH AF           ;FOUND/NOT FOUND STATUS
           LD B,18           ;TYPE ASSUMED TO BE STRING
           LD A,(FLAGS)
           ADD A,A
           JP M,SVDNU        ;JP IF NUMERIC

           JR NC,SVDS1       ;JR IF NOT RUNNING

           RST &18
           CP ")"
           JR NZ,SVDTT       ;MUST BE NAME$

           RST &20           ;SKIP ')'
           JR SVDTT          ;MUST BE NAME$()

SVDS1:     BIT 6,C
           JR Z,SVDTT        ;JR IF NO OPENING BRACKET USED

           JR SVNSC

SVDNU:     DEC B             ;TYPE=17
           BIT 5,C

SVDNH:     JP Z,NONSENSE     ;ERROR IF NON-ARRAY NUMERIC

SVNSC:     RST &18
           CALL INSISCBRK    ;INSIST ON ')', SKIP

SVDTT:     POP AF
           PUSH BC           ;B=TYPE, 17 (NUMERIC) OR 18 (STRING)
           JR Z,SVNWAR       ;JR IF NOT FOUND

           LD A,(MEMVAL+2)
           LD (HDR+HDN),A
           LD (HDR+HDN+1),DE ;START OF VARIABLE
           LD HL,MEMVAL+3    ;TEXT LEN DATA STORED HERE
           CALL ADD14        ;ALLOW FOR T/L,NAME,PG,MOD 16K
           LD (HDR+HDN+3),A
           LD (HDR+HDN+4),HL ;LEN OF VARIABLE INC. HEADER
           JR SVDTCE

;NEW ARRAY

SVNWAR:    LD A,(CURCMD)
           CP LOADTOK
           JP NZ,VNFERR      ;ERROR IF VERIFYING OR SAVING A NEW ARRAY

SVDTCE:    POP AF            ;TYPE
           CALL CHKEND

           LD HL,TLBYTE
           LD DE,HDR+16
           LD BC,11
           LDIR              ;COPY DETAILS OF VAR NAME TO HDR

SLVMC:     LD (HDR),A

SLVM1:     LD A,(CURCMD)
           CP SAVETOK
           JP Z,SAMAIN       ;SAVE PROGRAM

;LOAD/VERIFY/MERGE MAIN

LVMMAIN:   CALL TORN
           JR Z,LKTH         ;JR IF TAPE, OR N AND NO DOS

           LD IX,HDR
           RST &08
           DB FOPHK          ;CALL DOS TO LOAD HDR (OPEN FILE FOR READ)
           JR LDFL

;JUMP FROM DOS (E=3) - LOAD HEADER, THEN FILE FROM TAPE/NET

LKTH:      CALL LKHDR        ;GET THE CORRECT HEADER

;JUMP FROM DOS (E=1) - LOAD JUST FILE FROM TAPE/NET

LDFL:      LD A,(HDL)
           SUB 19
           JR NZ,LVM2        ;JR IF NOT CODE

           LD A,(CURCMD)
           CP MERGETOK
           JR NZ,CDSCVE      ;JR IF LOAD/VERIFY CODE

           LD A,(HDL+HFG)
           AND &02
           JR NZ,CDSCVE      ;JR IF PROT - CANNOT STOP AUTO-RUN CODE

           DEC A
           LD (HDL+HDN+6),A  ;PREVENT AUTO-RUN IF MERGE UNPROTECTED CODE
           JR CDSCVE

LVM2:      DEC A
           JP Z,LDSCRN       ;JR IF TYPE=SCREEN$ (20)

           LD A,(CURCMD)
           CP LOADTOK
           JP Z,LDPRDT       ;JR IF LOAD (A PROGRAM OR ARRAY - TYPES 16-18)

           CP MERGETOK
           JP Z,MEPROG       ;JP IF MERGE PROGRAM - CONT WITH VERIFY

;VERIFY PROGRAM, DATA, CODE OR SCREEN, LOAD CODE

CDSCVE:    CALL RDRLEN       ;CDE='DESIRED' LEN FROM HDR
           LD B,C
           PUSH BC
           PUSH DE
           CALL RDLLEN       ; CDE=ACTUAL LEN OR FFFFFF
           POP HL
           POP AF
           INC A
           JR Z,HDLNM        ;JR IF DESIRED LEN UNSPECIFIED (ONLY IF CODE)

           DEC A
           AND A
           SBC HL,DE
           SBC A,C
           JP C,TERROR       ;ERROR IF LEN OF FILE IS LONGER THAN REQUESTED

           OR H
           OR L
           JR Z,HDLNM        ;EQUAL LENS OK FOR VERIFY OR LOAD

           LD A,(CURCMD)
           CP VERIFYTOK
           JP Z,TERROR       ;IF LOAD, LEN CAN BE LESS THAN 'DESIRED'
                             ;BUT VERIFY INSISTS ON EQUALITY

HDLNM:     LD HL,HDR+HDN
           CALL RDTHREE      ;CDE=DESIRED START
           LD A,(HDR)
           CP 19
           LD A,C
           JR NZ,STSPEC3     ;FOR ANYTHING APART FROM CODE, 'START' IS ALWAYS
                             ;'DESIRED' (E.G. CUR. PROG, SCREEN OR VAR. ADDR)
           INC A
           JR NZ,STSPEC      ;JR IF DESIRED START WAS SPECIFIED: E.G.
                             ;VERIFY/LOAD "NAME" CODE 40000
           LD HL,HDL+HDN
           CALL RDTHREE      ;CDE=LOADED START
           JR STSPEC2

STSPEC:  ;  IN A,(LRPORT)     ;PAGE AT 0000
         ;  ADD A,C           ;CONVERT REL LOAD ADDR TO ABS
         ;  LD C,A
           DEC C

STSPEC2:   LD A,(LDCO)
           ADD A,C

STSPEC3:   PUSH DE
           CALL TSURPG       ;START SWITCHED IN AT HL
           CALL RDLLEN       ;CDE=ACTUAL LEN FROM LOADED HDL (PAGE FORM)
           POP HL            ;START
           CALL LDVDBLK      ;LOAD OR VERIFY BLOCK
           LD A,(CURCMD)
           CP VERIFYTOK
           RET Z

;MUST BE LOAD CODE

           LD A,(HDL+HFG)
           BIT 1,A
           JR NZ,HDNSTP      ;JR IF PROT - CANNOT STOP AUTO-RUN CODE

           LD A,(HDR+HDN+6)
           LD HL,(HDR+HDN+7)
           CP &FF
           JR NZ,HDLDEX      ;JR IF LOAD EXEC - OVER-RIDES ANY SAVED EXEC

HDNSTP:    LD A,(HDL+HDN+6)
           LD HL,(HDL+HDN+7) ;AHL=LOADED EXEC ADDR (REL PAGE FORM) OR FFXXXX
           CP &FF
           RET Z             ;RET IF NO EXEC ADDR

HDLDEX:    CALL PDPSR2       ;SWITCH IN CORRECT PAGE, FIDDLE HL IF NEEDED
           LD B,H
           LD C,L
           JP R1OFFCLBC      ;CALL BC WITH ROM1 OFF

;LOAD OR VERIFY DATA BLOCK ACCORDING TO CURCMD

LDVDBLK:   LD A,(CURCMD)
           CP VERIFYTOK
           JR Z,LDVD2        ;JR WITH NC IF VERIFY

;CALLED TO LOAD A DATA BLOCK

LDDBLK:    SCF               ;LOAD

LDVD2:     LD A,&FF          ;DATA BLOCK
           PUSH AF
           CALL TORN         ;Z IF 'T', OR 'N' AND NO DOS
           JR Z,LDVD3        ;IF NO DOS LET ROM HANDLE NET LOAD

DOSLV:     LD IX,HDR
           POP AF            ;HL=DEST, CDE=LEN
           JR C,DOSLD

           RST &08
           DB VFYHK          ;DOS VERIFY FOR DISC/NET ETC
           RET

DOSLD:     RST &08
           DB LDHK           ;DOS LOAD FOR DISC/NET ETC
           RET

LDVD3:     POP AF
           CALL LDBYTES
           RET C

TERROR:    RST &08
           DB 19             ;'LOADING ERROR'


;LOAD/VERIFY SCREEN$ FILE

LDSCRN:    LD A,(MODE)
           LD C,A
           LD HL,HDL+16
           LD A,(HL)
           CP &20            ;20H IF THIS IS A CODE FILE LOADED AS SCREEN$
           JR NZ,LDSC2       ;JR IF IT IS A SCREEN$ FILE LOADED AS SCREEN$

           LD (HL),C         ;SET MODE=CURRENT MODE FOR CODE FILE
           LD A,C            ;SKIP MODET

LDSC2:     CP C
           CALL NZ,MODET     ;SELECT MODE IF A NEW ONE IS NEEDED

           CALL SELSCRN
           LD HL,HDL+HDN+3
           CALL RDTHREE      ;CDE=LOADED LEN
           LD HL,&8000       ;SCREEN START
           PUSH DE
           CALL LDVDBLK
           POP DE
           LD A,(CURCMD)
           CP VERIFYTOK
           RET Z

           LD A,(HDL+16)     ;MODE
           PUSH DE
           CALL SCRLEN       ;DE=SCREEN LEN MOD 16K FOR MODE. NC
           POP HL            ;FILE LEN MOD 16K
           RES 7,H
           SBC HL,DE         ;HL=PALTAB/LINICOLS
           RET Z             ;RET IF EXACT LEN CODE FILE

           RET C             ;OR SHORT

           SET 7,D           ;DE=9B00 IF MODE 0, BB00 IF MODE 1, ELSE A000 (AND
                             ;LOAD BLOCK MEANS C/D PAGED).
           LD BC,40          ;SUB PALTAB LEN
           SBC HL,BC
           PUSH HL           ;HL=LINICOL LEN IN FILE
           EX DE,HL          ;HL PTS TO PALTAB AND LINICOLS DATA
           LD A,(CUSCRNP)
           CALL CUS2         ;Z IF CURRENT SCREEN IS DISPLAYED
           LD DE,PALTAB
           JR Z,PMV          ;MOVE LOADED PALTAB TO ACTIVE PALTAB, OR STORED
                             ;AREA, IF CURRENT SCRN IS INVIS.
           LD DE,PALBUF-&4000

PMV:       LDIR              ;COPY PALTAB (40 BYTES)

           LD A,(HL)
           CP 195
           LD (DE),A
           POP BC            ;LINICOL LEN
           RET NC            ;RET IF NO LINICOLS

           LD A,B
           CP 2
           RET NC            ;LIMIT LINICOL LEN TO 01FFH FOR SAFETY

           DI
           LDIR
           LD A,&FF
           OUT (STATPORT),A  ;PREVENT ANY LINE INTS TILL AFTER NEXT FRAME
           EI
           RET

;LOAD PROGRAM OR DATA FILE

LDPRDT:    CALL RDLLEN       ;CDE=LEN OF FILE TO LOAD (PAGEFORM)
           PUSH DE
           LD A,C
           CALL RDRLEN       ;CDE=LEN OF CURRENT ('DESIRED') AREA
           POP HL            ;AHL=LOADING LEN
           INC C
           JR Z,LDNAR        ;JR IF LOADING A NEW ARRAY (CUR LEN=FFXXXX)

           DEC C
           CALL SUBAHLCDE
           JR C,LDSZOK       ;JR IF CURRENT FILE IS BIGGER THAN LOADING

LDNAR:     CALL TSTRMAHL     ;CHECK AHL BYTES OK. (PAGEFORM)

LDSZOK:    LD HL,HDR+HDN
           CALL RDTHREE      ;START OF EXISTING ARRAY (PAGE FORM) OR FFXXXX
           LD A,C
           INC C
           JR Z,LDCRA        ;JR IF NEW ARRAY

           PUSH AF
           PUSH DE           ;START
           CALL RDRLEN       ;CURRENT LEN TO CDE (PAGEFORM)
           PUSH DE
           LD D,C
           POP BC            ;DBC=LEN
           POP HL
           POP AF            ;AHL=START
           CALL SELURPG
           LD A,(HDR)
           SUB 16
           JR NZ,LDCRX       ;JR IF NOT PROGRAM (IT'S AN ARRAY)

           LD (NVARSP),A
           LD (NVARS+1),A    ;SINCE PROG AND NVARS HAVE BEEN DELETED,
                             ;PREVENT XOINTERS ALTERING NVARS, CAUSING
                             ;SADJ WITH NO FOR-NEXTS, OR ODD BSTK
           LD A,D            ;ABC=LEN
           CALL RECL2BIG     ;DELETE CURRENT PROGRAM
           LD HL,(BASSTK)
           LD (BSTKEND),HL   ;CLEAR BASIC STACK - DATA OBSOLETE
           CALL ADDRPROG     ;ADDR PROG
           JR LDCR3

LDCRX:     LD A,D            ;ABC=LEN
           CALL RECL2BIG     ;DELETE CURRENT ARRAY

LDCRA:     CALL ADDRELN      ;ADDRESS ELINE
           CALL DECPTR       ;DEC HL AND CHANGE PAGE IF BELOW 8000H

LDCR3:     PUSH HL
           CALL RDLLEN       ;CDE=LOADING LEN (PAGEFORM)
           POP HL
           PUSH BC
           PUSH DE
           LD A,C
           LD B,D
           LD C,E
           CALL MKRBIG       ;OPEN ABC AT HL
           LD (HL),&FF       ;IN CASE LOAD FAILS!!
           POP DE
           POP BC
           IN A,(251)
           PUSH AF
           PUSH HL
           CALL LDDBLK       ;LOAD MAIN BLOCK
           POP DE
           POP BC            ;BDE=START OF MAIN BLK
           LD A,(HDR)
           CP 16
           JR Z,LDPROG       ;JR IF PROGRAM WAS LOADED

           LD A,B
           CALL TSURPG       ;DE PTS TO LOADED ARRAY TYPE/LEN BYTE
           LD HL,HDR+16
           LD A,(DE)
           XOR (HL)
           AND &F0
           XOR (HL)
           LD (DE),A         ;TYPE FROM LOADED ARRAY, NAME LEN FROM REQUESTED
           INC DE            ;PT TO NAME
           INC HL
           LD BC,10
           LDIR              ;COPY REQUESTED NAME TO SAVARS
           RET

;BASIC FILE LOADED - SET VARS

LDPROG:    LD B,3            ;DO NVARS, NUMEND, SAVARS
           LD HL,HDL+16
           LD IY,NVARS+1

SNTVL:     CALL RDTHREE      ;CDE=HDL DATA (LEN OF PROG ALONE, WITH NVARS, ETC)
           INC HL
           PUSH HL
           CALL ADDRPROG
           CALL ADDAHLCDE
           LD (IY+0),H
           DEC IY
           LD (IY+0),L
           DEC IY
           LD (IY+0),A
           DEC IY
           POP HL            ;HDL PTR
           DJNZ SNTVL        ;SET NVARS, NUMEND, SAVARS

           CALL RESTOREZ     ;SET DATA PTR TO START OF PROG
           CALL R1OFFCL
           DW DOCOMP         ;DEF PROCS/DEF FNS AND LABELS NEED DOING -
                             ;ANY PRE-PASS OF LABELS ETC IS OBSOLETE.
           LD A,(HDR+HDN+6)
           LD HL,(HDR+HDN+7)
           AND A
           JR Z,LDUSLN       ;JR IF THERE'S A DESIRED START LINE (LD "N" LINE n)

           LD A,(HDL+HDN+6)
           LD HL,(HDL+HDN+7)
           AND A
           RET NZ

LDUSLN:    DEC A             ;A=FF
           LD (PPC+1),A      ;ENSURE GOTO SEARCH STARTS FROM PROG, NOT CLA
           JP GOTO3          ;SET VARS SO GOTO LINE HAPPENS NEXT

;LOOK FOR A HEADER FROM TAPE OR NET.
;LOOK FOR A MATCHING HEADER (USING HDR AREA), LOADING HEADERS TO HDL AREA
;PRINT NAMES IF BIT 0,(TPROMPTS)=0. LOOP TILL MATCH FOUND.

LKHDR:     CALL LDHDR
           JR NC,LKHDR        ;LOOP IF ERROR

           CALL STREAMFE     ;"S"
           LD A,(HDL)        ;TYPE
           LD C,A
           OR &10
           CP &15
           JR NC,LKHDR

           LD HL,HDL+HFG
           LD A,(TPROMPTS)
           AND 1             ;ISOLATE SYS VAR 'PRINT NAMES' BIT.
           OR (HL)           ;OR WITH HDR VERSION
           LD (HL),A
           RRA
           JR C,LKHNP        ;JR IF NO PRINTING OF NAMES WANTED

           LD A,&0D
           RST &10
           LD A,"*"
           BIT 4,C
           CALL Z,&0010      ;PRINT "*" BEFORE NAME IF ZX TYPE
           LD A,C            ;A=16-20
           OR &10
           SUB 12            ;A=4-8
           CALL UTMSG        ;PRINT TYPE MSG

LKHNP:     LD BC,NMLEN*256   ;C=0
           LD DE,HDL
           LD HL,HDR
           LD A,(DE)         ;LOADED TYPE
           CP (HL)           ;CP DESIRED TYPE
           JR Z,LKHTM

           SUB 20            ;19->255, 20->0
           ADC A,0           ;19->0,20->0
           JR NZ,SNMN        ;JR IF NOT CODE/SCREEN$

           LD A,(HL)         ;ELSE
           LD (DE),A         ;LOADED=DESIRED (DESPITE UTMSG)
           SUB 20
           ADC A,0
           JR Z,LKHTM        ;IF OTHER FILE IS CODE/SCREEN$, ACCEPT MATCH

SNMN:      INC C             ;'NO MATCH' - TYPES DIFFER

LKHTM:     INC HL
           INC DE
           LD A,(HL)
           INC A
           JR NZ,PRHDLP

           LD H,D            ;IF DESIRED NAME=NULL (STARTS 0FFH) THEN
           LD L,E            ;ENSURE 'MATCH' OF LOADED NAME BY COMP VS. SELF!

PRHDLP:    LD A,(DE)
           XOR (HL)
           AND &DF           ;IGNORE MISMATCH ON BIT 5 (LC/UC)
           JR Z,PRHDC        ;JR IF MATCH BETWEEN LOADED NAME CHAR AND DESIRED

           INC C             ;NZ C REG SHOWS A MISMATCH

PRHDC:     LD A,(HDL+HFG)
           RRA
           LD A,(DE)         ;LOADED NAME CHAR
           CALL NC,&0010     ;PRINT UNLESS TURNED OFF
           INC HL
           INC DE
           DJNZ PRHDLP

           LD A,C
           AND A
           JR NZ,LKHDR       ;JR IF ANY MISMATCH OCCURRED - LOOK FOR ANOTHER

           LD A,(HDL+HFG)
           RRA
           LD A,&0D
           RET C

           RST &10           ;CR AFTER LAST (MATCHED) FILE NAME
           RET

;LOAD A HEADER

LDHDR:     LD HL,HDL
           LD DE,80
           XOR A
           LD C,A            ;CDE=80 BUT DE WILL CHANGE TO 17 IF ZX HDR FOUND
           INC A             ;'HEADER'
           SCF               ;'LOAD'
           CALL LDBYTES
           RET NC            ;RET IF LOAD FAILED

           LD HL,HDL
           LD A,(HL)         ;TYPE 0-3 IF ZX HEADER, 16-20 IF SAM
           BIT 4,A
           RET NZ            ;RET IF A SAM HEADER. CY STILL SHOWS 'OK'

           SUB 3
           LD A,0
           LD (HDL+HFG),A    ;ENSURE VISIBLE, UNPROTECTED
           RET NZ            ;RET IF OTHER THAN ZX CODE HDR (CY)

;TRANSFORM 17-BYTE ZX CODE HEADER INTO SAM HEADER

           LD (HL),19        ;TYPE=SAM CODE
           EX DE,HL
           XOR A
           LD HL,(HDL+11)    ;ZX FILE LEN
           CALL PAGEFORM
           LD (HDL+HDN+3),A
           LD (HDL+HDN+4),HL ;SAM LENGTH FORMAT
           LD C,&20          ;NORMAL 'SCREEN MODE' FOR SAM CODE FILE **
           LD HL,(HDL+13)    ;ZX START ADDR
           LD A,H            ;DEST ADDR MSB
           CP &40
           JR C,HDTR5

           CP &5B
           JR NC,HDTR5

;MUST BE LOADING TO SCREEN

           LD A,20
           LD (DE),A         ;FILE TYPE=SCREEN$
           LD C,0            ;MODE 0

HDTR5:     LD A,C
           LD (HDL+16),A     ;SET SCREEN MODE OR 'NO MODE'
           XOR A
           LD (HDL+HFG),A    ;NO PROTECT OR INVIS
           CALL PAGEFORM
           DEC A
           LD (HDL+HDN),A
           LD (HDL+HDN+1),HL ;SAM START ADDR FORMAT (IRREL IF SCREEN$)
           LD A,&FF
           LD (HDL+HDN+6),A  ;NO EXEC ADDR
           SCF               ;'OK'
           RET

SAMAIN:    LD HL,HDR+HDN
           LD A,(HDR)
           CP 19
           LD A,0
           JR NZ,SAPA2       ;JR IF NOT CODE

           IN A,(250)        ;ADJUST START PAGE

SAPA2:     ADD A,(HL)
           LD (HL),A
           CALL TORN
           JR Z,SVFL         ;LET ROM HANDLE T SAVE, OR NET SAVE IF NO DOS

SADOS:     LD IX,HDR
           RST &08
           DB SVHK           ;DOS SAVE
           RET

;JUMP FROM DOS (E=2) - SAVE ENTIRE FILE TO TAPE OR NET

SVFL:      LD A,(TPROMPTS)
           RRA
           RRA
           JR C,SAHDDB       ;JR IF NO SAVE PROMPTS WANTED

           CALL TCHK
           LD A,3            ;'START TAPE..' MSG NO.

           CALL Z,WTBRK      ;GIVE MSG IF TEMP DEVICE=T

;SAVE HEADER, AND DATA BLOCK SPECIFIED BY HEADER

SAHDDB:  ;  IN A,(250)
          ; INC A             ;PAGE WITH HDR IN
         ;  CALL TSURPG       ;PAGE IN AT 8000H
           XOR A
           LD C,A
           INC A             ;'HEADER' (A=1)
           LD DE,80          ;CDE=80 (HEADER LEN)
         ;  LD HL,HDR+4000H
           LD HL,HDR
           CALL SABYTES      ;SAVE HEADER

           LD HL,HDR+HDN
           LD A,(HL)
           CALL TSURPG
           INC HL
           LD E,(HL)
           INC HL
           LD D,(HL)         ;DE=ADDR TO START SAVING FROM (SWITCHED IN)
           PUSH DE
           INC HL
           CALL RDTHREE      ;CDE=LEN
           POP HL            ;START
           LD A,&FF          ;MAIN BLOCK
           JP SABYTES


;GET SCREEN LEN
;ENTRY: A=MODE. EXIT: ADE=001B00H IF MODE 0, 003800H IF MODE 1, ELSE 012000H

SCRLEN:    LD DE,&1B00       ;MODE 0 SCRN LEN
           AND A
           RET Z

           LD D,&38          ;MODE 1 SCRN LEN=3800H
           DEC A
           RET Z

           LD A,1            ;A=16K PAGE. MODES 2 AND 3 LEN=4000H+2000H
           LD D,&20
           RET

TORN:      CALL TCHK
           RET Z

           CP "N"
           RET NZ

           LD A,(DOSFLG)
           AND A
           RET

TCHK:      LD A,(SLDEV)
           CP "T"
           RET

;CALLED BY VIDSEL AND TAPEMN

CUS2:      AND &7F           ;MIDI OUT BIT INACTIVE
           LD D,A
           IN A,(VIDPORT)
           AND &7F
           CP D
           RET

;          INCLUDE TAPEX.SAM
;
;TAPEX.SAM - TAPE/NET EXECUTIVE ROUTINES

;SAVE CDE BYTES FROM HL TO NET. TYPE ON STACK

                             ;HDR/DATA FLAG ON STACK
WNF:       PUSH BC
           LD B,100
           CALL DELBC
           POP BC
           CALL CKNET        ;WAIT FOR FREE NET
           POP AF
           CALL NMOUT        ;SEND TYPE

           LD IX,NOSR
           CALL NIXR

;NET SEND PARITY

           EXX
           LD A,H
           EXX

;NET/MIDI OUT

NMOUT:     PUSH AF

NMOUT1:    CALL BRKCR
           XOR A
           IN A,(CLUTPORT)
           AND 2
           JR NZ,NMOUT1

           CALL BRKCR
           POP AF
           OUT (MDIPORT),A
           RET

;ENTRY: HL POINTS TO DATA TO SAVE, CDE=LEN TO SAVE (PAGEFORM) A=TYPE (AND FIRST
;BYTE TO SAVE). 01=HEADER, FF=DATA
;EXIT: NC IF ALL SAVED, CY IF SPACE PRESSED

SABLK:     DI
           PUSH AF
           CALL TCHK
           JR NZ,WNF

           CALL CDENORM      ;CONVERT CDE TO 19-BIT
           POP AF
           PUSH AF
           EXX
           LD B,A
           EX AF,AF'         ;INITIALISE PARITY BYTE WITH TYPE
           LD A,(SLDEV+1)    ;SPEED. MAX SPEED IF 19 (GIVES ABOUT 5*ZX)
                             ;HIGHER VALUES GIVE LOWER SPEEDS.
           LD L,A
           INC A
           ADD A,A
           JR NC,SVLC

           LD A,&FE          ;HI VALUE IF CY

SVLC:      INC A
           LD H,A            ;H PRODUCES DELAY ABOUT TWICE AS LONG AS L
           PUSH HL

           LD C,A            ;LEADER DELAY

;NOW FIDDLE NO. OF LEADER CYCLES TO USE TO KEEP LEN ROUGHLY CONST. WHATEVER THE
;SVSPEED. 128 OR MORE=LC*2, 86-127=LC*3, 64-85=LC*4, 52-63=LC*5, 43-51=LC*6
;37-42=LC*8,.... 19=LC*14

           XOR A
           LD H,A
           LD L,A
           LD DE,3000

SVCLC:     ADD HL,DE
           ADD A,C
           JR NC,SVCLC

           INC B
           DJNZ SVTYP        ;JR IF DATA

           ADD HL,HL         ;LONGER LEADER IF HEADER

SVTYP:     LD DE,&0202       ;D'=BORDER LS 3 BITS - RED

SVHDR:     LD A,D
           XOR &0F
           LD D,A
           OUT (KEYPORT),A
           LD B,C

SVDL0:     DEC B
           JR NZ,SVDL0       ;DELAY REG*16

           DEC HL
           LD A,H
           OR L
           JR NZ,SVHDR       ;LOOP TILL LEADER SAVED

           SRL C
           SRL C             ;QUARTER LENGTH PULSES NOW
           INC C
           INC C
           INC C             ;IN CASE VERY SMALL - HELPS AVOID SYNC BEING MISSED
           LD L,2            ;2 HALF-CYCLES ONLY
           DEC E
           JR NZ,SVHDR       ;JR IF SYNC PULSE TIME

           POP HL            ;DELAY CONSTANTS FOR HI/LOW BITS
           POP AF            ;TYPE BYTE
           LD E,A            ;FIRST BYTE
           LD D,1            ;D'=BORDER LS 3 BITS - BLUE
           SCF
           RL E

SVBL:      LD C,H            ;ASSUME HI BIT
           JR C,SV2

           LD C,L            ;GET DELAY FOR A LOW BIT

SV2:       LD A,D            ;BORDER COLOUR.
           XOR &0F           ;FLIP MIC AND BORDER BITS
           OUT (KEYPORT),A   ;38 OR 37 FROM SVBL TO END OF OUT INSTRUCTION
                             ;55 OR 54 FROM PREV OUT, PLUS DELAY (IF WITHIN BYTE
           LD B,C

SVDL:      DJNZ SVDL         ;THESE 2 INSTRUCTIONS GIVE DELAY OF 13*C, -1

           DEC C
           DEC C             ;SUB 26 Ts FROM DELAY
           XOR &0F           ;NC
           RL E
           OUT (KEYPORT),A   ;34 TO END OF OUT FROM PREV OUT, PLUS DELAY

           JP Z,SVBY         ;JP IF TIME FOR NEXT BYTE
                             ;ELSE CY/NC SHOWS NEXT BIT
           LD B,C

SVDL2:     DJNZ SVDL2

           JR SVBL

;FROM SVBL: 38/37,OUT,13*R-1,34,OUT,13*R-27,22; 38/37,OUT ETC. R=REGISTER
;E.G. REG=20: 38/37,OUT,293,OUT,293/291,OUT,293   (0.098 MSEC AT 6MHZ)
;E.G. REG=43: 38/37,OUT,592,OUT,592/591,OUT,      (0.197 MSEC AT 6MHZ)

SVBY:      EXX
           LD A,D
           OR E
           LD A,C            ;FF IF PARITY SENT, FE IF LAST JUNK BYTE SENT
                             ;(SO PARITY LAST BIT TERMINATED CORRECTLY)
                             ;0 IF LAST 64K BLOCK SENT
           JR NZ,SV4         ;JR IF MOD 64K NOT SAVED YET

           INC A
           INC A
           RET Z             ;RET IF ALL BYTES SAVED - NC, Z

           DEC C             ;DEC NUMBER OF 64K BLOCKS
           CP 3              ;
           JR NC,SV4         ;JR IF ORIG WASN'T FF OR 0 - SOME BLOCKS LEFT

           EX AF,AF'         ;PARITY
           LD B,A
           JR SV45

SV4:       DEC DE
           LD B,(HL)         ;BYTE TO SAVE
           EX AF,AF'
           XOR B
           EX AF,AF'         ;PARITY

SV45:      LD A,&F7
           IN A,(STATPORT)
           AND &20
           SCF
           RET Z             ;RET IF ESC KEY HIT - CY

           INC HL
           LD A,H
           CP &C0
           IN A,(251)
           INC A             ;READY IN CASE PASSED BFFF
           JR C,SV5          ;JR IF OK (ADDR HASN'T PASSED BFFF YET)

           LD H,&80
           OUT (251),A       ;NEXT PAGE

SV5:       LD A,B
           EXX

           LD E,A            ;NEXT BYTE TO SAVE
           LD A,C            ;ORIG DELAY, MINUS 2
           INC B             ;B=1
           SUB 17            ;COMP FOR EXTRA TIME TAKEN GETTING NEXT BYTE
           JR C,SV6          ;USE B=1 IF DELAY COUNTER CARRIED

           INC A             ;ENSURE NOT ZERO
           LD B,A            ;DELAY 182 Ts LESS
           SCF               ;SHOWS BYTE ALL SENT WHEN ROTATED OUT.

SV6:       RL E
           JR SVDL2          ;ABOUT 187 EXTRA TO HANDLE THIS BYTE

SABYTES:   CALL SABLK
           CCF               ;NOW CY=OK
           JR SVLDCOM

LDBYTES:   CALL LDBLK

SVLDCOM:   EI
           EX AF,AF'         ;NC IF ERROR
           LD A,(BORDCOL)
           OUT (KEYPORT),A
           CALL BRKCR        ;CHECK BREAK, STOP IF REQUIRED
           EX AF,AF'
           RET               ;C IF OK


;LOAD CDE BYTES TO HL FROM NET. TYPE ON STACK

WNH:       POP AF
           LD B,A
           EX AF,AF'         ;CY IF LOAD
           LD A,B

WNHL:      PUSH AF
           CALL CKNET        ;WAIT FOR FREE NET

WTNI:      CALL NMIN         ;WAIT FOR A BYTE
           JR NC,WTNI

           LD B,A
           POP AF
           CP B
           JR NZ,WNHL        ;WAIT FOR HDR OR DATA MARKER

           LD IX,NISR
           CALL NIXR

;NET PARITY CHECK

           CALL NMIN

NERR:      JP NC,TERROR

           EXX
           XOR H
           EXX

           CP 1
           RET

;NET OUT SR. OUTPUTS THE BYTE AT (HL), INCLUDES IN PARITY

NOSR:      LD A,(HL)
           CALL NMOUT
           JR NTVL

;NET INPUT SR. LOAD OR VERIFY NET BYTE WITH (HL), INCLUDE IN PARITY

NISR:      CALL NMIN
           JR NC,NERR

           EX AF,AF'
           JR NC,NTV         ;JR IF VERIFYING

           EX AF,AF'
           LD (HL),A         ;LOAD BYTE
           JR NTVL

NTV:       EX AF,AF'
           CP (HL)           ;VERIFY BYTE
           JR NZ,NERR

NTVL:      EXX
           XOR H
           LD H,A            ;PARITY BYTE
           EXX

           RET

;ENTRY: HL=DEST TO LOAD DATA TO, CDE=LEN TO SAVE (PGFORM), A=TYPE (CHECKED VS
;FIRST BYTE ON TAPE). 01=HEADER, FF=DATA. (IF TAPE TYPE=ZX HEADER, 17 BYTES
;WILL BE LOADED

;EXIT: CY IF LOADED OK, NC IF ERROR

LDBLK:     DI
           PUSH AF
           CALL TCHK
           JR NZ,WNH

           POP AF
           CALL CDENORM      ;CONVERT CDE TO 19-BIT
           LD (TEMPW1),BC    ;SAVE C (64K BLOCKS)
           LD (TEMPW2),HL    ;DEST ADDR
           INC C             ;NZ
           EX AF,AF'         ;NZ=FIRST BYTE, NC=VERIFY, CY=LOAD
           LD A,8
           OUT (KEYPORT),A   ;ENSURE MIC BIT STARTS OFF OR WE CANNOT READ EAR!
                             ;INIT EDGE TYPE. BORDER WILL GO WHITE

LDERR:     CALL BRKTST
           RET Z             ;RET IF ESC PRESSED - NC

LDSTRT:    LD B,8
           CALL EDGE2        ;LOOK FOR ALTERED EAR SIGNAL
           JR NC,LDERR       ;LOOP IF TIMEOUT OR ESC

           CALL EDGE2
           JR NC,LDERR

           EXX
           LD L,A
           LD B,0
           EXX

           LD L,0            ;LOOK AT 256 SAMPLES

;A SIGNAL HAS BEEN FOUND - SEE IF LEADER

LDLDR:     CALL EDGE2       ;LOOK FOR TWO EDGES
           JR NC,LDERR      ;JR IF BREAK OR TIMEOUT

           EXX
           LD H,B            ;HL=AV. B=0
           LD C,L            ;BC=AV
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL         ;*16
           SBC HL,BC         ;*15
           LD C,A            ;BC=SAMPLE
           ADD HL,BC         ;*15+NEW SAMPLE
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL
           ADD HL,HL         ;H=NEW AV (HL/16)
           LD L,H            ;KEEP RUNNING AVERAGE OF PULSE WIDTH IN L
           LD A,L
           SUB C             ;LAST PULSE WIDTH
           JR NC,BLWAV

           NEG               ;GET ABS DIFF FROM AV.

BLWAV:     ADD A,A
           ADD A,A
           CP L              ;4*ABS DIFF FROM AVERAGE SHOULD BE LESS THAN AV.
           EXX               ;(+/-25%)

           JR NC,LDSTRT

           DEC L
           JR NZ,LDLDR       ;LOOK FOR 256 LEADER PULSES
                             ;L ENDS AS ZERO - PARITY BYTE INIT STATE.
           LD A,B
           AND &F8
           OR &02
           LD B,A            ;RED BORDER NOW

           EXX
           LD A,L
           SRL A
           LD B,A
           SRL A
           ADC A,L           ;A=1.25*AV LDR PULSE LEN
           LD E,A            ;E'=MAX LEN FOR 'LONG' (HI) BIT
           LD D,E
           DEC D
           DEC D             ;FIDDLE A BIT TO CENTRALIZE..
           SRL D             ;D'=HALF THAT - SHORT/LONG DECISION VALUE
           LD A,B
           ADD A,L
           LD BC,(TEMPW1-1)
           INC B             ;B'=64K BLOCKS, PLUS 1
           EXX

           LD H,A
           SRL H             ;0.75*AV

;NOTE: WAITING FOR SYNC THIS WAY ENSURES BOTH HALVES OF ALL PULSES KEPT TOGETHER
;WHATEVER POLARITY OF SIGNAL, AS WELL AS SHOWING START OF DATA

WTSYNC:    LD C,0
           CALL EDGSENS
           CP H              ;CP 1.50*AV HALF-CYCLE LEN
           JR NC,LDSTRT      ;ERROR IF TOO LONG (>0.75*AV)

           ADD A,A           ;2*HALF-CYCLE
           CP H              ;CP 1.50*AV HALF-CYCLE LEN
           JR NC,WTSYNC      ;LOOP UNTIL FIRST HALF OF SYNC PULSE*2<1.50*AV
                             ;HALF CYCLE. IE WAIT UNTIL 0.75 OR LESS OF AV.
           CALL EDGSENS      ;C IS CARRIED IN AS START VALUE
           CP H              ;A=TIME FOR WHOLE POSSIBLE SYNC PULSE
           JR NC,WTSYNC      ;INSIST WHOLE SYNC PULSE<0.5*AV WHOLE CYCLE

           LD A,B
           XOR 3
           LD B,A            ;NEW BORDER COLOURS ARE BLUE AND YELLOW
           EXX
           LD HL,(TEMPW2)    ;DEST PTR
           EXX
           JR LDSTART        ;JUMP TO LOAD TYPE BYTE

LDTYPE:    RL C              ;SAVE CY
           INC H
           DEC H
           JR NZ,LDTCP       ;JR IF NOT TYPE 0 (ZX HEADER)

           INC H             ;NOW TYPE=1 (SAM HEADER)
           LD E,17           ;LEN=ZX HEADER LEN

LDTCP:     XOR H             ;SEE IF TYPE FLAG A' MATCHES TYPE BYTE LOADED
           RET NZ            ;RET IF NOT - NC, NZ

           LD A,C
           RRA               ;GET CY BACK. CAN'T USE RR C - CHANGES Z
           EX AF,AF'
           JR LDSTART

LDLOOP:    EXX

LDDE:      EX AF,AF'
           LD A,H
           EXX
           JR C,LDNVER

LDVERIF:   XOR (HL)
           RET NZ            ;RET IF MATCH FAILED - NC,NZ

           DB &3E            ;"JR+1"

LDNVER:    LD (HL),A         ;STORE LOADED BYTE

LDNEXT:    EX AF,AF'         ;PROTECT FLAGS
           INC HL            ;INC DEST PTR
           LD A,H
           CP &C0
           IN A,(251)
           INC A
           JR C,LDDEC        ;JR IF NOT PAST BFFFH

           LD H,&80
           OUT (251),A       ;NEXT PAGE

LDDEC:     EXX
           DEC DE            ;DEC BYTE COUNT

LDSTART:   LD H,1            ;MARKER BIT SET IN DEST SHIFT REG
           LD C,3            ;COMP FOR TIME LOST BY HANDLING BYTE

LDBITS:    CALL EDGEC
           RET NC            ;RET IF TIMEOUT OR SPACE PRESSED

           EXX
           CP E
           RET NC            ;RET IF TOO LONG

           CP D
           CCF               ;NC IF SHORTER THAN 'DECISION' REGISTER
           EXX

           RL H              ;ACCUMULATE BITS IN H
           LD C,0
           JR NC,LDBITS      ;LOOP FOR ALL 8 BITS (TILL THE MARKER ROTATED OUT)

           LD A,L            ;PARITY BYTE
           XOR H             ;MODIFIED
           LD L,A            ;WITH NEW DATA

           EX AF,AF'
           JR NZ,LDTYPE      ;NO DEC B IF TYPE BYTE

           EX AF,AF'
           LD A,E
           OR D
           JR NZ,LDDE        ;LOOP TO LOAD DE BYTES

           EXX
           DJNZ LDLOOP
           EXX

           LD A,L            ;PARITY
           CP 1              ;CY SET IF OK (ZERO)
           RET


;CHECK IF NET BUSY

CKNET:     PUSH HL

CKNT1:     LD H,4

CKNT2:     CALL BRKCR
           IN A,(VIDPORT)
           RLA
           JR NC,CKNT1       ;LOOP TILL FREE

           DEC HL
           LD A,H
           OR L
           JR NZ,CKNT2       ;ENSURE FREE FOR A WHILE

           POP HL
           RET


;NET/MIDI IN. GETS BYTE IN A (CY) OR NC AND A=0 IF NO BYTE

NMIN:      PUSH HL
           LD HL,300

NMIN1:     DEC HL
           LD A,H
           OR L
           JR Z,NMIN3

           CALL BRKCR
           IN A,(STATPORT)
           BIT 2,A
           JR NZ,NMIN1

NMIN2:     IN A,(STATPORT)
           BIT 2,A
           JR Z,NMIN2

           IN A,(MDIPORT)
           SCF

NMIN3:     POP HL
           RET


NIXR:      EXX
           LD H,A            ;PARITY BYTE
           EXX

           RES 7,D
           LD A,C            ;16K BLOCKS
           AND A
           JR Z,NIXJ

NIXL:      PUSH AF
           PUSH DE
           LD DE,&4000       ;DO 16K
           CALL NIXJ
           POP DE
           POP AF
           DEC A
           JR NZ,NIXL

;NET SAVE/LOAD/VERIFY 0-16K BYTES (DE BYTES FROM HL)

NIXJ:      LD A,D
           OR E
           RET Z

           LD A,H
           CP &C0
           CALL NC,INCURPAGE ;** BUG FIX AND RE-WRITE
           CALL IXJUMP       ;INPUT OR OUTPUT
           INC HL
           DEC DE
           JR NIXJ

;          INCLUDE USING.SAM      ;INSTR, LENGTH, STRING$, XOINTERS
;USING.SAM
;POINTERS
;ENTRY: HL=LOCN (PAGED IN), CDE=ADJUSTMENT, CY IF SUBTRACT
;EXIT: PAGCOUNT/MODCOUNT=BLOCK SIZE TO MOVE, AHL=OLD WKEND

; XOI3:      LD B,3
 ;         LD IY,NUMENDP
  ;        JR X31

XOINTERS:  LD B,14           ;14 SYS VARS TO DO
           LD IY,SAVARSP     ;FIRST SYS VAR TO CONSIDER

X31:       EX AF,AF'         ;CY'=ADD/SUB FLAG
           LD (TEMPW4),BC
           LD (TEMPW5),DE
           EX DE,HL
           IN A,(251)
           AND &1F
           LD C,A
           BIT 6,D
           JR Z,PNT1

           INC C
           RES 6,D           ;MAKE LOCN IN SECTION C

PNT1:    ;  PUSH BC
;           PUSH DE           ;ADJUSTED LOCN
           LD A,(WKENDP)
           LD HL,(WKEND)
           BIT 6,H
           JR Z,PNT15

           INC A
           RES 6,H

PNT15:     PUSH AF           ;SAVE ORIG WKEND (END OF BLOCK TO MOVE)
           PUSH HL
           IN A,(251)
           PUSH AF
           CALL ADDRNV
           PUSH HL
           CALL PNLP         ;DO B SYS VARS
           LD A,C
           POP BC
           LD HL,(NVARS)
           AND A
           SBC HL,BC
           CALL NZ,SADJ      ;IF NVARS HAVE MOVED, PROGRAM HAS ALTERED, SO
                             ;CHECK ADDRESSES ON GOSUB/DO/PROC STACK.
                             ;NOTE: DELETE OF 16K EXACTLY WILL BE MISSED..
           LD C,A
           POP AF
           OUT (251),A
           LD A,(ELINEP)
           CALL SMBW         ;MAKE WORKSP AND
                             ;WKEND SAME BASE PAGE AS ELINE
           LD L,A
           LD A,(CLA+1)
           AND A
           LD A,L
           LD L,CHADP\256
           CALL Z,SMBS       ;IF RUNNING ELINE, MAKE CHAD SAME BASE AS ELINE

           POP HL
           POP AF            ;AHL=OLD WKEND
;           POP DE
 ;          POP BC            ;CDE=ORIG LOCN
           PUSH AF
           PUSH HL           ;OLD WORKEND
           CALL SUBAHLCDE    ;AHL=BLOCK SIZE TO MOVE IF MAKEROOM
           EX AF,AF'
           JR NC,PNBS        ;JR IF MAKEROOM

           EX AF,AF'
           LD BC,(TEMPW4)
           LD DE,(TEMPW5)
           CALL SUBAHLCDE    ;SUBTRACT BLOCK SIZE IF RECLAIM
           EX AF,AF'

PNBS:      EX AF,AF'
           RES 7,H
           LD (PAGCOUNT),A
           INC HL            ;ONE EXTRA (MODCOUNT MAY BE 4000H NOW)
           LD (MODCOUNT),HL
           POP HL
           POP AF            ;AHL=OLD WKEND
           RET


SMBW:      LD HL,WORKSPP
           CALL SMBS
           LD L,WKENDP\256
           CALL SMBS
           LD L,KCURP\256

SMBS:      PUSH AF
           XOR (HL)
           AND &1F
           JR Z,SMBS2

           DEC (HL)          ;IF WORKSPACE IS ON PAGE ABOVE, ADJUST
                             ;TO SAME BASE AS ELINE
           INC HL
           INC HL
           SET 6,(HL)

SMBS2:     POP AF
           RET

;STACK ADJUST
;80H=DO, 40H=PROC, 00=GOSUB

SADJ:      PUSH BC           ;OLD (STILL CORRECT!) NVARS
           LD C,A            ;CDE=LOCN
           LD HL,(BSTKEND)

SADJL:     LD A,(HL)         ;TYPE/PAGE
           CP &FF
           JR NZ,SADJ2

           POP HL            ;NVARS
           PUSH DE
           LD (TEMPW3),DE
           LD D,C
           EX AF,AF'
           CALL R1OFFCL
           DW AFLPS          ;ADJUST FOR-NEXT LOOPS
           EX AF,AF'
           POP DE
           LD A,C
           RET

SADJ2:     PUSH AF           ;SAVE B BITS 7-5 OF PAGE
           PUSH HL
           CALL ASSV         ;ADJUST SINGLE "SYS VAR"
           POP HL
           POP AF
           AND &E0
           OR (HL)
           LD (HL),A         ;KEEP TYPE BITS 7-5
           INC HL            ;SKIP PAGE
           INC HL
           INC HL            ;SKIP OFFSET
           INC HL            ;SKIP STAT
           AND &E0           ;ISOLATE TYPE BITS
           CP &40
           JR NZ,SADJL       ;JR IF NOT PROC

FPTLP:     LD A,(HL)
           INC HL
           OR (HL)
           JR NZ,FPTLP

           INC HL
           JR SADJL        ;LOOP WHEN PROC DOUBLE ZERO TERMINATOR FOUND



;SEND BYTE IN 'A' TO PRINTER

SNDA2:     PUSH BC
           PUSH AF
           LD BC,(LPTPRT1)   ;C=CONTROL PORT, B=1

SENDLP:    CALL BRKCR        ;STOP IF BREAK PRESSED
           IN A,(C)
           RRCA              ;TEST BIT 0
           JR C,SENDLP       ;LOOP TILL NOT BUSY

           DEC C
           POP AF
           OUT (C),A         ;DATA TO DATA PORT
           INC C
           OUT (C),B         ;STROBE SIGNAL TO CONTROL PORT
           DEC B
           OUT (C),B         ;CANCEL STROBE PULSE (ABOUT 2.6 USECS)
           POP BC
           RET

;HEAP ROOM
;ENTRY: BC=BYTES TO RESERVE (IF +VE) OR BYTES TO RELEASE (IF -VE)
;EXIT: DE=OLD HEAPEND (ROOM START). RELEASE OF >=HEAP SIZE MAKES IT EMPTY.
;E.G. LD BC,0C000H:CALL HEAPRM WILL MAKE HEAP MT.
;HL=NEW HEAPEND (ROOM+1). CAN BE CALLED WITH BC=0. NC INDICATES NOT ENOUGH
;ROOM. (HL=DEGREE OF OVERFLOW, 0+ BYTES). BC IS PRESERVED.

HEAPROOM:  LD HL,(HEAPEND)   ;(4200H TO ABOUT 4A00H)
           ADD HL,BC
           LD A,H
           CP &40
           JR NC,HEAPR2      ;JR IF HEAP NOT EMPTY AFTER ADJUSTMENT

           LD HL,(HPST)      ;EMPTY HEAP
           JR HEAPR3

HEAPR2:    LD DE,(BSTKEND)
           SBC HL,DE
           RET NC            ;RET IF NEW HEAPEND WOULD BE >=BSTKEND

           ADD HL,DE

HEAPR3:    LD DE,(HEAPEND)
           LD (HEAPEND),HL
           RET

;USING.SAM. USING AND INARRAY/INSTRING, LENGTH, STRING$
;*******************************************************************************
;INSTRING FUNCTION - E.G. PRINT INSTR(2,S$,T$) OR INSTR(S$,T$)


IMINSTR:      CALL SINSISOBRK     ;'('
              CALL EXPTEXPR       ;EXITS WITH Z IF $, NZ IF NUM, C IF RUNNING
              JR NZ,INSTR2        ;JR IF FOUND NUMBER FOR SEARCH START

              JR NC,INSTR3        ;AVOID STACKING DEFAULT OF 1 IF SYNTAX CHK

              DB CALC             ;S$
              DB STKONE           ;S$,1
              DB SWOP             ;1,S$
              DB EXIT

              JR INSTR3

INSTR2:       CALL EXPTCSTR        ;COMMA, SEARCH$

INSTR3:       CALL EXPTCSTRB      ;COMMA, TARGET$, ')'
              RET NC              ;DON'T RET HERE IF NOT RUNNING

              IN A,(URPORT)
              PUSH AF

;FETCH TARGET$, COPY TO PAGE 0 BUFFER IF LENGTH 1-255,
;FETCH SEARCH$. GET DE=S$ ST, BC=S$ LEN, A=T$ LEN, NC. S$ PAGED IN

              CALL SBFSR          ;COPY $ ON FPCS TO INSTBUF
                                  ;INV ARG IF T$ LEN >255. A=LEN, NC ON EXIT
              PUSH AF             ;T$ LEN, NC
              CALL GETSTRING      ;S$ ST TO DE, LEN TO BC, PAGE IN
              PUSH DE             ;S$ ST
              PUSH BC             ;S$ LEN
              CALL GETINT         ;START TO BC. A=C
              OR B
              JP Z,SWER2          ;ERROR IF POSN=0

              LD A,(INSTHASH)

              EXX
              LD C,A              ;C'=HASH OR EQUIVALENT
              EXX

              DEC  BC             ;POSN >=0
              POP HL              ;S$ LEN
              POP DE              ;S$ ST
              POP AF              ;T$ LEN
              CALL INARRAYEN
              POP AF
              JP OSBC             ;OUT (URPORT),A: JP STACKBC
            ;  OUT (URPORT),A
             ; JP STACKBC

INARRAYEN:    PUSH BC             ;POSN
              LD C,A              ;A=T$ LEN
              LD B,0              ;BC=T$ LEN
                                  ;DE=S$ START
                                  ;HL=S$ LEN
                                  ;STACK=POSN
              AND A
              JP Z,NOTFND2        ;NOT FOUND IF T$ LEN=0

              SBC HL,BC           ;SBC S$ LEN,T$ LEN
              POP BC              ;POSN
              JR C,NOTFND3H       ;NOT FOUND IF TARGET$ LEN > SEARCH$ LEN

              INC HL
              SBC HL,BC           ;SUB START POSN

NOTFND3H:     JP C,NOTFND3        ;JR IF START POSN TOO FAR UP SEARCH$

              EX DE,HL
              INC DE              ;DE=BYTES TO CHECK
              EX AF,AF'
              ADD HL,BC           ;MODIFY START-OF-SEARCH PTR NOW IN HL
              CALL C,PGOVERF      ;IF OVERFLOW, GET HL IN 8000-BFFF AREA

INSTBKLP:     CALL CHKHL          ;IF NEEDED, GET HL IN 8000-BFFF AREA
              LD A,D
              CP &3F
              JR C,MINSR          ;JR IF OK FOR A SEARCH WITHOUT OVERFLOW

              PUSH DE             ;LEN >=3F00
              LD DE,&3EFF
              CALL MINSR          ;SEARCH 3EFF BYTES
              JR NC,JUNKS         ;IF FOUND, JUNK PREV LEN, NC. BC=POSN

;              POP DE              ;JUNK PREVIOUS LEN
 ;             RET                 ;FOUND - BC=POSN FOUND, NC

              EX DE,HL            ;ELSE A'=T$ LEN
                                  ;DE=S$ PTR, HL=START POSN
              LD BC,&3EFF
              ADD HL,BC           ;INCR START POSN FOR NEW SEARCH
              EX (SP),HL          ;HL=PREV. LEN, (SP)=START POSN
              SBC HL,BC
              EX DE,HL            ;DE=REMAINING LEN TO SEARCH, HL=S$ PTR
              POP BC              ;START POSN
              JR INSTBKLP

;ENTRY: A'=T$ LEN, HL=S$ PTR, DE=BYTES TO SEARCH, BC=START POSN

MINSR:        EX AF,AF'
              PUSH AF
              LD (BCSTORE),BC
              CALL R1OFFCL
              DW R0INST

JUNKS:        EX AF,AF'
              POP AF
              EX AF,AF'
              RET

;E.G. LENGTH(1,A$) OR LENGTH(2,B())

IMLENGTH:  CALL SINSISOBRK
           CALL EXPT1NUM
           CALL INSISCOMA
           CALL R1OFFCL
           DW LENGSR         ;SETS  BIT 6,(FLAGS) FOR NUM/STR
           JP Z,VNFERR       ;ERROR IF NOT FOUND IN RUNTIME

           RST &18
           CALL EXCBRF       ;INSIST ON A$() OR XXX()
           EX AF,AF'         ;CY IF RUNNING
           BIT 5,C
           JR Z,IMLEN2       ;JR IF NOT NUMERIC ARRAY

           RST &18
           CALL EXCBRF       ;INSIST ON E.G. (1,AL() )
           RET NC            ;RET IF SYNTAX TIME

           JR IMLEN3

;E.G. ALPHA OR ASD$

IMLEN2:    EX AF,AF'
           RET NC            ;RET IF SYNTAX TIME

           JP P,IMLEN3       ;JR IF STRING VAR

           CALL GETBYTE
           AND A
           JR NZ,IMLERR

           LD HL,(MEMVAL)    ;ADDR OF NUMERIC VALUE

IMLENC:    LD  A,(MEMVAL+2)
           LD B,A
           JP ASBHL          ;ADJUST BHL TO REL PAGE, STACK

IMLEN3:    PUSH BC           ;C=T/L
           CALL GETBYTE
           POP BC
           LD HL,MEMVAL+3    ;PTR TO LEN DATA
           PUSH AF

;ENTRY: C=TYPE BYTE, HL PTS TO HEADER DATA
;EXIT: HL PTS TO START OF TEXT, DE=EL LEN,
;BC=NO OF ELS. SIMPLE STRINGS HAVE EL LEN OF 1.

           LD A,C
           AND &60
           LD A,(HL)
           INC HL
           LD C,(HL)
           INC HL
           JR NZ,ASSAR4      ;JR IF ARRAY

           RRCA              ;A=PAGES OF SIMPLE STRING LEN
           RRCA
           OR (HL)
           LD B,A            ;BC=STRING LEN ('EL NUMBERS')

ASSAR3:    LD DE,1           ;DE='ELEMENT' LEN
           JR ASSAR5

ASSAR4:    INC HL
           LD A,(HL)         ;DIMS
           INC HL
           LD C,(HL)
           INC HL
           LD B,(HL)
           DEC A
           JR Z,ASSAR3       ;IF DIMS=1, USE BC AS EL. NOS, 1 AS EL LEN

           INC HL            ;IF DIMS=2, DE IS LOADED WITH EL. LEN
           LD E,(HL)
           INC HL
           LD D,(HL)

ASSAR5:    LD A,L
           SUB (MEMVAL+2)\256 ;GET BYTES FROM DIMS TO TEXT
           LD HL,(MEMVAL)
           ADD A,L
           LD L,A
           JR NC,ASSAR6

           INC H

 ; HL=ARRAY ST, DE=EL. LEN, BC=EL NOS

ASSAR6:    POP AF
           AND A
           JR Z,IMLENC

           DEC A
           JP Z,STACKBC

           EX DE,HL
           DEC A
           JP Z,STACKHL

IMLERR:    RST &08
           DB 30             ;IOOR

;*******************************************************************************
;STRING$(N,A$)

IMSTRINGS: CALL EXBNCSB      ;(N,$)
           RET NC            ;RET IF SYNTAX TIME

           DB CALC           ;N,$
           DB STOD0          ;N
           DB DUP            ;N,N
           DB RCL0           ;N,N,$
           DB DUP            ;N,N,$,$
           DB LEN            ;N,N,$, LEN $
           DB SWOP23         ;N,$,N, LEN $
           DB MULT           ;N,$,RESULT LEN
           DB EXIT

           CALL GETINT
           OR B
           JR Z,STRINGSN     ;JR IF RESULT LEN ZERO

           LD A,B
           CP 2
           JP NC,STLERR      ;LIMIT LEN TO <512 CHARS TO FIT BUFFER

           PUSH BC           ;RESULT LEN
           CALL SBUFFET      ;COPY $ TO BUFFER, ERROR IF LEN >255. BC=LEN
           PUSH BC           ;$ LEN
           PUSH DE           ;BUFFER START
           CALL GETBYTE      ;N IN A
           POP HL            ;BUFFER START
           LD D,H
           LD E,L
           POP BC            ;$ LEN

STRSL:     PUSH BC
           PUSH HL
           LDIR              ;MAKE REPEATED COPIES FROM BUFFER START
                             ;(FIRST ONE ON TOP OF ITSELF!)
           POP HL
           POP BC
           DEC A
           JR NZ,STRSL

           POP BC            ;RESULT LEN
           JP CWKSTK         ;COPY RESULT TO WKSPACE AND STACK PARAMS.

;NULL STRING RESULT IF EG STRING$(0,"AA") OR STRING$(10,"")
;BC=0

STRINGSN:  DB CALC           ;N,$
           DB DROP           ;N
           DB DROP           ;
           DB EXIT

           JP STACKBC

;CIRCLE/FILL SR. UNSTACKS COORDS TO B,C (NC) OR FIDDLED COORDS IN BC (CY)
; AND TEMPW1 IS SET UP AS OFFSET TO X COORD IF THIN PIX.

CIFILSR:   CALL R1OFFCL      ;v2.6
           DW  GTFCOORDS     ;Y COORD IN B, X IN C, OR X IN HL AND CY IF THIN
           JR C,CIFISR2      ;JR IF THINPIX

           LD A,(CURCMD)
           LD HL,MODE
           ADD A,(HL)
           SUB &EB+2         ;FILLTOK+2
           SCF
           CCF               ;NC
           RET NZ            ;RET UNLESS: MODE 2, FATPIX, FILL
                             ;(CUR CMD MUST BE 9A,9D OR EB)

           LD L,C
           LD H,A
           ADD HL,HL         ;X=X*2. (ALWAYS USE THIN PIX SYSTEM FOR FILL)

;HL=X, B=Y

CIFISR2:   LD A,H
           AND A
           LD A,L
           JR NZ,THINC2

;X IS <=00FF
           CP &80
           JR C,THINC3      ;IF X IS <80H, JR, USE L (X LSB) AS X, ADD HL OF 0

           JR THINC4

;X>=0100H
THINC2:    CP &80
           JR C,THINC4       ;IF X>017FH, NO JR, USE L AS X, ADD HL OF 0100H

;X>017FH
THINC3:    LD C,L
           LD L,0
           JR THINC5

;X IS BETWEEN 80H AND 017FH

THINC4:    LD DE,&80
           LD C,E            ;PRETEND CENTRE X IS 128
           AND A
           SBC HL,DE         ;HL=0-FF=DISP TO ADD TO 80H CENTRE TO GET REAL CRD

THINC5:    LD (TEMPW1),HL
           SCF               ;"THINPIX"
           RET

;PIXEL ROLL/SCROLL SR

CRBBFN:    PUSH DE
           PUSH HL
           LD B,A
           LD DE,&672C       ;2ND BYTE OF RRD/INC L
           DEC C
           JR NZ,CRBB2       ;JR IF MOVE RIGHT

           LD DE,&6F2D       ;2ND BYTE OF RLD/DEC L

CRBB2:     LD A,&ED          ;1ST BYTE OF RLD OR RRD
           LD HL,CDBUFF

CRBBL:     LD (HL),A
           INC HL
           LD (HL),D
           INC HL
           LD (HL),E
           INC HL
           DJNZ CRBBL

           LD (HL),&C9       ;"RET"
           POP HL
           POP DE
           RET

CRTBF:     PUSH BC
           DEC C
           LD C,&A8
           JR NZ,CRTB2       ;JR IF LDD WANTED

           DB &0E            ;"JR+1"

CRTBFI:    PUSH BC

CRTB1:     LD C,&A0          ;ELSE LDI

CRTB2:     PUSH HL
           LD B,A
           LD A,&ED
           LD HL,CDBUFF

CRTBL:     LD (HL),A
           INC HL
           LD (HL),C
           INC HL
           DJNZ CRTBL

           LD (HL),&C9       ;"RET"
           POP HL
           POP BC
           RET

;DRCURVE

;DRAW TO X,Y,Z. MEM0 HOLDS Z, REGS HOLD FIDDLED COORDS (NOW DISPLACEMENTS).
;PUT COORDS BACK ON STACK, REPLACE Z.
;ENTRY: B=Y DIFF, C (OR HL IF THIN)=X DIFF, D=SGN Y, E=SGN X (01/FF)

DRTCRV:    LD A,(THFATT)
           AND A             ;Z IF THIN
           LD A,E            ;SGN X
           NEG
           LD E,B
           PUSH DE           ;SGN Y, Y DIFF
           EX DE,HL
           JR Z,DRT2         ;JR IF THIN PIX - DE=X DIFF

           LD D,0
           LD E,C            ;DE=X DIFF

DRT2:      LD HL,(STKEND)
           CALL STORADE      ;FIDDLE SGN AND PUT DE ON FPCS
           INC HL
           INC HL            ;PT TO NEXT NUMBER AREA ON FPCS
           POP DE            ;SGN Y, Y DIFF
           LD A,D
           LD D,0
           CALL STORADE
           INC HL
           INC HL
           LD (STKEND),HL

           DB CALC
           DB RCL0           ;GET CURVATURE BACK
           DB EXIT

DRCURVE:   DB CALC           ;X,Y,-Z
           DB NEGATE         ;X,Y,Z (REVERSE ANGLE SO CURVES IN RIGHT DIRECTION)
           DB STO5           ;X,Y,Z (M5=Z)
           DB STKHALF        ;X,Y,Z,0.5
           DB MULT           ;X,Y,Z/2
           DB SIN            ;X,Y,SIN(Z/2)
           DB DUP            ;X,Y,SIN(Z/2),SIN(Z/2)
           DB NOT            ;X,Y,SIN(Z/2),1/0
           DB JPTRUE        ;JP IF APPROX. A STRAIGHT LINE, DROPEX
DRHLB:     DB DROPEX-DRHLB

           DB STOD0          ;X,Y  (M0=SIN(Z/2)
           DB NEGATE         ;X,Y  (REVERSED BECAUSE OF INVERSE Y AXIS)
           DB SWOP           ;Y,X
           DB DUP            ;Y,X,X
           DB ABS            ;Y,X,ABS X
           DB SWOP           ;Y,ABS X,X
           DB SWOP13         ;X,ABS X,Y
           DB DUP            ;X,ABS X,Y,Y
           DB ABS            ;X,ABS X,Y,ABS Y
           DB SWOP23         ;X,Y,ABS X,ABS Y
           DB ADDN           ;X,Y,ABS X+ABS Y
           DB RCL0           ;X,Y,ABS X+ABS Y,SIN(Z/2)
           DB DIVN           ;X,Y,(ABS X+ABS Y)/SIN(Z/2)
           DB ABS            ;X,Y,FF
           DB RCL0           ;X,Y,FF,SIN(Z/2)
           DB SWOP           ;X,Y,SIN(Z/2),FF
           DB DUP            ;X,Y,SIN(Z/2),FF,FF
           DB STKFONE        ;X,Y,SIN(Z/2),FF,FF,1
           DB SUBN           ;X,Y,SIN(Z/2),FF,FF-1
           DB GRTE0          ;X,Y,SIN(Z/2),FF,1/0 (1 IF FF>=1)
           DB JPTRUE         ;JP IF NOT A STRAIGHT LINE, DRCURV3
           DB &07

           DB DROP           ;X,Y,SIN(Z/2)

DROPEX:    DB DROP           ;X,Y
           DB EXIT

           JP LINEDRAW

DRCURV3:   DB DUP            ;X,Y,SIN(Z/2),FF,FF
           DB SQR            ;X,Y,SIN(Z/2),FF,SQR FF
           DB ONELIT
           DB &02
           DB SWOP           ;"     "     ,FF,2,SQR FF
           DB DIVN           ;"     "     ,FF,2/SQR FF
           DB RCL5           ;"     "     ,FF,2/SQR FF,Z
           DB SWOP           ;"     "     ,FF,Z,2/SQR FF
           DB DIVN           ;            ,FF,Z*SQR FF/2
           DB ABS            ;            ,FF,ABS(Z*SQR FF/2)
           DB EXIT

           CALL FPTOA
           LD B,&FC
           JR C,DRCURV4      ;JR IF TOO BIG

           AND B             ;A=00-FC
           ADD A,4           ;A=04-00H
           JR Z,DRCURV4      ;JR IF TOO BIG

           LD B,A

DRCURV4:   PUSH BC           ;ARCS IN B

           DB CALC           ;            ,FF
           DB RCL5           ;            ,FF,Z
           DB STKBREG        ;            ,FF,Z,ARCS
           DB DIVN           ;            ,FF,Z/ARCS
           DB DUP            ;            ,FF,Z/ARCS,Z/ARCS
           DB SIN            ;            ,FF,Z/ARCS,SIN(Z/ARCS)
           DB STOD4          ;            ,FF,Z/ARCS
           DB DUP            ;            ,FF,Z/ARCS,Z/ARCS
           DB STKHALF        ;            ,FF,Z/ARCS,Z/ARCS,0.5
           DB MULT           ;            ,FF,Z/ARCS,Z/2*ARCS
           DB SIN            ;            ,FF,Z/ARCS,SIN(Z/2*ARCS)
           DB STO1           ;            ,FF,Z/ARCS,SIN(Z/2*ARCS)
           DB SWOP           ;            ,FF,SIN(Z/2*ARCS),Z/ARCS
           DB STOD0          ;            ,FF,SIN(Z/2*ARCS)
           DB DUP            ;            ,FF,SIN(Z/2*ARCS),SIN(Z/2*ARCS)
           DB MULT           ;            ,FF,SIN(Z/2*ARCS)*SIN(Z/2*ARCS)
           DB STKHALF        ;            ,FF,SIN(Z/2*ARCS)*SIN(Z/2*ARCS),0.5
           DB DIVN           ;            ,FF,SIN(Z/2*ARCS)*SIN(Z/2*ARCS)*2
           DB STKFONE        ;            ,FF,SIN(Z/2*ARCS)*SIN(Z/2*ARCS)*2,1
           DB SWOP           ;            ,FF,1,SIN(Z/2*ARCS)*SIN(Z/2*ARCS)*2
           DB SUBN           ;            ,FF,1-SIN(Z/2*ARCS)*SIN(Z/2*ARCS)*2
           DB STOD3          ;            ,FF

           DB DROP           ;X,Y,SIN(Z/2)
           DB RCL1           ;X,Y,SIN(Z/2),SIN(Z/2*ARCS)
           DB SWOP           ;X,Y,SIN(Z/2*ARCS),SIN(Z/2)
           DB DIVN           ;X,Y,SIN(Z/2)/SIN(Z/2*ARCS) (CALL IT V)
           DB STOD1          ;X,Y (M1=V)
           DB SWOP           ;Y,X
           DB DUP            ;Y,X,X
           DB RCL1           ;Y,X,X,V
           DB MULT           ;Y,X,X*V
           DB STOD2          ;Y,X            (M2=X*V)
           DB SWOP           ;X,Y
           DB DUP            ;X,Y,Y
           DB RCL1           ;X,Y,Y,V
           DB MULT           ;X,Y,Y*V
           DB STOD1          ;X,Y            (M1=Y*V)
           DB RCL5           ;X,Y,Z
           DB RCL0           ;X,Y,Z,Z/A
           DB SUBN           ;X,Y,Z-Z/A
           DB STKHALF        ;X,Y,Z-Z/A,0.5
           DB MULT           ;X,Y,(Z-Z/A)/2 (CALL IT T)
           DB DUP            ;X,Y,T,T
           DB SIN            ;X,Y,T,SIN T
           DB STO5           ;X,Y,T,SIN T    (M5=SIN T)
           DB SWOP           ;X,Y,SIN T,T
           DB COS            ;X,Y,SIN T,COS T
           DB STOD0          ;X,Y,SIN T      (M0=COS T)
           DB RCL1           ;X,Y,SIN T,Y*V
           DB MULT           ;X,Y,SIN T*Y*V
           DB RCL0           ;X,Y,SIN T*Y*V,COS T
           DB RCL2           ;X,Y,SIN T*Y*V,COS T,X*V
           DB MULT           ;X,Y,SIN T*Y*V,COS T*X*V
           DB ADDN           ;X,Y,SIN T*Y*V+COS T*X*V (CALL IT P)
           DB RCL1           ;X,Y,P,Y*V
           DB SWOP           ;X,Y,Y*V,P
           DB STOD1          ;X,Y,Y*V        (M1=P)
           DB RCL0           ;X,Y,Y*V,COS T
           DB MULT           ;X,Y,Y*V*COS T
           DB RCL5           ;X,Y,Y*V*COS T,SIN T
           DB RCL2           ;X,Y,Y*V*COS T,SIN T,X*V
           DB MULT           ;X,Y,Y*V*COS T,SIN T*X*V
           DB SUBN           ;X,Y,Y*V*COS T-SIN T*X*V (CALL IT J)
           DB STO2           ;X,Y,J
           DB ABS            ;X,Y,ABS J
           DB RCL1           ;X,Y,ABS J,P
           DB ABS            ;X,Y,ABS J,ABS P
           DB ADDN           ;X,Y,ABS J+ABS P
           DB DROP           ;X,Y
           DB EXIT           ;(DE)=EXP OF ABS J+ABS P

           POP BC
           LD A,(DE)
           CP &81
           JP C,LINEDRAW

           DB CALC
           DB SWOP           ;Y,X
           DB LKADDRW
           DW XCOORD         ;Y,X,XCOORD
           DB STO0           ;Y,X,XCOORD
           DB ADDN           ;Y,X+XCOORD
           DB SWOP           ;X+XCOORD,Y
           DB LKADDRB
           DW YCOORD         ;X+XCOORD,Y,YCOORD
           DB STO5
           DB ADDN           ;X+XCOORD,Y+YCOORD
           DB RCL0           ;X+XCOORD,Y+YCOORD,XCOORD
           DB RCL5           ;X+XCOORD,Y+YCOORD,XCOORD,YCOORD (END/START COORDS)
           DB EXIT

           DJNZ CUENTRY

           JR CURVEND

CURVLP:    DB CALC
           DB RCL1           ;PREV X INC
           DB DUP
           DB RCL3
           DB MULT
           DB RCL4
           DB RCL2           ;PREV Y INC
           DB MULT
           DB SUBN
           DB STOD1          ;NEW X INC
           DB RCL4
           DB MULT
           DB RCL3
           DB RCL2
           DB MULT
           DB ADDN
           DB STOD2          ;NEW Y INC
           DB EXIT

CUENTRY:   DB CALC
           DB STOD0
           DB RCL1           ;X INC
           DB ADDN
           DB DUP
           DB LKADDRW
           DW XCOORD         ;PEEK X COORD
           DB SUBN
           DB RCL2           ;Y INC
           DB RCL0
           DB ADDN
           DB STO0
           DB SWOP
           DB LKADDRB
           DW YCOORD         ;PEEK Y COORD
           DB RCL0
           DB SUBN
           DB EXIT

           PUSH BC
           CALL R1OFFCL
           DW DRAWFD         ;DRAW A LINE USING DISPS. ON FPCS, WITH XRG/YRG
           POP BC            ;ADJUSTMENTS
           DJNZ CURVLP

CURVEND:   DB CALC
           DB DROP
           DB DROP
           DB SWOP
           DB LKADDRW
           DW XCOORD
           DB SUBN
           DB SWOP
           DB LKADDRB
           DW YCOORD
           DB SWOP
           DB SUBN
           DB EXIT

LINEDRAW:  CALL R1OFFCL
           DW DRAWFD
           JP TRCURP

;          INCLUDE MISC31.SAM      ;CALL, BORDER, ZOOM ETC,
;MISC31.SAM -  CALL, BGRAPHICS, KEY, STRM16, NEW


;'CALL' CMD

CALLER:    CALL EXPT1NUM     ;GET ADDR
           LD C,0            ;PARAMS COUNTER TO ZERO

FCALERLP:  CALL RCRC         ;RST 18H, CRCOLON
           JR Z,FCALERCE     ;EXIT LOOP IF CR OR ':'

           CALL INSISCOMA
           PUSH BC
           CALL EXPTEXPR     ;Z=STR, NZ=NUM, CY IF RUNNING. (BIT 7,A GAVE Z/NZ)
           POP BC
           INC C
           JR NC,FCALERLP

   ;        RLA               ;NC=STR, CY=NUMB
    ;       SBC A,A           ;STR=00, NUM=FF BUG**A IS CHAR BY THIS TIME
     ;      INC A             ;STR=01, NUM=00
           LD A,(FLAGS)
           LD B,A            ;NOW STACK EXPR AND TYPE UNDER ADDR
                             ;C IS SAVED

           DB CALC           ;ADDR,EXPR
           DB SWOP           ;EXPR,ADDR
           DB STKBREG        ;EXPR,ADDR,TYPE
           DB SWOP           ;EXPR,TYPE,ADDR
           DB EXIT

           JR FCALERLP

FCALERCE:  LD A,C
           LD (TEMPB3),A
           CALL ABORTER

           CALL R1OFFJP
           DW CALLX


;CREATE ERROR, STAT, LINO

SETUPVARS: LD A,(ERRNR)
           LD DE,ERVT        ;PTR TO NAME
           CALL CRTVAR2
           LD HL,(PPC)
           LD DE,ERVT+6
           CALL CRTVAR3
           LD A,(SUBPPC)
           LD DE,ERVT+11

CRTVAR2:   LD H,0
           LD L,A

CRTVAR3:   PUSH DE           ;PTR
           CALL STACKHL
           POP HL
           LD DE,TLBYTE
           LD A,(HL)         ;TLBYTE FOR SEARCH
           LD BC,6           ;ENOUGH FOR 'ERROR' VAR
           LDIR
           CALL R1OFFJP
           DW CRTVAR4


ERVT:      DB 4
           DM "error"
           DB 3
           DM "lino"
           DB 3
           DM "stat"


MNINIT:    XOR A
           LD I,A
           IM 1

RMPS:      LD BC,CLUTPORT
           LD D,A
           ADD A,A
           ADD A,A
           ADD A,A
           OUT (C),A         ;SET COLOUR 0
           LD A,D
           OUT (URPORT),A
           LD HL,&8000
           LD DE,&8001
           LD BC,&3FFF
           LD (HL),L
           LDIR              ;CLEAR A PAGE
           LD HL,&8000
           INC B             ;BC=0100
           LD E,&40

RMCK:      LD (HL),&FF
           LD D,(HL)
           INC D
           JR NZ,RAMEX       ;CHECK ALL BITS CAN BE ONES

           LD (HL),D         ;CHECK CAN BE ZEROED
           LD D,(HL)
           INC D
           DEC D
           JR NZ,RAMEX       ;CHECK HOLDS ONE

           ADD HL,BC
           DEC E
           JR NZ,RMCK

           INC A
           CP &20
           JR C,RMPS

           LD A,&FE
           IN A,(&FE)
           RRA
           LD A,&10          ;256K
           JR NC,RAMEX       ;FORCE 256K SYSTEM IF SHIFT PRESSED

           ADD A,A           ;20H=512K

RAMEX:     LD B,A
           DEC A
           LD E,A
           LD (PRAMTP),A     ;PHYSICAL RAMTOP PAGE (USUALLY 0F OR 1F)
           OUT (VIDPORT),A   ;ANY NZ VAL STOPS SYS VARS APPEARING AS ATTR
           LD SP,ISPVAL
           LD HL,ALLOCT
           PUSH HL

ATIF:      LD (HL),0         ;'FREE'
           INC HL
           DJNZ ATIF

           SUB &21
           CPL               ;IF PRAMTP WAS 0F, A=11H; IF 1F, A=01
           LD B,A

ATIX:      LD (HL),&FF       ;'NON-EXISTENT/TERMINATOR'
           INC HL
           DJNZ ATIX         ;FILL REST OF TABLE WITH FF'S

           POP HL
           LD A,&40          ;'IN USE, CONTEXT 0'
           LD B,4            ;PAGES TO RESERVE

ATIU:      LD (HL),A         ;'USED BY CONTEXT A'
           INC HL
           DJNZ ATIU

           LD A,L
           DEC A
           LD (LASTPAGE),A   ;LAST PAGE USED BY BASIC
           LD (RAMTOPP),A    ;RAMTOP PAGE

           LD L,E
           DEC L             ;HL PTS TO SCREEN PAGES IN ALLOCT
           LD A,L
           OR &60            ;SCREEN PAGE=LAST POSSIBLE PAIR, MODE=3, MIDI
                             ;BIT LOW (INACTIVE)
           LD (FISCRNP),A
           LD A,&C0          ;'SCREEN'
           LD (HL),A
           INC HL
           LD (HL),A
           LD HL,&BFFF
           LD (RAMTOP),HL

           LD HL,KSRC
           LD DE,KTAB+1
           LD C,70*3
           LDIR              ;INIT MAIN KEYBOARD TABLES

           EX DE,HL          ;DE PTS TO TABLE OF VALUES AND DISPS TO NEXT
                             ;DEST, ENDING IN ZERO
           LD HL,KTAB+238    ;DEST FOR BRIGHT CC
           CALL PBSL         ;B SHOULD BE ZERO ON ENTRY. EXITS UNCHANGED

           LD HL,&5CB6+31+&4000
           LD (PROG),HL

           LD DE,&5CB6
           LD (CHANS),DE
           LD HL,CHANTAB
           LD C,31
           LDIR              ;INIT 6 CHANNELS

           LD HL,DKSRC
           LD DE,DKBU
           LD C,DKEN-DKSRC+1
           LDIR              ;INIT DEF KEYS

   ;       LD HL,CHIT
           LD DE,LNCUR
           LD C,18
           LDIR              ;INIT FIRST 18 BYTES OF SYS VARS

      ;    LD HL,MAIT
           LD DE,BASSTK
           LD C,26
           LDIR              ;13 IMPORTANT ADDRESSES INITED

           LD HL,NMISTOP
           LD (NMIV),HL

           LD HL,ANYI
           LD (ANYIV),HL

           CALL UPACK        ;UNPACK CHAR SET
           LD HL,CHARSVAL-256
           LD (CHARS),HL
           LD HL,CHARSVAL+896
           LD (UDG),HL
           JR NEW2

NEW:       CALL CHKEND
           DI

NEW2:      LD HL,SCLIST
           LD (SCPTR),HL
           DEC HL            ;PT TO FISCRNP
           LD A,(HL)
           LD (CUSCRNP),A
           OUT (VIDPORT),A
           LD B,16

SCLI:      INC HL
           LD (HL),A
           LD A,&FF          ;'CLOSED'
           DJNZ SCLI

           LD A,(PRAMTP)
           DEC A
           DEC A             ;SKIP PAST SCREEN 1
           LD L,A
           LD H,ALLOCT/256

CSPL:      LD A,(HL)
           CP &C0
           JR NZ,DCSP        ;JR IF NOT A SCREEN PAGE

           LD (HL),B         ;CLOSE SCREEN PAGE

DCSP:      DEC L
           JR NZ,CSPL

           LD C,L
           LD HL,STREAMS-4
           LD DE,STRMTAB     ;MUST BE IN ROM0!
           LD B,9            ;INITIALISE 9 STREAMS

STRIL:     LD A,(DE)
           INC DE
           LD (HL),A
           INC HL
           LD (HL),C
           INC HL
           DJNZ STRIL

           LD B,24           ;12 MORE STREAM PTRS TO ZAP

CLSTL:     LD (HL),C
           INC HL
           DJNZ CLSTL

           CALL ADDRPROG
           LD (HL),&FF       ;PROGRAM TERMINATOR
           INC HL
           LD (NVARS),HL
           LD (NVARSP),A
           LD (ELINEP),A
           CALL RESTOREZ
           LD HL,&0321
           LD (REPDEL),HL    ;REPDEL=33, REPPER=3
           LD HL,MEMVAL
           LD (MEM),HL
           LD A,H
           LD (RASP),A
           LD (SPEEDIC),A    ;ANY NON-ZERO VALUE WILL DO
           LD (THFATT),A     ;TEMP FAT
           XOR A
           LD (THFATP),A     ;PERM THIN
           LD (MODE),A       ;NOT MODE 3 SO XRG NOT HALVED
           CALL CLRSR        ;CLEAR FPCS, BASIC STACK, NVARS, SAVARS
           LD HL,(SAVARS)
           INC HL
           LD (ELINE),HL
           CALL SETMIN
           LD A,3
           CALL MODET        ;SET MODE, CSIZE, WINDOWS
           CALL CLSHS2
           LD SP,ISPVAL
           LD HL,MAINER
           PUSH HL
           LD (ERRSP),SP

;RAINBOW SCREEN

           LD DE,PALTAB+1
           LD HL,LINICOLS    ;L=0
           LD B,L            ;INIT SCAN NUMBER IN B
           LD C,L

RBOWL:     LD (HL),B
           INC HL
           LD (HL),C         ;PAL MEM ZERO
           INC HL
           LD A,(DE)
           INC DE
           LD (HL),A
           INC HL
           LD (HL),A         ;ALT COLOUR=MAIN
           INC HL
           LD A,B
           ADD A,11
           LD B,A            ;NEXT SCAN TO ALTER AT
           CP 166
           JR C,RBOWL

           LD (HL),&FF

           RST &08
           DB &50            ;COPYRIGHT MSG


;UPACK - CALLED BY INITIALIZATION ROUTINE
;UPACK CHARSET FROM 5-BIT TO 8-BIT WITH 2 ZEROS AT LHS, 1 AT RHS. MAKE BOTTOM
;SCAN ZERO EXCEPT IN 13 CASES DEALT WITH SEPARATELY.
;CHAR DEFS. THIS ROUTINE TAKES 101 BYTES, WHEREAS A NORMAL LDIR WOULD TAKE 11.
;NET GAIN: 402 BYTES (NOTE:OUT OF DATE NOW FOREIGN SET DROPPED!)

UPACK:     LD HL,99*256+7    ;H COUNTS 99 CHARS, L COUNTS 7 BYTES/CHAR
           EXX
           LD HL,CHARSRC
           LD DE,CHARSVAL
           XOR A
           LD B,5            ;5 BITS TO UNPACK

UPKGC:     LD C,(HL)
           INC HL
           SCF               ;AFTER FIRST PASS, C ROTATES IN NC. WHEN C=0, LAST
                             ;VALID DATA BIT HAS GONE, CY=JUNK (SET)
UPKBL:     RL C
           JR Z,UPKGC        ;GET NEXT DATA BYTE IF C USED UP

           RLA
           DJNZ UPKBL        ;GET 5 BITS IN 'A' REG

           RLCA              ;CENTRE DATA.
           LD (DE),A
           INC DE
           XOR A             ;NC, A=0
           LD B,5            ;GET 5 BITS
           EXX
           DEC L
           EXX
           JR NZ,UPKBL       ;LOOP FOR 7 BYTES/CHAR

           LD (DE),A         ;8TH BYTE IS ZERO
           INC DE

           EXX
           LD L,7
           DEC H
           EXX
           JR NZ,UPKBL       ;LOOP FOR 137 CHARS

           LD HL,95*8+CHARSVAL+1  ;PT TO SECOND BYTE OF COPYRIGHT SIGN
                                   ;(FIRST OF 5 WHICH NEED BIT 6 SET)
SB5L:      SET 6,(HL)
           INC HL
           DJNZ SB5L               ;DO 5 BYTES

;NOW PATCH CHARS WHERE BOTTOM SCAN IS USED

           LD DE,U8TAB
           LD HL,CHARSVAL+103 ;SCAN 7 OF COMMA

;CALLED TO UNPACK CONTROL KEY VALUES

PBSL:      LD A,(DE)         ;BYTE TO PLACE
           INC DE
           LD (HL),A         ;TO DEST
           LD A,(DE)         ;DISP TO NEXT DEST, OR 0
           INC DE
           LD C,A            ;(B=0)
           ADD HL,BC         ;PT HL TO NEXT DEST
           AND A
           JR NZ,PBSL        ;LOOP TILL TERMINATOR HIT

           RET

;CLS #

CLSHS:     CALL SABORTER

;CALLED BY NEW

CLSHS2:    CALL STREAMFE     ;'S'
           LD BC,&0510

CLHSL:     LD A,B
           ADD A,C
           RST &10           ;PRINT CHR$ 15H/14H/13H/12H/11H
           XOR A
           RST &10           ;OVER/INVERSE/BRIGHT/FLASH/PAPER 0
           DJNZ CLHSL

           LD A,C
           RST &10           ;CHR$ 10H - PEN
           LD A,7
           RST &10           ;PEN 7
           CALL PER3         ;COPY TEMP EFFECTS OF COLOUR CODES TO PERMS.
 ;         CALL ZBCI
;          JP MCLS

;ZBCI:      XOR A
           XOR A
           CALL SETBORD
           CALL COLINIT
           JP MCLS

;COLOUR.SAM
;E.G. PALETTE I,C
;     PALETTE I,B,C
;     PALETTE I,C LINE L or COLOUR I,B,C LINE L
;     PALETTE I LINE L=DELETE CHANGE OF I AT LINE L
;     PALETTE   CLEARS ALL INTERRUPT CHANGES, RE-INITS PAL MEMORIES

;I=LOGICAL INK NUMBER (PALETTE MEMORY) 0-15.
;C IS A COLOUR NUMBER FROM 0-127. B AND C ARE 2 SUCH COLOURS TO ALTERNATE UNDER
;INTERRUPT CONTROL. VALUES ARE SIMPLY ENTERED INTO TWO TABLES USED BY THE
;FRAME INTERRUPT TO SET UP THE PALETTE 50 TIMES/SEC. IF TABLES MATCH, NO
;INKS FLASH, OTHERWISE FLASH HAPPENS AFTER (SPEEDINK) INTS.
;IF 'LINE L' IS USED, THE COLOUR(S) WILL ONLY BE SET FROM START OF SPECIFIED
;SCAN LINE (ACTUALLY RHS BORDER OF PRECEDING LINE). LINE CAN BE 174 TO -16.
;=SCANS 1-191. GIVES INT AT SCANS 0-190 (ACTUALLY END OF PRECEDING LINE), AND
;COLOUR CHANGE AT SCANS 1-191
;UP TO 127 CHANGES CAN BE MADE PER SCREEN

COLOUR:      CALL CRCOLON
             JR NZ,COLOUR1             ;JR UNLESS JUST 'PALETTE'

             CALL CHKEND

COLINIT:     LD A,&FF
             LD (LINICOLS),A          ;CLEAR INTERRUPT COL CHNG LIST
             LD DE,PALTAB
             CALL COLINIT1            ;DO IT TWICE
             CALL COLINIT1
             LD A,(MODE)
             CP 2
             RET NZ

PALSW:     LD DE,PALTAB      ;IF CHANGING TO MODE 2, SAVE NON-MODE-2 PALTAB 0-3
           LD HL,PALTAB+16   ;TO STORE, AND GET BACK MODE 2 PALTAB 0-3
           CALL PL4S         ;SWOP MAIN COLOURS. EXIT WITH HL=PALTAB+20
           LD DE,PALTAB+36

PL4S:      LD B,4
           JP FPSWOPLP     ;SWOP ALTERNATE COLOURS

COLINIT1:    LD BC,20
             LD HL,INITCOLS
             LDIR
             RET

COLOUR1:     CALL EXPT1NUM             ;I
             CP LINETOK
             JR NZ,COLOUR5

             CALL SSYNTAX6             ;L OF 'PALETTE I LINE L'

             CALL COLATSR
             PUSH AF                   ;LINE
             LD DE,&1000+23            ;LIMIT OF 16, INKVALERR
             CALL LIMBYTE              ;I
             POP DE                    ;D=LINE
             LD E,A                    ;E=I
             LD HL,LINICOLS

COLDELP:     LD A,(HL)
             INC HL
             CP D
             JR Z,COLDEL2              ;EXIT IF FOUND RIGHT SCAN ENTRY

             RET NC                    ;RET IF PAST ANY ENTRIES FOR LINE D

COLDEL1:     INC HL
             INC HL
             INC HL
             JR COLDELP

COLDEL2:     LD A,(HL)
             CP E
             JR NZ,COLDEL1             ;JR IF WRONG I

             LD D,H                    ;ELSE DELETE ENTRY
             LD E,L
             DEC DE                    ;DE PTS TO LINE VALUE
             INC HL
             INC HL
             INC HL                    ;HL PTS TO LINE VALUE OF NEXT ENTRY
             PUSH HL
             CALL FLITD                ;GET LEN TO TABLE END
             POP HL
             DI
             LDIR                      ;DELETE ENTRY. IF LINIPTR PTS BEFORE
             EI                        ;DELETED ENTRY, NO PROBLEM. IF PTS TO
             RET                       ;

INKVALERR:   RST &08
             DB 23                     ;'Invalid colour'

COLOUR5:     CALL EXPTCNUM             ;,C OF 'PALETTE I,C....'
             CP ","
             JR Z,COLOURFL             ;GET THIRD PARAM IF THERE IS ONE

             CP LINETOK
             JR NZ,COLSING             ;JR IF 'PALETTE I,C'

             CALL SSYNTAX6             ;LINE OF 'PALETTE I,C LINE L

             CALL COLATSR
             JR COLOUR10

COLSING:     CALL CHKEND

             LD A,&FF

COLOUR10:    PUSH AF                   ;NUL LINE
             LD DE,&8000+24            ;LIMIT TO <128
             CALL LIMBYTE              ;GET SINGLE COLOUR
             PUSH AF                   ;STACK IT AS THE 'SECOND' COLOUR TOO
             JR COLOUR2                ;FPCS=I, (SP)=COL, (SP+2)=LINE, A=COL

COLOURFL:    CALL SEXPT1NUM            ;SECOND COLOUR
             CP LINETOK
             JR Z,COLATL

             CALL CHKEND

             LD A,&FF                  ;NUL LINE
             PUSH AF
             JR COLOUR15               ;FPCS=I,B,C. (SP)=LINE

COLATL:      CALL SSYNTAX6             ;LINE

COLATL2:     CALL COLATSR
             PUSH AF                   ;LINE

COLOUR15:    LD DE,&8000+24            ;LIMIT TO <128
             CALL LIMBYTE              ;GET SECOND COLOUR TO A

             PUSH AF                   ;SECOND COLOUR
             CALL LIMBYTE              ;FIRST COLOUR

COLOUR2:     PUSH AF                   ;FIRST COLOUR
             LD DE,&1000+23            ;LIMIT TO <16
             CALL LIMBYTE              ;PALETTE ENTRY (I)

             LD E,A                    ;E=I
             POP BC                    ;B=FIRST COLOUR
             POP AF
             LD C,A                    ;C=SECOND
             POP AF                    ;LINE

;A=LINE (FF IF NONE), LETTE ENTRY

JPALET:      CP &FF
             JR NZ,COLRLINE

             LD HL,PALTAB              ;PT TO PALETTE TABLE
             LD D,0
             ADD HL,DE
             LD (HL),B                 ;FIRST COLOUR
             LD E,20
             ADD HL,DE                 ;POINT TO ALTERNATE PALETTE TABLE
             LD (HL),C                 ;SECOND COLOUR (OFTEN THE SAME)
             RET

COLFULERR:   RST &08
             DB 25                     ;'Too many palette changes'

COLRLINE:    LD HL,LINICOLS
             LD D,A                    ;D=LINE

COLRLP:      LD A,(HL)
             INC HL
             CP D
             JR NC,COLRL2              ;JR IF WE FOUND END (FF) OR LINE>=L

COLRLP2:     INC HL
             INC HL
             INC HL
             JR COLRLP

COLRL2:      JR NZ,COLRL3              ;JR IF LINE HAS NO ENTRIES ALREADY

             LD A,(HL)
             CP E                      ;CP I
             JR NZ,COLRLP2             ;JR IF LINE DOES NOT CHANGE THIS I
                                       ;ELSE OVERWRITE ENTRY

             DI                        ;(IN CASE INTERRUPT COLOUR SWOP OCCURS)
             JR LD2COL

;WE NEED TO OPEN 4 BYTES AT (HL-1) - MIGHT BE TERMINATOR POSN

COLRL3:      DEC HL
             PUSH BC                   ;COLOURS
             PUSH DE                   ;LINE, I
             PUSH HL                   ;LINE OR TERMINATOR POSN
             CALL FLITE                ;GET HL=TABLE END, BC=LEN
             INC BC
             INC BC
             INC BC
             INC BC
             LD A,B
             ADD A,&FE
             JR C,COLFULERR            ;ERROR IF LIST WITH NEW ENTRY WOULD BE
                                       ;MORE THAN 01FFH LONG
             POP DE                    ;LOCN FOR NEW ENTRY
             PUSH HL
             SBC HL,DE                 ;GET TERMINATOR-LOCN
             LD B,H
             LD C,L
             INC BC                    ;ALLOW FOR INCLUSIVE BYTE=LEN TO MOVE
             POP DE                    ;TERMINATOR
             LD HL,4
             ADD HL,DE
             EX DE,HL                  ;DE=TERMINATOR+4, HL=TERMINATOR
             DI
             LDDR
             INC HL                    ;PT TO 4 BYTE SPACE
             POP DE
             POP BC
             LD (HL),D                 ;LINE
             INC HL
             LD (HL),E                 ;I

LD2COL:      INC HL
             LD (HL),B
             INC HL
             LD (HL),C
             EI
             RET



;FIND LINE INT TABLE END. EXIT WITH BC=TABLE LEN, HL=END.

FLITE:       LD HL,LINICOLS

;FIND LINE INT TABLE DISP. EXIT WITH BC=DISP TO TERMINATOR FROM ENTRY HL,+1.

FLITD:       LD BC,1

FLITL:       LD A,(HL)
             INC A
             RET Z

             INC HL
             INC HL
             INC HL
             INC HL
             INC BC
             INC BC
             INC BC
             INC BC
             JR FLITL

;GET LINE FROM TOP OF FPCS AS 0-191 FROM BASIC'S 175 TO -16

COLATSR:     DB CALC
             DB DUP                    ;L,L SO COORDFID CAN BE USED
             DB EXIT

             CALL COORDFID
             CALL USYCOORD             ;GETS Y AS 0 TO 191 (175 TO -16)
             PUSH AF                   ;LINE
             CALL FDELETE              ;JUNK DUMMY X
             POP AF                    ;A=LINE
             SUB 1
             RET NC                    ;RET UNLESS A WAS ZERO

             RST &08
             DB 30                     ;IOOR
                                       ;COLOUR CHANGE AT LINE 175 NOT POS.
                                       ;0-190 FOR ORIG 174 TO -16
                                       ;EG 1 GIVES INT AT END OF SCAN 0, COLOUR
                                       ;CHANGE AT END OF SCAN 1.

                                 ;RECORD, FATPIX, CSIZE, WINDOW,
;          INCLUDE MISC32.SAM    ;BEEP
;MISC32.SAM

BEEP:      CALL SYNTAX8

           DB CALC           ;LENGTH,NOTE
           DB ONELIT
           DB 27             ;L,N,27
           DB ADDN           ;L,N+27
           DB ONELIT
           DB 12
           DB DIVN           ;L,(N+27)/12
           DB POWR2          ;L,2^(N+27)/12
           DB ONELIT
           DB 55
           DB MULT           ;L,FREQUENCY
           DB DUP            ;L,F,F
           DB SWOP13         ;F,F,L
           DB RESTACK        ;F,F,L (FP FORM)
           DB EXIT

           LD A,(HL)         ;L EXPONENT
           CP &85            ;**
           JR C,BEEP2        ;ALLOW DURATION UP TO 16 SECS

           RST &08
           DB 50             ;'note too long'

BEEP2:     LD BC,-5
           ADD HL,BC
           LD A,(HL)         ;F EXPONENT
           CP &84
           JR C,INVNOTE

           CP &8F
           JR C,BEEP3        ;ALLOW FREQUENCIES OF 8Hz TO 16KHz.

INVNOTE:   RST &08
           DB 49             ;'Invalid note'

BEEP3:     DB CALC           ;F,F,L
           DB MULT           ;F,F*L=CYCLES
           DB SWOP           ;CY,F
           DB FIVELIT
           DB &93,&37
           DB &1B,0,0        ;CY,F,375000=8T UNITS IN A 1HZ HALF-CYCLE
           DB SWOP           ;CY,375000,F
           DB DIVN           ;F,375000/F=8T UNITS PER HALF-CYCLE
           DB ONELIT
           DB 15
           DB SUBN           ;ALLOW FOR TIME TAKEN BY LOOP EVEN IF NIL 8T UNITS
                             ;(15*8=120 TS)
           DB EXIT

           CALL GETINT
           PUSH BC
           CALL GETINT
           EX DE,HL          ;DE=CYCLES (ALSO, BC=DE=BA)
           POP HL            ;HL=8 T UNITS
           OR B
           RET Z             ;RET IF NONE TO DO

           DEC DE            ;DE=0 GIVES 1 CYCLE

;ENTRY: DE=CYCLES TO DO, MINUS 1
;       HL=8T UNITS PER HALF-CYCLE (ON ENTRY, H=2048 Ts, L=8 Ts)
;TAKES 118 TS EVEN IF HL=0, CONTENTION OF 'OUT' MAKES THAT 120 TS

BEEPP2:    DI
           PUSH BC
           LD BC,BEEPLP
           SRL L             ;L=16T UNITS NOW
           JR C,BEEPER2      ;USE A LOOP 8 TS LONGER IF L WAS ODD

           INC BC
           INC BC

BEEPER2:   PUSH BC
           POP IX            ;IX IS LOOPING ADDR
           LD A,(BORDCOL)    ;BITS=STI01GRB
                             ;(SOFF/THRO MIDI/INTENSITY/0/MIC/GRB)
           OR &18            ;SPKR BIT HI (ON), MIC BIT HI (OFF)
           JR BPLENT         ;JUMP INTO LOOP - PULSE SPEAKER OFF

BEEPLP:    LD B,B
           LD B,B

;ENTER HERE (IX) IF SHORTER LOOP

           INC C
           INC B             ;INC IN CASE B OR C=0

BPTMLP:    DEC B
           JR NZ,BPTMLP      ;EACH INNER LOOP=16 TS

           LD B,127          ;OUTER LOOP TAKES 32 TS. 127 GIVES 126*16+32=2048
           DEC C
           JP NZ,BPTMLP

BPLENT:    XOR &10           ;REVERSE BIT 4
           OUT (&FE),A       ;PULSE SPEAKER
           LD B,A            ;SAVE A FOR LATER
           LD C,H
           BIT 4,A
           JR NZ,BEEPR4      ;JR IF JUST DONE FIRST HALF-CYCLE

           LD A,D
           OR E
           JR Z,BEEPR5       ;END IF DONE ALL CYCLES

           DEC DE

BEEPR3:    LD A,B
           LD B,L
           JP (IX)

BEEPR4:    LD A,B            ;DELAY 4TS SO BOTH PATHS TAKE THE SAME TIME
           JR BEEPR3

BEEPR5:    POP BC
           EI
           RET


ZAP:       CALL CHKEND

           LD B,6

ZPL:       PUSH BC
           LD BC,2
           LD E,1
           LD A,30
           CALL PAF
           DI
           POP BC
           DJNZ ZPL

           EI
           RET


BOOM:      CALL CHKEND

           LD E,1
           LD BC,12
           JR ZPC

ZOOM:      CALL CHKEND

           LD E,6
           LD BC,65533

ZPC:       LD A,78

PAF:       LD L,255
           PUSH AF

           LD H,0
           LD D,H

SAD:       EXX
           POP BC

SELP:      EXX
           PUSH DE
           PUSH HL
           CALL BEEPP2
           DI
           POP HL
           POP DE
           ADD HL,BC
           EXX
           DJNZ SELP

           EXX
           EI
           RET

POW:       CALL CHKEND
           EX DE,HL
           LD B,0

PWLP:      LD A,(DE)
           LD L,A
           LD H,0
           INC DE
           PUSH DE
           LD DE,1
           CALL BEEPP2
           DI
           POP DE
           DJNZ PWLP

           EI
           RET

BGRAPHICS: CALL SYNTAX6

           LD DE,&0200+30    ;LIMIT TO <2 OR IOOR
           CALL LIMBYTE

           DEC A
           LD (BGFLG),A      ;0 IF USE BLOCKS, FF IF USE UDGS
           RET               ;(BGRAPHICS 1=USE BLOCKS, 0=USE UDGS)

;KEY POSN,VALUE

KEY:       CALL SYNTAX8

           CALL GETBYTE
           PUSH AF
           CALL GETINT
           POP AF
           LD HL,-281
           ADD HL,BC
           JP C,IOORERR      ;LIMIT POSN TO 0-280 (0 NOT USED)

           LD HL,(KBTAB)
           ADD HL,BC
           LD (HL),A
           RET


;SELECT SAVE/LOAD DEVICE E.G. DEVICE M: DEVICE T: DEVICE N: DEVICE M2
;DEVICE T45 SETS SPEED=45

SLDEVICE:  CALL GETALPH
           AND &DF           ;FORCE UPPER CASE
           PUSH AF
           RST &20
           CALL FETCHNUM     ;NUMBER OR USE 0
           POP DE            ;LETTER
           CALL CHKEND

           PUSH DE
           CALL GETBYTE      ;IN C
           POP AF            ;LETTER
           CP "N"
           JR Z,DEVI3        ;IF NET, USE NUMBER OR DEFAULT TO 0

           CP "T"
           JR NZ,DEVI2

           INC C
           DEC C
           JR NZ,DEVI3

           LD C,TSPEED       ;DEFAULT TAPE SPEED

DEVI2:     INC C
           DEC C
           JR NZ,DEVI3

           INC C             ;DEFAULT TO 1 IF DISC

DEVI3:     LD HL,PSLD
           LD (HL),A         ;LETTER
           INC HL
           LD (HL),C         ;DRIVE/STATION/SPEED
           RET


PAUSE:     CALL SYNTAX3

           CALL GETINT
           LD E,7            ;BLITZ CODE FOR 'PAUSE'
           CALL GRAREC       ;USE PAUSE MOD 256 AS PARAM (C)

PAU1:      CALL KBFLUSH      ;(HL=FLAGS)
           HALT
           CALL BRKCR        ;CHECK BREAK, STOP IF SO
           LD A,(LASTSTAT)   ;STATPORT VALUE ON LAST INTERRUPT
           AND 8
           JR NZ,PAU1        ;JR IF IT WASN'T A FRAME INTERRUPT

           LD A,B
           OR C
           JR Z,PAU2         ;DON'T DEC BC IF PARAM WAS ZERO

           DEC BC
           LD A,B
           OR C
           RET Z             ;RET IF COUNTED TO ZERO

PAU2:      BIT 5,(HL)
           JR Z,PAU1         ;LOOP IF NO KEY PRESSED

           RES 5,(HL)        ;'NO KEY'
           RET


PRCOITEM2:    LD B,D                 ;B ALSO IS PARAM
              SUB 16
              JP Z,COINK

              DEC A
              JP Z,COPAPER

              DEC A
              JR Z,COFLASH

              DEC A
              JR Z,COBRIGHT

              DEC A
              JR NZ,COOVER

COINVERSE:    LD C,4                 ;MASK FOR BIT 2 - INVERSE
              LD A,D
              CP 2
              JR NC,INVCOLERR        ;ALLOW INVERSE 0 OR 1 ONLY

              DEC A
              CPL                    ;0/1 ->00/FF
              LD (INVERT),A
              LD A,D
              RLCA
              RLCA
              LD B,A                 ;PARAM BIT TO BIT 2
              JR COINOVC

COOVER:       LD C,1                 ;MASK FOR BIT 0 - OVER
              LD A,D                 ;CHECK ORIG PARAM FOR 0/1
              CP 4
              JR NC,INVCOLERR        ;OVER 0/1/2/3 ALLOWED

              LD E,4                 ;BLITZ CODE FOR 'OVER'
              PUSH BC
              LD C,A
              PUSH AF
              CALL GRAREC
              POP AF
              POP BC
              LD (GOVERT),A          ;GRAPHICS OVER IS 0-3
              CP 2
              RET NC                 ;NO FURTHER ACTION IF OVER 2 OR 3

              LD (OVERT),A
              LD A,B

COINOVC:      LD HL,PFLAGT
              JP COCHNG              ;ADD MODIFIED PARAM TO PFLAG

COBRIGHT:     LD C,&40               ;MASK FOR BIT 6 - BRIGHT
              LD A,(MODE)
              CP 2
              LD A,D                 ;PARAM
              JR Z,COBRI2

              CP 2
              JR NC,COBRI2           ;JR IF BRIGHT 8

              AND A
              LD A,(M23PAPT)
              LD E,A
              LD A,(M23INKT)
              JR Z,COBRI1            ;JR IF BRIGHT 0

              OR &88                 ;ADD 8 TO INK
              PUSH AF
              LD A,E
              OR &88                 ;AND PAPER, IF <8
              JR COBRI15

COBRI1:       AND &77
              PUSH AF
              LD A,E
              AND &77

COBRI15:      LD (M23PAPT),A
              POP AF
              LD (M23INKT),A
              LD A,D

COBRI2:       RRCA                   ;PARAM 0/1 ENDS IN BIT 6...
              JR COBRFLC

COFLASH:      LD C,&80               ;MASK FOR BIT 7 - FLASH
              LD A,D                 ;PARAM

COBRFLC:      RRCA                   ;PARAM 0/1 TO BIT 7 (OR 6 IF FLASH)
              LD B,A                 ;MODIFIED PARAM
              LD A,D
              CP 16
              JR NZ,COBFC2           ;ALLOW ORIG PARAM OF 0/1, OR 8/16=TRANSP

              RRCA                   ;A=8
              RRC B                  ;ADJ B TOO

COBFC2:       CP 8
              JR Z,COFBOK

              CP 2
              JR C,COFBOK

INVCOLERR:    RST &08
              DB 23

COFBOK:       LD HL,ATTRT
              LD A,B
              CALL COCHNG            ;ADD FLASH 0/1 TO ATTRT
              LD A,B
              RRCA
              RRCA
              RRCA                   ;FLASH/BRIGHT 8 MOVED TO CORRECT BIT FOR
              JR COCHNG              ;ADDING TO MASKT

COINK:        LD C,7                 ;MASK FOR INK
              JR CINKPAPC

COPAPER:      LD C,&38               ;MASK FOR PAPER
              LD A,D
              RLCA
              RLCA
              RLCA
              LD B,A                 ;GET PARAM BITS IN PLACE FOR PAPER

CINKPAPC:     LD HL,ATTRT
              LD A,D                 ;PARAM
              CP 16
              JR NC,CINKPAP0

              RLCA
              RLCA
              RLCA
              RLCA
              OR D                   ;A=2 COPIES OF PARAM BITS 3-0
              LD E,A                 ;MODE 3 INK/PAP
              RLCA
              JR NC,CONFBRI          ;JR IF NO NEED TO FORCE BRIGHT 1 (COL<8)

              SET 6,(HL)             ;SET BRIGHT BIT IN ATTRT FOR COLOURS 8-15

CONFBRI:      LD A,(MODE)
              CP 2
              LD A,E
              JR NZ,COIPM3

              RLCA
              RLCA                   ;BITS 5,4 AND 1,0 TO 7,6 AND 4,3
              XOR E
              AND &CC                ;KEEP BITS 7,6,4,3 OF A
              XOR E                  ;A=4 COPIES OF PARAM BITS 1,0 IF MODE 2
                                     ;WHICH ONLY HAS 4 INKS
              RLCA                   ;CORRECT BIT SWOP

COIPM3:       BIT 0,C                ;TEST MASK BIT
              JR Z,COPAPM3           ;JR IF PAPER

              LD (M23INKT),A
              LD E,5                 ;BLITZ CODE FOR 'PEN'
              PUSH BC
              LD C,A
              CALL GRAREC
              POP BC
              JR CINKPAP2

COPAPM3:      LD (M23PAPT),A
              JR CINKPAP2

CINKPAP0:     CP 18
              JR NC,INVCOLERR        ;ONLY ALLOW INK/PAPER 16 OR 17 HERE

              LD   A,(HL)            ;GET (ATTRT)
              JR   Z,CINKPAP1        ;JR IF INK/PAPER 16 - NO CHNG TO ATTRT,
                                     ;JUST MASKT
              OR   C                 ;MAKE INK OR PAPER WHITE
              CPL                    ;THEN BLACK. FLIP OTHER BITS
              AND  &24               ;00 100 100
              JR Z,CINKPAP2          ;JR IF INK/PAPER WAS LIGHT

              LD   A,C               ;USE WHITE INK OR PAPER TO CONTRAST

CINKPAP1:     LD B,A

CINKPAP2:     LD A,B
              CALL COCHNG            ;CHANGE ATTRT
              LD A,15                ;SO GET CARRY FOR INK/PAPER 16/17
              CALL COCHNGP           ;CHANGE MASKT
              RLCA
              RLCA
              AND &50
              LD C,A
              LD A,16                ;SO GET CARRY FOR INK/PAPER 17
                                     ;THEN ALTER PFLAGT
COCHNGP:      CP D
              SBC A,A

COCHNG:       XOR (HL)
              AND C
              XOR (HL)
              LD (HL),A
              LD A,C
              INC HL
              RET


BORDER:    CALL SYNTAX6

           LD DE,&1000+23    ;LIMIT TO <16 OR INVALID COLOUR
           CALL LIMBYTE      ;A=BORDER

SETBORD:   LD C,A
           LD L,C
           RLCA
           RLCA
           LD B,A
           XOR C
           AND &20           ;USE BIT 5 FROM A
           XOR C
           OR &08            ;MIC OFF
           EX DE,HL
           LD HL,BORDCOL
           XOR (HL)
           AND &3F           ;USE BITS 7 AND 6 (SOFF/THRO) FROM SYS VAR
           XOR (HL)
           LD (HL),A         ;USED BY SAVE/LOAD TO RESTORE BORDER, AND BEEP
                             ;BIT 7=SOFF STATUS
           EX DE,HL
           OUT (KEYPORT),A
           LD A,B
           RLCA              ;0XXX X000
           LD H,0            ;BLACK INK
           BIT 5,A           ;IS BORDER COLOUR LIGHT?
           JR NZ,BORD1       ;JR IF SO - INK IS BLACK

           LD H,&FF          ;COLOUR 15/3 (WHITE) FOR LS INK (MODE 3/2)
           OR &07            ;AND BORDER COLOUR

BORD1:     LD (BORDCR),A
           LD A,L
           RLCA
           RLCA
           RLCA
           RLCA
           OR L
           LD L,A            ;DOUBLE PAPER NIBBLE
           LD A,(MODE)
           CP 2
           JR NZ,BORD3

           CALL M3TO2
           INC A
           JR Z,BORD2             ;USE INK 0 IF PAPER FF

           LD A,&FF               ;(USUALLY) WHITE INK OTHERWISE

BORD2:     LD H,A

BORD3:     LD (M23LSC),HL
           RET

;CONVERT LS PAPER TO NON-STRIPED MODE 2 COLOUR - CALLED BY MODE

CVLSP:     CALL M3TO2        ;CONVERT L
           JR BORD3

M3TO2:     LD A,L
           RLCA
           RLCA                   ;BITS 5,4 AND 1,0 TO 7,6 AND 4,3
           XOR L
           AND &CC                ;KEEP BITS 7,6,4,3 OF A
           XOR L                  ;A=4 COPIES OF PARAM BITS 1,0 IF MODE 2
           RLCA                   ;CORRECT BIT SWOP
           LD L,A
           RET


WINDOW:    CALL CRCOLON
           JR Z,ALLWIND

           CALL EXPT4NUMS    ;L,R,T,B
           CALL CHKEND

           CALL GETBYTE      ;B
           LD A,(WINDMAX)    ;LOWEST BOTTOM
           SUB C
           JR C,WDERR        ;ERROR IF WINDOW BOTTOM WILL BE TO LOW

           LD B,C
           PUSH BC
           CALL GETBYTE      ;T
           POP BC            ;B=BOT
           CP B
           JR Z,WND2         ;OK IF WINDOW TOP=WINDOW BOTTOM (1 LINE HIGH)

           JR NC,WDERR       ;ERROR IF WINDOW TOP WILL BE BELOW BOTTOM

WND2:      LD C,A
           PUSH BC           ;BOT/TOP
           CALL GETBYTE      ;R
           LD A,(WINDMAX+1)  ;MAX RHS MARGIN
           CP C
           JR C,WDERR        ;ERROR IF TOO FAR RIGHT

           PUSH BC
           CALL GETBYTE      ;LHS
           POP HL            ;L=RHS
           CP L
           JR NC,WDERR       ;ERROR IF WINDOW IS ONE CHAR OR LESS WIDE

SETWIND:   LD H,A            ;HL=LHS/RHS
           LD (UWRHS),HL
           POP HL            ;HL=BOT/TOP
           LD (UWTOP),HL
           LD H,L
           LD L,A            ;LHS
           LD (SPOSNU),HL    ;TOP/LHS
           RET

ALLWIND:   CALL CHKEND

           LD HL,(WINDMAX)   ;L=BOT, H=RHS
           XOR A
           LD D,L
           LD E,A            ;DE=BOT/TOP
           PUSH DE
           LD L,H            ;L=RHS
           JR SETWIND

WDERR:     RST &08
           DB 54             ;'Invalid WINDOW'



OUT:       CALL SYNTAX8

           CALL GETBYTE
           PUSH AF
           CALL GETINT
           POP AF
           OUT (C),A
           RET

STOP:      CALL CHKEND

           RST &08
           DB 16             ;'STOP statement'


RANDOMIZE: CALL SYNTAX3      ;NUMBER OR ZERO

           CALL GETINT
           LD A,H
           OR L
           JR NZ,RANDOM1

           LD HL,(FRAMES)    ;RANDOMIZE OR RANDOMIZE 0 USES FRAMES

RANDOM1:   LD (SEED),HL
           RET

                                 ;ON ERROR, FINDER, MNINIT, PALETTE, BLOCKS,
                                 ;KEY, DEVICE, PAUSE, COITEM2
;          INCLUDE SCRFN.SAM      ;COPY, SCREEN$, LIST, SPACES, EDPTR2
;SCRFN.SAM - TEXT/GRAPHICS COPY, SCREEN$ FUNCTION, ATTR FN, POINT, BORDER,
;LOOK SAM, WINDOW, ZAP ETC.

;MAIN COPY ROUTINE:

COPY:      CP &FF
           JR NZ,GRCOPY

;TEXT COPY

           RST &20           ;SKIP 0FFH
           CP CHRSTOK
           JP NZ,NONSENSE

           RST &20

GRCOPY:    CALL CHKEND

JGCOPY:    DB &3E            ;'LD A,0AFH' **

JTCOPY:    XOR A

           LD HL,(DMPV)

JPOPT:     INC H
           DEC H
           RET Z

           JP (HL)           ;A=0 FOR TEXT COPY, 0AF FOR GRAPHICS

;SCREEN$(L,C)

IMSCREENS: CALL EXB2NUMB  ;CHECK (X,Y). CY IF RUNNING
           RET NC

           LD A,(UWRHS)
           INC A
           LD L,A            ;L=RHS LIMIT FOR COL, PLUS 1
           LD A,(UWBOT)
           ADD A,3           ;ALLOWS FOR LW OF 2 LINES
           LD H,A            ;H=BOT LIMIT FOR LINE, PLUS 1
           CALL GETCP        ;GET POSN IN DE
           CALL IMSCSR
           JP NC,CWKSTK      ;IF FOUND, STACK 1 BYTE STRING, COPY TO WORKSP

           XOR A
           JP STACKA         ;ELSE STACK NULL STRING

;CALLED BY TEXT COPY AND SCREEN$ FN
;ENTRY: DE=LINE/COL
;EXIT: CY IF FOUND, (HL)=CHAR, BC=1, ELSE NC, A=0

IMSCSR:    LD HL,DEVICE
           LD A,(HL)
           LD (HL),0         ;ENSURE DEVICE=UPPER SCREEN, OR ANYDEADDR FAILS
           PUSH AF
           PUSH HL
           CALL ANYDEADDR    ;GET DE=SCREEN ADDR, CY IF 6-PIX CHARS IN USE,
                             ;(IN WHICH CASE NZ/Z=ODD/EVEN COL)
           POP HL
           POP BC
           LD (HL),B
           EX DE,HL
           LD DE,SCRNBUF     ;BUFFER WILL HOLD TARGET CHAR IN A STANDARD FORM
           PUSH AF
           LD A,(MODE)
           CP 2
           JR C,SCM01

           POP AF            ;CY IF 6-PIX, NZ/Z=ODD/EVEN COL
           PUSH AF
           CALL CHARCOMP     ;COMPRESS SCREEN AREA TO BUFFER USING TOP LHS
                             ;PIXEL OF CHAR AS BACKGROUND
           POP AF
           JR NC,SCBMCH      ;JR IF NOT 6-PIX - BUFFER OK

           LD BC,&087E       ;8 BYTES TO ROTATE BY 1 PIX LEFT OR RIGHT FOR
                             ;CENTRAL POSITION, C=MASK TO TRIM LHS AND RHS BITS
           LD HL,SCRNBUF
           JR Z,SC6EAL       ;JR IF EVEN COLUMN

SC6OAL:    LD A,(HL)
           RLCA
           AND C             ;MASK OFF BITS 7 AND 0, WHICH MAY BE JUNK
           LD (HL),A
           INC HL
           DJNZ SC6OAL

           JR SCBMCH

SC6EAL:    LD A,(HL)
           RRCA
           AND C
           LD (HL),A
           INC HL
           DJNZ SC6EAL

           JR SCBMCH

;MODES 0 AND 1 DO NOT NEED COMPRESSION OF SCRN CHAR DATA - BUT TRANSFER IT

SCM01:     POP AF            ;JUNK FLAGS FOR 6-PIX
           LD BC,&0800       ;BYTES TO DO/NO INVERSE
           CALL SREAD
           RLA
           JR NC,SCM01L

           DEC C             ;MASK=FF FOR INVERTING CHAR IF TOP LH PIX=FORGROUND

SCM01L:    CALL SREAD
           XOR C
           LD (DE),A
           CALL NXTDOWN      ;DROP HL TO NEXT SCAN
           INC DE            ;NEXT BUFF POSN
           DJNZ SCM01L

;SCREEN$ BUFFER MATCH - MATCH BUFFER WITH CHAR PATTERNS

SCBMCH:    LD HL,(CHARS)
           INC H
           LD A,96           ;CHARS TO CHECK (32-127)
           CALL SCREENSR
           JR NC,SCRNFND

           LD HL,(UDG)       ;PTS TO CHR$ 144
           LD BC,-128
           ADD HL,BC         ;PT TO CHR$ 128
           LD A,41           ;128-168
           CALL SCREENSR
           RET C             ;RET IF NOT FOUND

UDGFND:    ADD A,96          ;1-41 -> 97-137

SCRNFND:   ADD A,32          ;1-96 -> 32-127, 97-137 -> 128-168
           LD BC,1           ;LEN=1
           LD HL,TEMPW1
           LD (HL),A         ;NC='FOUND'
           RET


;SR TO CHECK B CHARS IN CHAR. GENERATOR AT (HL) VS. CHAR IN SCRNBUF
;ENTRY: A=NO. OF CHARS, HL PTS TO CHARSET
;EXIT WITH NC IF MATCHED, A=CHAR MATCH POSN, 0 TO B-1, OR CY SET=FAIL

SCREENSR:  LD B,A
           EX AF,AF'         ;A'=CHARS TO CHECK (KEPT TILL END)
           LD DE,SCRNBUF+4
           LD A,(DE)
           LD C,A            ;C=BYTE 4 OF TARGET CHAR
           DEC DE
           LD A,(DE)         ;A=BYTE 3 OF TARGET CHAR
           INC HL
           INC HL
           INC HL            ;PT HL TO BYTE 3 OF CHAR GEN. CHARACTER
           LD DE,8           ;FOR STEPPING TO NEXT CHAR
           DB &FE            ;'JR+1'

SCREENLP:  ADD HL,DE
           CP (HL)           ;CHECK BYTE 3 FOR MATCH
           JR Z,SCREEN2      ;JR TO CHECK BYTE 4 IF NEEDED

SCREEN1:   DJNZ SCREENLP

           SCF               ;'FAILED'
           RET

SCREEN2:   LD A,C            ;BYTE 4 OF TARGET CHARACTER
           INC HL
           CP (HL)           ;VS. BYTE 4 IN CHAR. GEN. CHARACTER
           DEC HL
           LD A,(HL)
           JR NZ,SCREEN1

           PUSH HL
           PUSH BC
           DEC HL
           DEC HL
           DEC HL            ;PT TO BYTE 0 IN CHAR. GEN CHARACTER
           LD DE,SCRNBUF     ; AND BYTE 0 OF TARGET CHAR IN BUFFER
           LD B,8            ;DOING A FULL CHECK IS NOW WORTHWHILE

FULCKLP:   LD A,(DE)
           CP (HL)
           JR Z,FULCK1       ;JR IF FULL MATCH STILL OK

           POP BC
           POP HL
           LD A,(HL)
           LD DE,8
           JR SCREEN1

FULCK1:    INC HL
           INC DE
           DJNZ FULCKLP      ;LOOP TILL ALL 8 MATCHED OK

           POP BC
           POP HL
           EX AF,AF'         ;CHARS TO CHECK
           SUB B             ;FIRST CHAR MATCH GIVES 0, LAST GIVES ORIG B-1
           RET               ;WITH NC ='MATCHED'.

;PT 2 OF LIST

LSTR1:     CALL SPACAN

LSTLNL:    CALL OUTLINE
           RET C             ;RET IF HIT END OF PROG

           RST &10           ;PRINT 0DH
           CALL R1OFRD
           LD B,A
           CALL CHKHL        ;**
           INC HL
           CALL R1OFRD
           LD C,A
           DEC HL            ;BC=NUMBER OF NEXT LINE
           EX DE,HL
           LD HL,(LAST)    ;LAST LINE
           AND A
           SBC HL,BC
           EX DE,HL
           JR NC,LSTLNL      ;LOOP UNTIL PAST LAST LINE ASKED FOR ('LAST LINE'=
                             ;EPPC IF AUTO-LIST)
           LD A,(TVFLAG)
           AND &10
           RET Z             ;RET IF NOT AN AUTO-LIST, ELSE FILL REST OF SCREEN

           LD A,(WINDBOT)
           LD E,A
           LD A,(SPOSNU+1)   ;PRINT POSN ROW
           SUB E
           JR C,LSTLNL

           RET

;EXIT: CY=HIT END OF PROG, ELSE NC AND 0D JUST PRINTED.

OUTLINE:   CALL R1OFRD       ;LN MSB
           LD B,A
           ADD A,1
           RET C             ;RET IF FF END-OF-PROG STOPPER

           INC HL
           CALL R1OFRD
           LD C,A            ;BC=CURRENT LN NO.
           LD A,(NXTSPCS)
           LD (OLDSPCS),A    ;IN CASE LINE IS LAST ON SCREEN AND NEEDS
                             ;TO BE PRINTED TWICE - ALLOWS SPACES TO BE
                             ;RESET BEFORE 2ND TIME **
           XOR A             ;'BEFORE CURRENT LINE'
           EX DE,HL
           LD HL,(EPPC)
           SBC HL,BC         ;NC IF CUR LN=EPPC OR IS LESS THAN EPPC
           EX DE,HL          ;NC,Z IF '>' TO BE PRINTED
           PUSH AF
           JR NC,OUTLN2      ;JR IF 'BEFORE CURRENT LINE'

           INC A

OUTLN2:    LD (BCREG),A      ;1=CURRENT LINE HAS BEEN PRINTED
           CALL PRNUMB2      ;O/P NUMBER BC WITH LEADING SPACES
           LD A,(DEVICE)
           AND A
           JR NZ,OUTLN22     ;JR IF NOT UPPER SCREEN

           LD A,(WINDTOP)
           LD E,A
           LD A,(SPOSNU+1)   ;LINE
           SUB E             ;GET LINE REL. TO WINDOW
           ADD A,LPT\256
           LD E,A
           LD D,LPT/256
           LD A,D
           LD (DE),A         ;ENTRY IN LPT SHOWS LINE HAS A LINE NUMBER

OUTLN22:   INC HL
           INC HL
           INC HL            ;PT TO FIRST CHAR IN LINE
           POP AF
           JR NZ,OUTLN3

           CALL PRLCU        ;PRINT '>'

;USED BY EDPRNT

OUTLN25:   EX DE,HL
           LD HL,FLAGS
           SET 0,(HL)        ;'NO LEADING SPACE NOW'
           EX DE,HL
           JR OUTLN4

OUTLN3:    LD A," "
           RST &10           ;PRINT SPACE (ALSO SETS 'NO LEADING SPACE')

OUTLN4:    XOR A
           LD (NXTHSPCS),A
           LD A,(LISTFLG)
           AND A
           CALL R1OFRD       ;FIRST CHAR IN LINE
           PUSH HL           ;LINE PTR
           CALL NZ,SPACES    ;INDENT IF FLAG SAYS 'PRETTY LISTING'
           POP HL
           EX DE,HL          ;SAVE LINE PTR IN DE
           XOR A
           LD (INQUFG),A     ;'NOT IN QUOTES'

OUTLNLP:   LD HL,(XPTR)
           AND A
           SBC HL,DE
           CALL Z,PRFLQUERY  ;PRINT A FLASHING '?' IF SYNTAX ERROR PTR
           CALL OPCURSOR
           EX DE,HL
           CALL R1OFFCL
           DW RDCN           ;=LD A,(HL): CALL NUMBER, WITH ROM1 OFF
           LD (LSPTR),HL     ;LINE SCAN PTR - USED BY CUOP O/P ROUTINE
           INC HL
           CP &0D
           RET Z

           EX DE,HL          ;DE=LINE PTR

           CP ":"
           JR NZ,OUTCH2

           LD H,A
           LD A,(LISTFLG)
           AND A
           LD A,H
           JR Z,OUTCH3       ;JR IF NO PRETTY LISTING

           LD A,(INQUFG)
           RRCA              ;BIT 0=1 IF INSIDE
           LD A,H            ;':'
           JR C,OUTCH3       ;JR IF ':' IS INSIDE QUOTES

           LD A,(FLAGX)
           AND &20
           LD A,H
           JR NZ,OUTCH3      ;JR IF INPUT MODE

;DO TAB 0 IF USING LOWER SCREEN (TO OVER-WRITE JUNK WITH SPACES) OR DO CR FOR
;SPEED IF NOT; FOLLOW EITHER WITH 6 SPACES TO INDENT TEXT

           LD A,(INDOPFG)
           PUSH AF
           XOR A
           LD (INDOPFG),A    ;NO INDENTED O/P SO TAB FILLING LINE AVOIDS INDENT
           LD A,(DEVICE)
           DEC A
           LD A,&0D
           JR NZ,TABS2      ;JR IF NOT LOWER SCREEN

           LD A,&17          ;TAB
           RST &10
           XOR A
           RST &10
           XOR A

TABS2:     RST &10
           LD B,6
           CALL OPBSP
           POP AF
           LD (INDOPFG),A

           EX DE,HL
           CALL R1OFRD
           EX DE,HL          ;A=(DE) (CHAR TO O/P NEXT)
           CALL SPACES       ;SET SPACES, O/P CURRENT SPACES
           JR OUTLNLP

OUTCH2:    CP &22
           JR NZ,OUTCH3

           LD HL,INQUFG
           INC (HL)          ;FLIP BIT 0 (INSIDE/OUTSIDE QUOTES FLAG)

OUTCH3:    RST &10
           JR OUTLNLP


;SCROLL TABLE ENTRIES
;ENTRY: A=LINES TO SCROLL BY, D=1 IF UP, NOT 1 IF DOWN

STENTS:    LD L,A
           LD A,30
           SUB L
           LD C,A
           XOR A
           LD B,A
           LD H,A
           LD A,L

;HL=LINES TO SCROLL BY, BC=30-LINES TO SCROLL BY, A=LINES TO SCROLL BY, NC

           DEC D
           JR Z,PTU          ;JR IF SCROLL UP

           LD DE,LPT+29
           PUSH DE
           EX DE,HL          ;HL=LPT+29, DE=LINES
           SBC HL,DE         ;HL=LPT+29-LINES
           POP DE            ;LPT+29
           LDDR
           LD B,A
                             ;(NEW LINE FOR CURSOR SET BY PRINTING OF LINE)
           XOR A

PDCL:      LD (DE),A         ;NEW ENTRIES IN TABLE ARE ZEROS
           DEC DE
           DJNZ PDCL

           RET

PTU:       LD DE,LPT
           ADD HL,DE
           LDIR
           LD B,A
           LD HL,LNPTR
           LD A,(HL)
           SUB B
           LD (HL),A         ;NEW LINE FOR CURSOR
           XOR A

PTCL:      LD (DE),A
           INC DE
           DJNZ PTCL

           RET

SPACES:    LD HL,NXTSPCS     ;POINT TO 'NEXT-SPACES' VAR.
           PUSH HL
           LD B,(HL)
           INC HL
           LD (HL),B         ;CURRENT SPACES=NEXT SPACES
           INC HL
           LD B,(HL)
           INC HL
           LD (HL),B         ;CURRENT THEN SPACES=NEXT THEN SPACES
           POP HL            ;PTR TO NEXT-SPACES

           CP &D4            ;DOTOK
           JR Z,INCSPCS

           CP &D7            ;LIFTOK
           JR Z,INCSPCS

           CP &CA            ;DEFPROCTOK
           JR Z,INCSPCS

           CP &C0            ;FORTOK
           JR Z,INCSPCS      ;THESE CMDS NEED NEXT SP=NEXT SP+INDENT
                             ;(INDENT FROM NEXT STATEMENT ONWARDS)
           CP &D5            ;LOOPTOK
           JR Z,DECSPCS

           CP &CB            ;ENDPROCTOK
           JR Z,DECSPCS

           CP &DB            ;ENDIFTOK
           JR Z,DECSPCS      ;THESE CMDS (AND NEXT) NEED TO CANCEL INDENT FOR
                             ;CURRENT AND LATER STATEMENTS.

           CP &C1            ;NEXTTOK
           JR NZ,SPACES2

DECSPCS:   CALL SPACESR      ;CURRENT=CURRENT-INDENT
           LD B,(HL)
           DEC HL
           LD (HL),B         ;NEXT SPACES=CURRENT
           JR SPACES4

SPACES2:   CP &D6            ;EXITIFTOK
           JR Z,SPACES3

           CP &D9            ;LELSETOK
           JR Z,SPACES3

           CP &D3            ;LOOPIFTOK
           JR Z,SPACES3      ;LOOP IF, LELSE AND EXIT IF CANCEL INDENT FOR
                             ;CURRENT STAT ONLY.
           INC HL
           INC HL            ;PT TO SPACES THAT WILL CANCEL AT LINE END (SIF)
           CP &DA            ;ELSETOK
           JR NZ,SPACES35    ;SHORT ELSE CANCELS SOME OF THEM, AS DOES 'ON'

SPACES3:   CALL SPACESR
           JR SPACES4

SPACES35:  CP &D8            ;SIFTOK
           JR Z,INCSPCS      ;SHORT IF INDENTS FOR LATER STATEMENTS, THIS LINE

           CP &DE            ;ONTOK. AS DOES 'ON'
           JR NZ,SPACES4

INCSPCS:   LD A,(LISTFLG)
           ADD A,(HL)
           LD (HL),A
           DB &FE            ;"JR+3" (CP 3EH: LD B,FEH)

;CALLED FROM MAIN PRINT ROUTINE WHEN LINE FULL

INDOPEN:   LD A,6
           DB &FE            ;'JR+1'

SPACES4:   XOR A
           LD HL,CURSPCS
           ADD A,(HL)
           INC HL
           INC HL
           ADD A,(HL)
           RET Z

           LD B,A
           LD HL,(WINDRHS)
           LD A,L
           SUB H             ;SUB RHS,LHS=WIDTH-1
           CP 10
           RET C             ;NO INDENT IF 10 COLS OR LESS

           SUB 5
           CP B
           JR NC,SPCS5       ;FULL INDENT IF ROOM

           LD B,A            ;ELSE INDENT BY WIDTH-6

SPCS5:     JP OPBSP

SPACESR:   INC HL
           LD A,(LISTFLG)
           LD B,A
           LD A,(HL)
           SUB B
           LD (HL),A
           RET NC

           LD (HL),&00
           RET



EDPTR2:    CALL TEMPS
           CALL POFETCH
           PUSH DE           ;SAVE SCRN POSN SO THAT SEVERAL EDPRTS CAN ALL
                             ;START AT THE SAME POSN, NOT CONCATENATED!
           LD A,(WINDTOP)
           LD (TEMPB2),A
           LD HL,TVFLAG
           RES 5,(HL)        ;'NO NEED TO CLEAR LS ON KEYSTROKE'
           RES 3,(HL)        ;'NO NEED TO COPY LINE TO LOWER SCRN'
           LD HL,(ERRSP)
           PUSH HL
           LD HL,EDPE        ;NEW ERROR HANDLER
           PUSH HL
           LD (ERRSP),SP
           CALL SETDE        ;DE=START OF ELINE OR INPUT LINE
           LD HL,(OLDPOS)
           PUSH HL           ;POSN OF END OF LINE IN LOWER SCREEN
           EX DE,HL          ;HL=LINE START
           LD BC,OUTLN25
           LD A,(FLAGX)
           AND &20
           JR NZ,EDIM        ;JR IF INPUT MODE - NO INDENT

           LD A,(HL)
           CP &0D
           JR Z,EDCOP        ;JR IF LINE EMPTY ** BUG FIX

           CALL SPACAN
           CALL IOPCL        ;PRINT THE LINE, INDENTED
           CP A              ;Z

EDIM:      CALL NZ,BCJUMP

EDCOP:     EX DE,HL          ;DE=LINE PTR
           CALL OPCURSOR     ;PRINT THE CURSOR IF IT IS AT THE END OF THE LINE
                             ;(OR IT HAS BEEN PRINTED ALREADY)
           CALL TEMPS
           CALL POFETCH      ;USE VALUE AS NEW 'OLDPOS'
           POP HL            ;OLDPOS
           CALL LSASR        ;ADJUST IF LS SCROLLED
           PUSH DE           ;NEW OLDPOS
           PUSH HL

EDBL:      POP BC            ;OLDPOS
           CALL POFETCH      ;NEW POSN OF END OF LINE IN LOWER SCREEN
           EX DE,HL
           AND A
           SBC HL,BC         ;NORMALLY NEW POSN IS FURTHER RIGHT, OR DOWN, AS
           JR NC,EDBE        ;TEXT IS ADDED, SO NC. BUT IF DELETE USED, CY

           PUSH BC
           LD A," "
           CALL FONOP        ;NORMAL OUTPUT
           JR EDBL           ;LOOP TILL LINE BLANKED TO OLD END-OF-LINE.

;EDPRNT ERRORS COME HERE

EDPE:      CALL WARNBZ
           CALL POFETCH      ;FOR OLDPOS
           DB &21            ;'JR+2'

EDBE:      POP DE            ;LAST END-OF-LINE POSN
           POP HL            ;ERROR HANDLER ADDR

           POP HL
           LD (ERRSP),HL
           LD (OLDPOS),DE
           POP HL            ;ORIG SCRN POSN
           CALL LSASR
           CALL POSTORE      ;ORIG SCRN POSN, MODIFIED IF SCOLLED UP
           XOR A
           LD (XPTR+1),A     ;CANCEL ANY '?' ERROR MARKER
           RET

LSASR:     LD A,(TEMPB2)
           LD B,A
           LD A,(WINDTOP)
           SUB B             ;A IS EG -1 IF LW HAS EXPANDED UP BY ONE
           ADD A,H           ;EG ADJUST PRINT LINE UP BY ONE IF LS SCROLLED
           LD H,A
           RET

;EDITOR'S SPECIAL CURSOR OUTPUT TO SET SCREEN POSN

CUOPP:
           LD BC,(SPOSNL)
           LD HL,(KPOS)
           AND A
           SBC HL,BC
           JR NZ,CUOP2

           LD HL,(LSPTR)
           LD (KCUR),HL
           PUSH AF
           CALL OPCUR2       ;PREVENT LINE BEING BRIEFLY PRINTED 1 CHAR SHORTER
           POP AF            ;AS OLD CURSOR VANISHES AND NEW CURS. POSN FOUND

CUOP2:     JP FONOP


;OP CURSOR IF DE=KCUR.

OPCURSOR:  LD HL,(KCUR)
           AND A
           SBC HL,DE
           RET NZ            ;RET IF THIS ISN'T CURSOR'S ADDR IN LINE

           IN A,(251)
           LD H,A
           LD A,(KCURP)
           XOR H
           AND &1F
           RET NZ            ;**

           LD HL,(SPOSNL)
           LD (KPOS),HL      ;SAVE SCREEN POSN OF CURSOR

OPCUR2:    LD HL,(KURV)
           CALL JPOPT

           LD HL,(KURCHAR)
           LD A,(FLAGS2)
           AND &08
           LD A,L
           JR Z,PRINVERT     ;JR IF CAPS LOCK OFF

           LD A,H
           JR PRINVERT

;PRINT LINE CURSOR - USED BY MAIN LIST ROUTINE AND FUPDN

PRLCU:     LD A,(SPOSNU+1)
           LD (LNPTR),A      ;STORE LINE NO. WITH CURSOR
           LD A,(LNCUR)
           DB &FE            ;"JR+2" (CP 3EH: CCF). PRINT INVERSE '>'

PRFLQUERY: LD A,"?"

;PRINT CHAR IN 'A' REG IN INVERSE VIDEO
;USE CALL TO MNOP (VIA FONOP), NOT RST 10H, IN CASE INVERSE CHAR IS PRINTED
;BETWEEN CC AND ITS PARAMETER (AND CHANNEL ADDR HAS BEEN CHANGED).

PRINVERT:  LD B,A
           PUSH HL
           LD HL,PFLAGT
           LD A,(HL)
           PUSH AF
           SET 2,(HL)        ;INVERSE 1
           LD A,(INVERT)
           PUSH AF
           LD A,(INQUFG)
           PUSH AF
           LD A,(BGFLG)
           PUSH AF
           LD A,&FF
           LD (INQUFG),A     ;'IN QUOTES' SO CURSORS CAN BE UDGS
           LD (INVERT),A
           LD (BGFLG),A
           LD A,B
           PUSH DE
           CALL FONOP
           POP DE
           POP AF
           LD (BGFLG),A
           POP AF
           LD (INQUFG),A
           POP AF
           LD (INVERT),A
           POP AF
           LD (PFLAGT),A
           POP HL
           RET


;PRINT INTEGER IN A, AS 1-3 CHARS. HL IS SAVED. USED FOR STAT AND ERROR NUMS.

PRAREG:    LD C,A
           LD B,0

;USED FOR LINE NUMS IN REPORTS

PRNUMB1:   LD E,0            ;NO LEADING SPACES
           LD A,B
           INC A
           JR NZ,PRNUMBC

           LD C,A
           LD B,A
           DB &22            ;"JR+2". NUMBERS >=FF00 PRINT AS 0 (EG ELINE)

;PRINT INTEGER IN BC, PADDED TO 5 CHARS WITH LEADING SPACES. HL IS SAVED.
;USED FOR LINE NUMS IN LISTINGS. USES BC, DE, AF.

PRNUMB2:   LD E,&20          ;LEADING SPACES

PRNUMBC:   PUSH HL
           PUSH BC           ;NUMBER
           LD HL,SUBTAB

PRNUOLP:   LD C,(HL)
           INC HL
           LD B,(HL)
           INC HL
           EX (SP),HL        ;HL=NUMBER
           LD A,L
           INC C
           DEC C
           JR Z,PRNTNO1      ;JR IF WE ARE AT 'UNITS' STAGE (C=TERMINATOR)

           XOR A

PRNUILP:   INC A
           ADD HL,BC
           JR C,PRNUILP      ;SUCCESSIVE SUBTRACTIONS OF EG. 10, 100

           SBC HL,BC
           DEC A             ;A=DIGIT FOR 1000'S, 100'S ETC.
           JR Z,PRNTNO2      ;LEAVE E ALONE IF IT'S A ZERO DIGIT

PRNTNO1:   LD E,&30          ;AFTER A NON-ZERO DIGIT USE '0' FOR ZERO, RATHER
                             ;THAN ' ' OR ''.
PRNTNO2:   ADD A,E
           CALL NZ,&0010     ;CALL UNLESS LEADING SPACES SUPPRESSED.
           EX (SP),HL        ;HL=TABLE PTR
           INC C
           DEC C
           JR NZ,PRNUOLP     ;LOOP IF NOT AT 'UNITS' YET

           POP HL            ;NUMBER
           POP HL            ;ORIG
           RET

                                 ;OPCURSOR, PRLCU, PRINVERT, STENTS, PRAREG,
                                 ;PRNUMB

;          INCLUDE TEXT.SAM       ;TABLES, MSGS, KEYWORDS, CMDADDRT, CHARSET
;TEXT.SAM - ERROR MESSAGES, KEYWORDS, MSGS, TABLES, CHARSET ETC

;REPORTS GENERATED BY E.G. RST 08H: DB 0 FOR OK
;UTILITY MESSAGES (START AT 0)

;UMVAL IS LOADED INTO UMSGS SYS VAR AT INIT.
UMVAL:

  DM "   MILES GORDON TECHNOLOGY PLC  "
  DM "     "
  DB 127
  DM " 1990  SAM Cou"
  DB "p"+&80  ;0

  DM "scroll"
  DB "?"+&80  ;1

  DB " "+&80  ;2 NOT USED

  DM "St"
  DB CAR
  DM "t tape and then press a ke"
  DB "y"+&80  ;3

  DM "Basic:"
  DB " "+&80  ;4

  DM "Nu"
  DB CME
  DM "ric"
  DB ARRAY+&80  ;5

  DB STRING,ARRAY+&80  ;6

  DM "Co"
  DB CDE,":"," "+&80  ;7

  DB "S",CREEN,":"," "+&80  ;8

;ERRMVAL IS LOADED INTO ERRMSGS SYS VAR AT INIT.
ERRMVAL:

  DB "O","K"+&80  ;0

  DM "Out"
  DB SOFS,CME
  DM "mor"
  DB "y"+&80  ;1

  DB SNOTS
  DM "foun"
  DB "d"+&80  ;2

  DM "DATA has all been rea"
  DB "d"+&80  ;3

  DM "Subscript wron"
  DB "g"+&80  ;4

  DB CNXT,WITHOUT
  DM "FO"
  DB "R"+&80  ;5

  DM "FOR"
  DB WITHOUT,CNXT+&80  ;6

  DM "FN"
  DB WITHOUT
  DM "DEF F"
  DB "N"+&80  ;7

  DM "RETURN"
  DB WITHOUT
  DM "GOSU"
  DB "B"+&80  ;8

  DB MISSING,CLOOP+&80  ;9

  DB CLOOP,WITHOUT,"D","O"+&80  ;10

  DB NO
  DM "POP dat"
  DB "a"+&80  ;11

  DB MISSING
  DM "DEF"
  DB CPROC+&80  ;12

  DB NO
  DM "END"
  DB CPROC+&80  ;13

  DB BREAK
  DM "- CONTINUE "
  DB CTO
  DM " repea"
  DB "t"+&80  ;14

  DB BREAK,CIN,CTO
  DM " progra"
  DB "m"+&80  ;15

  DB CSTOP,"s",TATEMENT+&80  ;16

  DB CSTOP,CIN
  DM " INPU"
  DB "T"+&80  ;17

  DB INVALID,FILE,SNAME+&80  ;18

  DM "Load"
  DB CIN,"g",ERROR+&80  ;19

  DB INVALID,CDE
  DM "vic"
  DB "e"+&80  ;20

  DB INVALID,"s",TREAM
  DM " n"
  DB UMBER+&80  ;21

  DM "End"
  DB SOFS,FILE+&80  ;22

  DB INVALID,CLOUR+&80  ;23

  DB INVALID,PALET,CLOUR+&80  ;24

  DB TOOMANY,PALET
  DM "change"
  DB "s"+&80  ;25

  DB "P",CAR,"a",CME
  DM "ter"
  DB ERROR+&80  ;26

  DB INVALID,CAR
  DM "gu"
  DB CME,"n","t"+&80  ;27

  DB "N",UMBER,TOO,"l",CAR,"g","e"+&80  ;28

  DM "Not un"
  DB CDE
  DM "rs"
  DB CTO,"o","d"+&80  ;29

  DM "Integer out"
  DB SOFS
  DM "rang"
  DB "e"+&80  ;30

  DB "S",TATEMENT
  DM " doesn't exis"
  DB "t"+&80  ;31

  DM "Off s"
  DB CREEN+&80  ;32

  DB NO
  DM "room for l"
  DB CIN,"e"+&80  ;33

  DB INVALID,"s",CREEN
  DM " mod"
  DB "e"+&80  ;34

  DB INVALID
  DM "BLITZ cod"
  DB "e"+&80  ;35

  DB "S",CTO
  DM "red "
  DB CAR
  DM "ea"
  DB TOO
  DM "bi"
  DB "g"+&80  ;36

  DB INVALID
  DM "PUT bloc"
  DB "k"+&80  ;37

  DM "PUT mask mismatc"
  DB "h"+&80  ;38

  DB MISSING
  DM "END I"
  DB "F"+&80  ;39

  DB INVALID,"v",CAR
  DM "iable"
  DB SNAME+&80  ;40

  DM "BASIC stack ful"
  DB "l"+&80  ;41

  DB STRING,TOO,LONG+&80  ;42

  DB INVALID,"s",CREEN
  DM " n"
  DB UMBER+&80  ;43

  DB "S",CREEN,ISALREDOP+&80  ;44

  DB "S",TREAM,ISALREDOP+&80  ;45

  DM "Current s"
  DB CREEN+&80  ;46  WAS INVALID CHANNEL

  DB "S",TREAM
  DM " is"
  DB SNOTS
  DM "ope"
  DB "n"+&80  ;47

  DB INVALID
  DM "CLEAR addres"
  DB "s"+&80  ;48

  DB INVALID,NOTE+&80  ;49

  DB NOTE,TOO,LONG+&80  ;50

  DM "FPC"
  DB ERROR+&80  ;51

  DB TOOMANY,CDE,"f",CIN
  DM "ition"
  DB "s"+&80  ;52

  DM "No DO"
  DB "S"+&80  ;53

  DB INVALID
  DM "WINDO"
  DB "W"+&80  ;54

  DB MISSING
  DM "dis"
  DB "k"+&80  ;55

;SAVES OVER 200 BYTES.

COMPLIST:  DM "Invalid"
           DB " "+&80            ;14 uses

INVALID:   EQU 0

           DM " without"
           DB " "+&80           ;5 uses

WITHOUT:   EQU 1

           DM "Missing"
           DB " "+&80            ;5 uses

MISSING:   EQU 2

           DM " too"
           DB " "+&80               ;3 uses

TOO:       EQU 3

           DM " is already ope"
           DB "n"+&80    ;2 uses

ISALREDOP: EQU 4

           DM "palette"
           DB " "+&80            ;2 uses

PALET:     EQU 5

           DM " of"
           DB " "+&80                ;3 uses

SOFS:      EQU 6

           DM " erro"
           DB "r"+&80              ;4 uses

ERROR:     EQU 7

           DM "trea"
           DB "m"+&80               ;3 uses

TREAM:     EQU 8

           DM "umbe"
           DB "r"+&80               ;3 uses

UMBER:     EQU 9

           DM "NEX"
           DB "T"+&80                ;2 uses

CNXT:      EQU 10

           DM "No"
           DB " "+&80                 ;3 uses

NO:        EQU 11

           DM "BREAK"
           DB " "+&80              ;2 uses

BREAK:     EQU 12

           DM "cree"
           DB "n"+&80               ;6 USES

CREEN:     EQU 13

           DM " array:"
           DB " "+&80            ;2 USES

ARRAY:     EQU 14

           DM "Not"
           DB "e"+&80                ;2 USES

NOTE:      EQU 15

           DM "lon"
           DB "g"+&80                ;2 USES

LONG:      EQU 16

           DM " not"
           DB " "+&80               ;2 USES

SNOTS:     EQU 17

           DM " nam"
           DB "e"+&80               ;2 USES

SNAME:     EQU 18

           DM "Strin"
           DB "g"+&80          ;2 USES

STRING:    EQU 19

           DM "Too many"
           DB " "+&80       ;2 USES

TOOMANY:   EQU 20

           DM "tatemen"
           DB "t"+&80         ;2 USES

TATEMENT:  EQU 21

           DM "STOP"
           DB " "+&80           ;2 USES

CSTOP:     EQU 22

           DM "fil"
           DB "e"+&80            ;2 USES

FILE:      EQU 23

           DM "colou"
           DB "r"+&80          ;2 USES

CLOUR:     EQU 24

           DB "i","n"+&80              ;5 USES

CIN:       EQU 25

           DM " PRO"
           DB "C"+&80           ;2 USES

CPROC:     EQU 26

           DM "LOO"
           DB "P"+&80            ;2 USES

CLOOP:     EQU 27

           DB "t","o"+&80              ;4 USES

CTO:       EQU 28

           DB "d","e"+&80              ;4 USES

CDE:       EQU 29

           DB "m","e"+&80              ;2 USES

CME:       EQU 30

           DB "a","r"+&80              ;6 USES

CAR:       EQU 31

;TOKENS.SAM - SAM TOKEN TABLE.
;FUNCTIONS RANGE 21-&69, PRECEDED BY FF
;ASCII RANGE 20-7F
;BLOCK GRAPHICS/EXTENDED CHARS  80-8F
;EXTENDED CHARS 90-A8
;(&80-A8H ACT AS UDGS - PROGRAMMED AS BLOCK GRAPHICS, FOLLOWED BY EXTENDED CHARS
;ON POWER-UP. UDGS SYS VAR PTS TO USR "A". TAKES 328 BYTES OF RAM. OVERLAP WITH
;COMMAND TOKENS USES CONTEXT TO AVOID PROBLEMS - PRINT CHR$ 160 GIVES UDG, LIST
;COMMAND GIVES KEYWORD. QUOTES FORCES UDGS.
;ALLOW 80-95 IN PROC NAMES SO A FACE SYMBOL CAN BE A COMMAND?
;USE "." FOR EXTERNAL COMMAND

;QUALIFIERS  96-9F
;COMMANDS RANGE A0-FE

;FUNCTIONS HAVE &0FF PREFIX

;"IMMEDIATE" FUNCTIONS

KEYWTAB:      DB &A0

IMFNTL:       DM "P"            ;&3B
              DB "I"+&80

              DM "RN"           ;
              DB "D"+&80

              DM "POIN"         ;
              DB "T"+&80

              DM "FRE"          ;
              DB "E"+&80

              DM "LENGT"        ;
              DB "H"+&80

              DM "ITE"          ;
              DB "M"+&80

              DM "ATT"          ;
              DB "R"+&80

              DM "F"            ;
              DB "N"+&80

              DM "BI"           ;
              DB "N"+&80

              DM "XMOUS"        ;
              DB "E"+&80

              DM "YMOUS"        ;
              DB "E"+&80

              DM "XPE"          ;
              DB "N"+&80

              DM "YPE"          ;
              DB "N"+&80

              DM "RAMTO"        ;
              DB "P"+&80

              DB "-"+&80        ; UNUSED INARRAY

              DM "INST"         ;&4A
              DB "R"+&80

              DM "INKEY"        ;&4B
              DB "$"+&80


              DM "SCREEN"       ;
              DB "$"+&80

              DM "MEM"          ;
              DB "$"+&80

              DB "-"+&80        ; UNUSED CHAR$

              DM "PATH"         ;
              DB "$"+&80

              DM "STRING"       ;
              DB "$"+&80

              DB "-"+&80        ; UNUSED USING$
              DB "-"+&80        ;&52 UNUSED SHIFT$

;FPC FUNCTIONS

FPCFNTL:      DM "SI"           ;&53
              DB "N"+&80

              DM "CO"           ;
              DB "S"+&80

              DM "TA"           ;
              DB "N"+&80

              DM "AS"           ;
              DB "N"+&80

              DM "AC"           ;
              DB "S"+&80

              DM "AT"           ;
              DB "N"+&80

              DM "L"            ;
              DB "N"+&80

              DM "EX"           ;
              DB "P"+&80

              DM "AB"           ;
              DB "S"+&80

              DM "SG"           ;
              DB "N"+&80

              DM "SQ"           ;
              DB "R"+&80

              DM "IN"           ;
              DB "T"+&80

              DM "US"           ;
              DB "R"+&80

              DM "I"            ;
              DB "N"+&80

              DM "PEE"          ;
              DB "K"+&80

              DM "DPEE"         ;
              DB "K"+&80

              DM "DVA"          ;
              DB "R"+&80

              DM "SVA"          ;
              DB "R"+&80

              DM "BUTTO"        ;
              DB "N"+&80

              DM "EO"           ;
              DB "F"+&80

              DM "PT"           ;   DISC USE?
              DB "R"+&80

              DB "-"+&80

              DM "UD"           ;
              DB "G"+&80

              DB "-"+&80

              DM "LE"           ;
              DB "N"+&80

              DM "COD"          ;
              DB "E"+&80

              DM "VAL"          ;
              DB "$"+&80

              DM "VA"           ;
              DB "L"+&80

              DM "TRUNC"        ;
              DB "$"+&80

              DM "CHR"          ;
              DB "$"+&80

              DM "STR"          ;
              DB "$"+&80

              DM "BIN"          ;
              DB "$"+&80

              DM "HEX"          ;
              DB "$"+&80

              DM "USR"          ;
              DB "$"+&80

              DB "-"+&80        ; CORRESPONDS TO INKEY$ FPC CODE

              DM "NO"           ;
              DB "T"+&80

              DB "-"+&80        ;
              DB "-"+&80        ;
              DB "-"+&80        ;&79

;BINARY OPERATORS

BINFNTL:      DM "MO"           ;&7A
              DB "D"+&80

              DM "DI"           ;
              DB "V"+&80

              DM "BO"           ;
              DB "R"+&80

              DB "-"+&80

              DM "BAN"          ;
              DB "D"+&80

              DM "O"            ;
              DB "R"+&80

              DM "AN"           ;
              DB "D"+&80

              DM "<"            ;
              DB ">"+&80

              DM "<"            ;
              DB "="+&80

              DM ">"            ;&83
              DB "="+&80



;QUALIFIERS - RANGE &85-&8F

KWDS85:       DM "USIN"             ;&85
              DB "G"+&80

              DM "WRIT"             ;86
              DB "E"+&80

              DM "A"                ;87
              DB "T"+&80

              DM "TA"               ;88
              DB "B"+&80

              DM "OF"               ;89
              DB "F"+&80

              DM "WHIL"             ;8A
              DB "E"+&80

              DM "UNTI"             ;8B
              DB "L"+&80

              DM "LIN"              ;8C
              DB "E"+&80

              DM "THE"              ;8D
              DB "N"+&80

              DM "T"                ;8E
              DB "O"+&80

              DM "STE"              ;8F
              DB "P"+&80

;COMMANDS.  RANGE &90-FEH

              DM "DI"               ;90
              DB "R"+&80

              DM "FORMA"            ;91
              DB "T"+&80

              DM "ERAS"             ;92
              DB "E"+&80

              DM "MOV"              ;93
              DB "E"+&80

              DM "SAV"              ;94
              DB "E"+&80

              DM "LOA"              ;95
              DB "D"+&80

              DM "MERG"             ;96
              DB "E"+&80

              DM "VERIF"            ;97
              DB "Y"+&80

              DM "OPE"              ;98
              DB "N"+&80

              DM "CLOS"             ;99
              DB "E"+&80


              DM "CIRCL"            ;9A
              DB "E"+&80

              DM "PLO"              ;9B
              DB "T"+&80

              DM "LE"               ;9C
              DB "T"+&80

              DM "BLIT"             ;9D
              DB "Z"+&80

              DM "BORDE"            ;9E
              DB "R"+&80

              DM "CL"               ;9F
              DB "S"+&80

KWDSA0:       DM "PALETT"           ;A0
              DB "E"+&80

              DM "PE"               ;A1
              DB "N"+&80

              DM "PAPE"             ;A2
              DB "R"+&80

              DM "FLAS"             ;A3
              DB "H"+&80

              DM "BRIGH"            ;A4
              DB "T"+&80

              DM "INVERS"           ;A5
              DB "E"+&80

              DM "OVE"              ;A6
              DB "R"+&80


              DM "FATPI"            ;A7  0=THIN, 1=FAT
              DB "X"+&80

              DM "CSIZ"             ;A8
              DB "E"+&80

              DM "BLOCK"            ;A9
              DB "S"+&80

              DM "MOD"              ;AA
              DB "E"+&80

              DM "GRA"              ;AB
              DB "B"+&80

              DM "PU"               ;AC
              DB "T"+&80


              DM "BEE"              ;AD
              DB "P"+&80

              DM "SOUN"             ;AE
              DB "D"+&80


              DM "NE"               ;AF
              DB "W"+&80

              DM "RU"               ;B0
              DB "N"+&80

              DM "STO"              ;B1
              DB "P"+&80

              DM "CONTINU"          ;B2
              DB "E"+&80

              DM "CLEA"             ;B3
              DB "R"+&80

              DM "GO T"             ;B4
              DB "O"+&80

              DM "GO SU"            ;B5
              DB "B"+&80

              DM "RETUR"            ;B6
              DB "N"+&80

              DM "RE"               ;B7
              DB "M"+&80


              DM "REA"              ;B8
              DB "D"+&80

              DM "DAT"              ;B9
              DB "A"+&80

              DM "RESTOR"           ;BA
              DB "E"+&80


              DM "PRIN"             ;BB
              DB "T"+&80

              DM "LPRIN"            ;BC
              DB "T"+&80

              DM "LIS"              ;BD
              DB "T"+&80

              DM "LLIS"             ;BE
              DB "T"+&80

              DM "DUM"              ;BF
              DB "P"+&80

KWDSC0:       DM "FO"               ;C0
              DB "R"+&80

              DM "NEX"              ;C1
              DB "T"+&80

              DM "PAUS"             ;C2
              DB "E"+&80

              DM "DRA"              ;C3
              DB "W"+&80

              DM "DEFAUL"           ;C4
              DB "T"+&80

              DM "DI"               ;C5
              DB "M"+&80

              DM "INPU"             ;C6
              DB "T"+&80

              DM "RANDOMIZ"         ;C7
              DB "E"+&80

              DM "DEF F"            ;C8
              DB "N"+&80

              DM "DEF KEYCOD"       ;C9
              DB "E"+&80

              DM "DEF PRO"          ;CA
              DB "C"+&80

              DM "END PRO"          ;CB
              DB "C"+&80

              DM "RENU"             ;CC
              DB "M"+&80

              DM "DELET"            ;CD
              DB "E"+&80

              DM "RE"               ;CE
              DB "F"+&80

              DM "COP"              ;CF
              DB "Y"+&80

              DB "-"+&80            ;D0

              DM "KEYI"             ;D1
              DB "N"+&80

              DM "LOCA"             ;D2
              DB "L"+&80

              DM "LOOP I"           ;D3
              DB "F"+&80

              DM "D"                ;D4
              DB "O"+&80

              DM "LOO"              ;D5
              DB "P"+&80

              DM "EXIT I"           ;D6
              DB "F"+&80

              DM "I"                ;D7
              DB "F"+&80

              DM "I"                ;D8
              DB "F"+&80

              DM "ELS"              ;D9
              DB "E"+&80

              DM "ELS"              ;DA
              DB "E"+&80

              DM "END I"            ;DB
              DB "F"+&80

              DM "KE"               ;DC
              DB "Y"+&80

              DM "ON ERRO"          ;DD
              DB "R"+&80

              DM "O"                ;DE
              DB "N"+&80

              DM "GE"               ;DF
              DB "T"+&80

KWDSE0:       DM "OU"               ;E0
              DB "T"+&80

              DM "POK"              ;E1
              DB "E"+&80

              DM "DPOK"             ;E2
              DB "E"+&80

              DM "RENAM"            ;E3
              DB "E"+&80

              DM "CAL"              ;E4
              DB "L"+&80

              DM "ROL"              ;E5
              DB "L"+&80

              DM "SCROL"            ;E6
              DB "L"+&80

              DM "SCREE"            ;E7
              DB "N"+&80

              DM "DISPLA"           ;E8
              DB "Y"+&80

BTWD:         DM "BOO"              ;E9 USED BY BOOT TO CHECK FILE NAME
              DB "T"+&80

              DM "LABE"             ;EA
              DB "L"+&80

              DM "FIL"              ;EB
              DB "L"+&80

              DM "WINDO"            ;EC
              DB "W"+&80

              DM "AUT"              ;ED
              DB "O"+&80

              DM "PO"               ;EE
              DB "P"+&80

              DM "RECOR"            ;EF
              DB "D"+&80

              DM "DEVIC"            ;F0
              DB "E"+&80

              DM "PROTEC"           ;F1
              DB "T"+&80

              DM "HID"              ;F2
              DB "E"+&80

              DM "ZA"               ;F3
              DB "P"+&80

              DM "PO"               ;F4
              DB "W"+&80

              DM "BOO"              ;F5
              DB "M"+&80

              DM "ZOO"              ;F6
              DB "M"+&80

              DB "-"+&80            ;F7
              DB "-"+&80            ;F8
              DB "-"+&80            ;F9
              DB "-"+&80            ;FA
              DB "-"+&80            ;FB
              DB "-"+&80            ;FC
              DB "-"+&80            ;FD
              DB "-"+&80            ;FE

              DM "IN"               ;FF (FUNCTION PREFIX) AND TEMP "INK" TOKEN
              DB "K"+&80



;DEF KEY INIT TABLE

DKSRC:     DB 192,1,0,&BD                            ;F0 LIST
           DB 193,2,0,&CC,":"                        ;F1 RENUM :
           DB 194,2,0,&BB,":"                        ;F2 PRINT :
           DB 195,2,0,&AA,":"                        ;F3 MODE :
           DB 196,1,0,&B0                            ;F4 RUN
           DB 197,1,0,&B2                            ;F5 CONTINUE
           DB 198,2,0,&9F,"#"                        ;F6 CLS #
           DB 199,3,0,LOADTOK,&22,&22                ;F7 LOAD ""
           DB 200,5,0,LOADTOK,&22,&22,&FF,CODETOK    ;F8 LOAD "" CODE
           DB 201,1,0,&E9                            ;F9 BOOT

           DB 252,2,0,6,":"                          ;TAB
           DB 253,3,0,20,1,":"                       ;INVERSE 1 CC
           DB 254,3,0,20,0,":"                       ;INVERSE 0 CC
DKEN:      DB &FF

;INIT TABLE - 18 BYTES

CHIT:      DB ">"        ;CURRENT LINE CURSOR
           DB 128,129    ;CURSOR CHARACTERS - LOWER CASE/UPPER CASE
           DB "1","0"    ;DIGIT CHARS FOR "BIN$"
           DB "#"        ;INSTR WILD CARD CHAR
           DB "T",TSPEED ;DEVICE T, TAPE SPEED
           DB 17         ;COLOUR FLASH SPEED
           DW LINICOLS   ;LINIPTR
           DB &FF,0,0    ;XCMDP SHOWS "NO EXTERNAL CMDS"

           DB 79         ;PRINTER RHS
           DB 10         ;AFTER CR CHARACTER
           DB &E9        ;PRINTER CONTROL PORT (E8=DATA)
           DB 1          ;PRINTER STROBE BYTE

MAIT:      DW BSTACK     ;BASSTK
           DW HPEND      ;HEAPEND
           DW HPEND      ;HPST  START WITH EMPTY HEAP
           DW FPSB       ;FPSBOT
           DW DKBU       ;DEF KEY BUFFER START
           DW DKBU+128   ;LIMIT OF DEF KEY BUFFER GROWTH
           DW ENDOUTP    ;"PRINTABLE CHARS" O/P ROUTINE
           DW ERRMVAL    ;ERROR MESSAGES
           DW UMVAL      ;"UTILITY" MESSAGES
           DW KTAB       ;KEYBOARD TABLE
           DW CMDADT     ;START OF CMD ADDR TABLE
                         ;FIRST 4 BYTES IN CHANTAB ALSO USED!

CHANTAB:   DW PRMAIN
           DW KYIP
           DB "K"

           DW PRMAIN
           DW KYIP
           DB "S"

           DW ADDCHAR
           DW IDERR
           DB "R"

           DW PRMAIN
           DW IDERR
           DB "P"

           DW S16OP
           DW IDERR
           DB "$"

           DW SENDA
           DW IDERR
           DB "B"

           DB &0D            ;KEEPS READ CMD HAPPY ON FIRST LINE

;KEY MAP FOR 70 KEYS (3 NOT READ THIS WAY) IN UNSHIFTED, CAPS SHIFTED AND SYMB.
;SHIFTED STATES. EACH ROW CORRESPONDS TO A BIT ON THE PORT (BIT 7 AT TOP) AND
;EACH COLUMN TO A PORT MSB. CAPS SHIFT (BIT 0,PORT FE) SCANNED SEPARATELY, AS
;IS SYM SHIFT (BIT 1,PORT 7F) AND CONTROL (BIT 0,PORT FF)

;PORT MSB:     FF  7F  BF  DF  EF  F7  FB  FD  FE
;BIT MAP BYTE  8   7   6   5   4   3   2   1   0

;254 DEFINED AS INVERSE CC,0
;253 DEFINED AS INVERSE CC,1
;252 DEFINED AS CHR$ 6

KSRC:      DB     253,&07,&C0, 12,&06,&C9,198,195  ;BIT 7
           DB "X",".",":", 34,"+",252,200,197,194  ;    6
           DB "X",",",";","=","-"," ",199,196,193  ;    5

           DB &09,"b","h","y","6","5","t","g","v"  ;    4
           DB &08,"n","j","u","7","4","r","f","c"  ;    3
           DB &0A,"m","k","i","8","3","e","d","x"  ;    2
           DB &0B,"X","l","o","9","2","w","s","z"  ;    1
           DB "X"," ",&0D,"p","0","1","q","a"      ;    0

;CAPS SHIFTED

           DB     "\",&07,202,&0E,&06,211,208,205
           DB "X",".",":",127,"*",252,210,207,204
           DB "X",",",";","_","/"," ",209,206,203

           DB &09,"B","H","Y","&","%","T","G","V"
           DB &08,"N","J","U","'","$","R","F","C"
           DB &0A,"M","K","I","(","#","E","D","X"
           DB &0B,"X","L","O",")","@","W","S","Z"
           DB "X"," ",&0D,"P",126,"!","Q","A"

;SYMBOL SHIFTED

           DB     254,&0F,"0",&0E,&06,"9","6","3"
           DB "X",">","*",&CF,"*",252,"8","5","2"
           DB "X","<","+","_","/"," ","7","4","1"

           DB &09,&9E,&5E,157,134,133,"]","}",VERIFYTOK
           DB &08,164,"-",129,135,132,"[","{",168
           DB &0A,165,"+",&A5,128,131,130,&9C,"?"
           DB &0B,"X",&60,148,124,130,">",SAVETOK,"?"
           DB "X"," ",&0D,187,126,129,"<",&B1


;CONTROL KEY TABLE - DISP/VALUE

CKTAB:     DB 19,3           ;BRIGHT CC
           DB 137,1          ;GRAPHICS
           DB 138,8
           DB 136,1
           DB 139,7
           DB 16,1           ;PEN CC
           DB 143,1
           DB 140,9
           DB 141,7
           DB 17,2           ;PAPER CC
           DB 142,0


;INITIAL PALETTE COLOURS - MS GRB BITS, BRIGHT BIT, LS GRB BITS
;                GRBbGRB

INITCOLS:    DB %0000000     ;BLACK
             DB %0010000     ;BLUE
             DB %0100000     ;RED
             DB %0110000     ;MAGENTA
             DB %1000000     ;GREEN
             DB %1010000     ;CYAN
             DB %1100000     ;YELLOW
             DB %1111000     ;WHITE

             DB %0000000     ;BRIGHT BLACK=BLACK
             DB %0010001     ;BLUE
             DB %0100010     ;RED
             DB %0110011     ;MAGENTA
             DB %1000100     ;GREEN
             DB %1010101     ;CYAN
             DB %1100110     ;YELLOW
             DB %1111111     ;WHITE

            ;COLOURS FOR 4-COLOUR MODE

             DB %0000000     ;BLACK
             DB %0010001     ;BLUE
             DB %0100010     ;RED
             DB %1111111     ;WHITE

;COMMAND ADDRESS TABLE.  RANGE 90H-FEH

CMDADT:    DW NONSENSE      ;DIR      90 ** ALTERED
           DW NONSENSE      ;FORMAT   91
           DW NONSENSE      ;ERASE    92
           DW NONSENSE      ;MOVE     93
           DW SLMVC         ;SAVE     94
           DW SLMVC         ;LOAD     95
           DW SLMVC         ;MERGE    96
           DW SLMVC         ;VERIFY   97
           DW OPSCRN        ;OPEN     98
           DW CLSCRN        ;CLOSE    99
           DW CIRCLE        ;CIRCLE   9A
           DW PLOT          ;PLOT     9B
           DW LET           ;LET      9C
           DW BLITZ         ;BLITZ    9D
           DW BORDER        ;BORDER   9E
           DW CLS           ;CLS      9F

           DW COLOUR        ;PALETTE  A0
           DW PERMS         ;INK      A1
           DW PERMS         ;PAPER    A2
           DW PERMS         ;FLASH    A3
           DW PERMS         ;BRIGHT   A4
           DW PERMS         ;INVERSE  A5
           DW PERMS         ;OVER     A6
           DW FATPIX        ;FATPIX   A7  PIXEL WIDTH
           DW WIDTH         ;CSIZE    A8
           DW BGRAPHICS     ;BLOCKS   A9  BLOCK GRAPHICS/UDGS
           DW MODECMD       ;MODE     AA
           DW GRAB          ;GRAB     AB
           DW PUT           ;PUT      AC
           DW BEEP          ;BEEP     AD
           DW SOUND         ;SOUND    AE
           DW NEW           ;NEW      AF

           DW RUN           ;RUN      B0
           DW STOP          ;STOP     B1
           DW CONTINUE      ;CONTINUE B2
           DW CLEAR         ;CLEAR    B3
           DW GOTO          ;GO TO    B4
           DW GOSUB         ;GO SUB   B5
           DW RETURN        ;RETURN   B6
           DW REMARK        ;REM      B7
           DW READ          ;READ     B8
           DW DATA          ;DATA     B9
           DW RESTORE       ;RESTORE  BA
           DW PRINT         ;PRINT    BB
           DW LPRINT        ;LPRINT   BC
           DW LIST          ;LIST     BD
           DW LLIST         ;LLIST    BE
           DW COPY          ;DUMP     BF

           DW FOR           ;FOR         C0
           DW NEXT          ;NEXT        C1
           DW PAUSE         ;PAUSE       C2
           DW DRAW          ;DRAW        C3
           DW DEFAULT       ;DEFAULT     C4
           DW DIM           ;DIM         C5
           DW INPUT         ;INPUT       C6
           DW RANDOMIZE     ;RAND        C7
           DW DEFFN         ;DEF FN      C8
           DW DEFKEY        ;DEF KEYCODE C9
           DW DEFPROC       ;DEF PROC    CA
           DW ENDPROC       ;END PROC    CB
           DW RENUM         ;RENUM       CC
           DW DELETE        ;DELETE      CD
           DW NONSENSE      ;REF         CE
           DW NONSENSE      ;COPY        CF

           DW NONSENSE      ;DRIVER   D0
           DW KEYIN         ;KEYIN    D1
           DW LOCAL         ;LOCAL    D2
           DW LOOPIF        ;LOOP IF  D3
           DW DO            ;DO       D4
           DW LOOP          ;LOOP     D5
           DW EXITIF        ;EXIT IF  D6
           DW LIF           ;LONG IF  D7
           DW SIF           ;SHORT IF D8
           DW LELSE         ;LELSE    D9
           DW ELSE          ;ELSE     DA
           DW ENDIF         ;END IF   DB
           DW KEY           ;KEY      DC
           DW ONERROR       ;ON ERROR DD
           DW ON            ;ON       DE
           DW GET           ;GET      DF

           DW OUT           ;OUT      E0
           DW POKE          ;POKE     E1
           DW DPOKE         ;DPOKE    E2
           DW NONSENSE      ;RENAME   E3
           DW CALLER        ;CALL     E4
           DW ROLL          ;ROLL     E5
           DW SCROLL        ;SCROLL   E6
           DW SCREEN        ;SCREEN   E7
           DW DISPLAY       ;DISPLAY  E8
           DW BOOT          ;BOOT     E9
           DW LABEL         ;LABEL    EA
           DW FILL          ;FILL     EB
           DW WINDOW        ;WINDOW   EC
           DW AUTO          ;AUTO     ED
           DW POP           ;POP      EE
           DW RECORD        ;RECORD   EF

           DW SLDEVICE      ;DEVICE   F0
           DW NONSENSE      ;PROTECT  F1
           DW NONSENSE      ;HIDE     F2
           DW ZAP           ;ZAP      F3
           DW POW           ;POW      F4
           DW BOOM          ;BOOM     F5
           DW ZOOM          ;ZOOM     F6
         ;  DW NONSENSE      ;         F7
          ; DW NONSENSE      ;         F8
          ; DW NONSENSE      ;         F9
          ; DW NONSENSE      ;         FA
          ; DW NONSENSE      ;         FB
          ; DW NONSENSE      ;         FC
          ; DW NONSENSE      ;         FD
          ; DW NONSENSE      ;         FE
          ; DW NONSENSE      ;         FF (FUNCTION PREFIX)


;TABLE FOR CHARS THAT USE ALL 8 SCANS; VALUE TO USE FOR SCAN 8, DISP TO NEXT
;SUCH CHAR, ZERO ENDS TABLE

U8TAB:     DB &08,&78        ;","
           DB &08,&80        ;";"
           DB &00,&A0        ;DUMMY
           DB &FF,&40        ;"_"
           DB &1C,&18        ;"g"
           DB &10,&30        ;"j"
           DB &20,&08        ;"p"
           DB &02,&40        ;"q"
           DB &1C            ;"y"

VVAR2:     DB &00,&5A        ;U8TAB TERMINATOR/SVAR BASE ADDR

;USED BY PRINT NUMBER

SUBTAB:    DW -10000
           DW -1000
           DW -100
           DW -10
;          DB  0  CHARSRC 1ST BYTE IS TERMINATOR!

;CHARSET BY SIMON N. GOODWIN
;CHARACTERS USE CENTRE 6 PIXELS, CAN BE UP TO 8 PIXELS HIGH
;COMPRESSED FORM USES 7 5-BIT SLICES PER CHAR, TAKES 600 BYTES VS 1096

CHARSRC:

    DB &00,&00,&00,&00,&04
    DB &21,&08,&40,&11,&4A
    DB &00,&00,&00,&29,&5F
    DB &57,&D4,&A7,&52,&8E
    DB &29,&5D,&9C,&88,&88
    DB &9C,&D1,&4A,&22,&B2
    DB &69,&84,&40,&00,&00
    DB &08,&88,&42,&08,&30
    DB &41,&08,&44,&40,&95
    DB &77,&DD,&52,&00,&84
    DB &F9,&08,&00,&00,&00
    DB &31,&84,&00,&03,&E0
    DB &00,&00,&00,&00,&06
    DB &30,&42,&22,&22,&10
    DB &74,&67,&5C,&C5,&C4
    DB &61,&08,&42,&39,&D1
    DB &08,&88,&8F,&BA,&21
    DB &30,&62,&E1,&19,&52
    DB &F8,&85,&F8,&78,&21
    DB &8B,&8C,&88,&7A,&31
    DB &77,&C2,&22,&22,&10
    DB &74,&62,&E8,&C5,&CE
    DB &8C,&5E,&11,&30,&00
    DB &31,&80,&63,&00,&06
    DB &30,&0C,&20,&88,&88
    DB &20,&82,&00,&7C,&1F
    DB &00,&20,&82,&08,&88
    DB &83,&A2,&11,&10,&04
    DB &74,&67,&5B,&C1,&CE
    DB &8C,&7F,&18,&C7,&D1
    DB &8F,&A3,&1F,&3A,&30
    DB &84,&22,&EF,&46,&31
    DB &8C,&7D,&F8,&43,&D0
    DB &87,&FF,&08,&7A,&10
    DB &83,&A3,&08,&4E,&2E
    DB &8C,&63,&F8,&C6,&2E
    DB &21,&08,&42,&38,&21
    DB &08,&43,&17,&46,&54
    DB &C5,&25,&18,&42,&10
    DB &84,&3F,&1D,&D6,&31
    DB &8C,&63,&1C,&D6,&71
    DB &8B,&A3,&18,&C6,&2E
    DB &F4,&63,&E8,&42,&0E
    DB &8C,&63,&59,&37,&D1
    DB &8F,&A9,&28,&BA,&30
    DB &70,&62,&EF,&90,&84
    DB &21,&09,&18,&C6,&31
    DB &8B,&A3,&18,&C6,&2A
    DB &24,&63,&18,&D6,&AA
    DB &8C,&54,&45,&46,&31
    DB &8A,&88,&42,&13,&E1
    DB &11,&11,&0F,&9C,&84
    DB &21,&08,&78,&41,&04
    DB &10,&43,&C2,&10,&84
    DB &27,&08,&EA,&90,&84
    DB &20,&00,&00,&00,&00
    DB &32,&51,&C4,&23,&E0
    DB &03,&82,&F8,&BE,&10
    DB &F4,&63,&1F,&00,&0F
    DB &84,&20,&F0,&85,&F1
    DB &8C,&5E,&00,&3A,&3F
    DB &83,&CC,&94,&79,&08
    DB &40,&00,&F8,&C5,&E1
    DB &84,&3D,&18,&C6,&24
    DB &01,&08,&42,&08,&80
    DB &21,&08,&42,&42,&11
    DB &97,&25,&12,&10,&84
    DB &21,&0C,&00,&6A,&B5
    DB &AD,&40,&0F,&46,&31
    DB &88,&00,&E8,&C6,&2E
    DB &00,&3D,&18,&FA,&00
    DB &03,&E3,&17,&84,&00
    DB &B6,&61,&08,&00,&0F
    DB &83,&83,&E2,&11,&E4
    DB &21,&06,&00,&46,&31
    DB &8B,&C0,&08,&C6,&2A
    DB &20,&01,&18,&C6,&AA
    DB &00,&22,&A2,&2A,&20
    DB &04,&63,&17,&84,&00
    DB &F8,&88,&8F,&88,&84
    DB &41,&08,&22,&10,&84
    DB &21,&08,&82,&10,&44
    DB &22,&0A,&A0,&00,&00
    DB &07,&82,&D4,&B4,&3E
    DB &00,&00,&0F,&7B,&C0
    DB &F7,&BC,&00,&00,&C8
    DB &74,&7F,&07,&80

;    DB "AW,BG"

;          DS 0FFFFH-$,0


;          SEND COMPUTER1
;          END &8000     ;dummy value
